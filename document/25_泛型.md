# 为什么要用泛型
## 先看一个需求
<font style="color:rgb(31, 35, 40);">请编写程序，在ArrayList 中，添加3个Dog对象</font>

<font style="color:rgb(31, 35, 40);">Dog对象含有name 和 age, 并输出name 和 age (要求使用getXxx())</font>

```java
package com.hspedu.generic;

import java.util.ArrayList;

@SuppressWarnings({"all"})
public class Generic01 {
    public static void main(String[] args) {

        //使用传统的方法来解决
        ArrayList arrayList = new ArrayList();
        arrayList.add(new Dog("旺财", 10));
        arrayList.add(new Dog("发财", 1));
        arrayList.add(new Dog("小黄", 5));

        //假如程序员，不小心，添加了一只猫
        arrayList.add(new Cat("招财猫", 8)); // 就会报类型转换的错误

        //遍历
        for (Object o : arrayList) {
            //向下转型Object ->Dog
            Dog dog = (Dog) o;
            System.out.println(dog.getName() + "-" + dog.getAge());
        }
    }
}
/*
请编写程序，在ArrayList 中，添加3个Dog对象
Dog对象含有name 和 age, 并输出name 和 age (要求使用getXxx())
 */
class Dog {
    private String name;
    private int age;
    public Dog(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}

class Cat { //Cat类
    private String name;
    private int age;
    public Cat(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

+ 可以看到，在向`arrayList`中加入`Cat`对象时并不会报错
+ 而在转型时，例如本例中在遍历时进行转型`Dog dog = (Dog) o;`，由于`Cat` 实例不能被强制转换成 `Dog` 类型，所以程序会抛出`java.lang.ClassCastException` 并终止运行。

## 泛型体验
**核心结论**：传统方式将类型检查推迟到了**运行时**（Runtime），而不是**编译时**（Compile time）。泛型的目的就是将这种错误提前到编译期间发现。

```java
package com.aurora.generics;

import com.aurora.generics.BasicUse.Dog;

import java.util.ArrayList;

public class GenericDemo01 {
    public static void main(String[] args) {
        ArrayList<Dog> dogs = new ArrayList<>();

        dogs.add(new Dog("旺财", 10));
        dogs.add(new Dog("发财", 1));
        dogs.add(new Dog("大黄", 5));

        //在编译期就会出错
        //dogs.add(new Cat("招财猫"), 8);

        //遍历时直接取出Dog类型就可以，不需要取出Object类型再转型
        for (Dog dog : dogs) {
            System.out.println(dog.getName() + "-" + dog.getAge());
        }
    }
}
```

从以上代码可以看出泛型的好处：

+ **提高了安全性**：设置泛型以后，在编译期发现添加的类型不满足要求，就会直接报错，不能添加成功
+ **<font style="color:rgb(31, 35, 40);">减少了类型转换的次数,提高效率</font>**
    - **<font style="color:rgb(31, 35, 40);">不使用泛型</font>**<font style="color:rgb(31, 35, 40);">：在加入时，会从</font>`<font style="color:rgb(31, 35, 40);">Dog</font>`<font style="color:rgb(31, 35, 40);">转为</font>`<font style="color:rgb(31, 35, 40);">Object</font>`<font style="color:rgb(31, 35, 40);">，在取出时，又需要从</font>`<font style="color:rgb(31, 35, 40);">Object</font>`<font style="color:rgb(31, 35, 40);">转为</font>`<font style="color:rgb(31, 35, 40);">Dog</font>`
    - **使用泛型**：直接以`Dog`的类型加入，遍历时直接取出`Dog`类型就可以，不需要取出`Object`类型再转型

# 泛型介绍
1. **定义**：泛型又称参数化类型，是JDK5.0出现的新特性
2. **核心理解**：
+ 可以将类型理解为变量。例如 `Integer`, `String`, `Dog` 是具体的类型，而泛型（如 `<E>`）是一个类型占位符。
+ **泛(广泛)型(类型)** => 指代任意具体的类型。
3. **泛型的作用与好处**
+ **编译时类型检查**：
    - 可以在类声明或实例化时指定好需要的具体类型。
    - **作用**：如果程序在编译时没有发出警告，运行时就不会产生 `ClassCastException` 异常。
+ **代码更健壮、简洁**：
    - 不再需要进行繁琐的向下转型（强制类型转换）。
+ **灵活的类型定义**：
    - 可以在类声明时通过一个标识（如 `E`, `T`, `K`, `V`）表示：
        * 类中**某个属性**的类型
        * **方法返回值**的类型
        * **参数**的类型
3. 示例

```java
package com.aurora.generics;

public class Person<E> {
    E s;    //E表示属性s的数据类型，E目前只是一个抽象的类型，该数据类型在定义Person对象的时候指定，即在编译期间，就确定E是什么类型

    public Person(E e) {    //E也可以是参数类型
        this.s = e;
    }

    public E get() {    //E也可以是返回类型
        return s;
    }

    public void set(E e) {
        this.s = e;
    }

    public void show() {
        System.out.println(s.getClass());
    }
}
```

```java
package com.aurora.generics;

import com.aurora.generics.BasicUse.Person;

public class GenericDemo02 {
    public static void main(String[] args) {
        Person<String> person = new Person<String>("aurora");
        person.show();  //class java.lang.String

        Person<Integer> person2 = new Person<Integer>(100);
        person2.show();     //class java.lang.Integer
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764318792604-ae415547-7a9c-465e-8ff9-79252f0094a7.png)

+ **泛型替换的原理：**可以将泛型理解为一种模板。当我们在创建对象时指定了具体的类型，编译器会在逻辑上将 `E` 替换为具体的类型。
+ 当执行`new Person<String>("aurora");`时，编译器会将`E`视为`String`，类在逻辑上变成了：

```java
package com.aurora.generics;

public class Person<E> {
    Stirng s;

    public Person(String e) {    // 参数类型变为 String
        this.s = e;
    }

    public String get() {    //返回值类型变为 String
        return s;
    }

    public void set(String e) {	// 参数类型变为 String
        this.s = e;
    }

    public void show() {
        System.out.println(s.getClass());
    }
}
```

+ 当执行`new Person<Integer>(100)` 时，也是一样的道理，编译器会将 `E` 视为 `Integer`

# 泛型的语法
## 泛型的声明
```java
interface 接口<T>{} 和 class 类 <K,V>{}
//比如:List , ArrayList
```

<font style="color:rgb(31, 35, 40);">说明:</font>

1. <font style="color:rgb(31, 35, 40);">其中，T,K,V不代表值,而是表示类型。</font>
2. <font style="color:rgb(31, 35, 40);">任意字母都可以。常用T表示，是Type的缩写</font>

## 泛型的实例化
<font style="color:rgb(31, 35, 40);">要在类名后面指定类型参数的值(类型)。</font>

```java
List<String> strList = new ArrayList<String>();
Iterator<Customer> iterator = customers.iterator();
```

## 泛型使用示例
<font style="color:rgb(31, 35, 40);">举例说明，泛型在HashSet,HashMap的使用情况</font>

<font style="color:rgb(31, 35, 40);">练习:</font>

1. <font style="color:rgb(31, 35, 40);">创建3个学生对象</font>
2. <font style="color:rgb(31, 35, 40);">放入到HashSet中学生对象,使用.</font>
3. <font style="color:rgb(31, 35, 40);">放入到HashMap中，要求Key是String name, Value就是学生对象</font>
4. <font style="color:rgb(31, 35, 40);">使用两种方式遍历</font>

```java
package com.aurora.generics;

public class Student {
    private String name;
    private int age;

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

}
```

```java
package com.aurora.generics;

import com.aurora.generics.BasicUse.Student;

import java.util.*;

@SuppressWarnings("all")
public class GenericPractice01 {
    public static void main(String[] args) {
        Student tom = new Student("tom", 20);
        Student jack = new Student("jack", 19);
        Student jerry = new Student("jerry", 21);

        //将学生对象放进HashSet
        HashSet<Student> students = new HashSet<Student>();
        students.add(tom);
        students.add(jack);
        students.add(jerry);

        //遍历HashSet
        //方式一：使用迭代器遍历
        System.out.println("==========使用迭代器遍历HashSet============");
        Iterator<Student> iterator = students.iterator();
        while (iterator.hasNext()) {
            Student student = iterator.next();
            System.out.println(student);
        }

        //方式二：使用增强for循环遍历
        System.out.println("==========使用增强for循环遍历HashSet============");
        for (Student student : students) {
            System.out.println(student);
        }

        //将学生对象放进HashMap
        HashMap<String, Student> studentsMap = new HashMap<String, Student>();
        studentsMap.put(tom.getName(), tom);
        studentsMap.put(jack.getName(), jack);
        studentsMap.put(jerry.getName(), jerry);

        //遍历HashMap
        //方式一：通过EntrySet()遍历
        System.out.println("==========通过EntrySet()遍历HashMap============");
        Set<Map.Entry<String, Student>> studentsSet = studentsMap.entrySet();
        for (Map.Entry<String, Student> entry : studentsSet) {
            System.out.println(entry.getValue());
        }

        //方式二：通过keySet()遍历
        System.out.println("==========通过keySet()遍历HashMap============");
        Set<String> studentsNames = studentsMap.keySet();
        for (String studentName : studentsNames) {
            System.out.println(studentsMap.get(studentName));
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764322175327-a4e7f080-6de0-4746-a62e-85b7fde1e4e4.png)

## 泛型使用的注意事项和细节
1. **泛型只能是引用类型**
+ 泛型的类型参数（即 `<>` 中的内容）只能是**类**（引用类型），不能是**基本数据类型**。
+ **原因**：Java 的泛型底层实现是基于“类型擦除”的，编译后泛型类型通常会被擦除为 `Object`。基本数据类型（如 `int`, `double`）不是 `Object` 的子类，无法转换为 `Object`。
+ **解决方案**：如果需要存储基本数据类型，必须使用其对应的**包装类**（Wrapper Class）。

```java
// 错误写法
List<int> list = new ArrayList<int>(); 

// 正确写法 (使用 Integer 包装类)
List<Integer> list = new ArrayList<Integer>();
```

2. **泛型赋值支持多态**
+ 在给泛型指定了具体的类型后，实际传入的数据可以是该类型，也可以是该类型的**子类**类型。
+ **示例分析**： 假设有类 `A` 和其子类 `B` (`class B extends A`)。 当我们定义 `Pig<A>` 时，构造器接收的类型 `E` 变为 `A`。由于 Java 的多态特性，`A` 类型的变量可以指向 `B` 类型的对象。

```java
class A {}
class B extends A {}

class Pig<E> {
    E e;
    public Pig(E e) {
        this.e = e;
    }
}

// 使用
Pig<A> aPig = new Pig<A>(new A()); // 传入 A 对象，正确
Pig<A> aPig2 = new Pig<A>(new B()); // 传入 B 对象 (A的子类)，正确
```

3. **泛型的简写形式**
+ 在 JDK 7 及以后的版本中，构造器后面的泛型类型可以省略。编译器会根据变量声明时的泛型类型自动推断出构造器的泛型类型。这被称为“菱形语法”（Diamond Operator）。

```java
// 传统写法 (稍显啰嗦)
ArrayList<Integer> list1 = new ArrayList<Integer>();

// 推荐写法 (简洁，编译器自动推断为 Integer)
ArrayList<Integer> list2 = new ArrayList<>();
ArrayList<Pig> pigs = new ArrayList<>();
```

4. **泛型的默认类型（Object）**
+ 如果在使用泛型类时**没有指定具体的泛型类型**，那么泛型默认会被处理为 `Object` 类型。这通常被称为“原始类型”（Raw Type）。
+ **示例分析**： `Tiger` 类定义了泛型 `E`。如果在实例化 `Tiger` 时没有写 `<...>`，底层会将 `E` 视为 `Object`。

```java
class Tiger<E> {
    E e;

    public Tiger() {
        
    }
    
    public Tiger(E e) {
        this.e = e;
    }
}

// 实际代码
Tiger tiger = new Tiger(); 

// 上面的代码在底层等价于：
// Tiger<Object> tiger = new Tiger<Object>();
// 此时，Tiger 类中的 E e; 变成了 Object e;
```

5. 代码示例总结

```java
package com.aurora.generics;

public class A {
}
```

```java
package com.aurora.generics;

import com.aurora.generics.BasicUse.A;

public class B extends A {
}
```

```java
package com.aurora.generics;

public class Pig<E> {
    E e;

    public Pig() {
    }

    public Pig(E e) {
        this.e = e;
    }

    public void show() {
        System.out.println(e.getClass());
    }
}
```

```java
package com.aurora.generics;

import com.aurora.generics.BasicUse.A;
import com.aurora.generics.BasicUse.B;
import com.aurora.generics.BasicUse.Pig;

import java.util.ArrayList;

@SuppressWarnings("all")
public class GenericDetail {
    public static void main(String[] args) {
        //1.泛型只能是引用类型
        ArrayList<Integer> list = new ArrayList<Integer>();
        //ArrayList<int> list2 = new ArrayList<int>();  //错误

        //2.泛型赋值支持多态
        Pig<A> pig1 = new Pig<A>(new A());
        pig1.show();    //class com.aurora.generics.BasicUse.A
        Pig<A> pig2 = new Pig<A>(new B());
        pig2.show();    //class com.aurora.generics.BasicUse.B

        //3.泛型的简写形式
        ArrayList<Integer> list1 = new ArrayList<>();

        //4.泛型的默认类型（Object）
    }
}
```

# 泛型练习
<font style="color:rgb(31, 35, 40);">定义Employee类</font>

1. <font style="color:rgb(31, 35, 40);">该类包含: private成员变量name, sal, birthday，其中 birthday 为 MyDate 类的对象;</font>
2. <font style="color:rgb(31, 35, 40);">为每一个属性定义getter, setter方法;</font>
3. <font style="color:rgb(31, 35, 40);">重写toString方法输出name, sal, birthday</font>
4. <font style="color:rgb(31, 35, 40);">MyDate类包含:private成员变量month, day, year; 并为每一个属性定义 getter,setter方法;</font>
5. <font style="color:rgb(31, 35, 40);">创建该类的3个对象，并把这些对象放入ArrayList集合中(ArrayList需使用泛型来定义),对集合中的元素进行排序，并遍历输出:</font>
6. <font style="color:rgb(31, 35, 40);">排序方式:调用ArrayList的sort方法，传入 Comparator对象[使用泛型]，先按照name排序，如果name相同，则按生日日期的先后排序。【即:定制排序】</font>

```java
package com.aurora.generics;

public class MyDate implements Comparable<MyDate>{
    private int year;
    private int month;
    private int day;

    public MyDate(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }

    public int getYear() {
        return year;
    }

    public void setYear(int year) {
        this.year = year;
    }

    public int getMonth() {
        return month;
    }

    public void setMonth(int month) {
        this.month = month;
    }

    public int getDay() {
        return day;
    }

    public void setDay(int day) {
        this.day = day;
    }

    @Override
    public String toString() {
        return year + "年"
                + month + "月"
                + day + "日";
    }

    @Override
    public int compareTo(MyDate o) {
        int yearCompare = this.year - o.year;
        if (yearCompare != 0) {
            return yearCompare;
        }

        int monthCompare = this.month - o.month;
        if (monthCompare != 0) {
            return monthCompare;
        }

        return this.day - o.day;
    }
}
```

```java
package com.aurora.generics;

import com.aurora.generics.BasicUse.MyDate;

public class Employee {
    private String name;
    private double salary;
    private MyDate birthday;

    public Employee(String name, double salary, MyDate birthday) {
        this.name = name;
        this.salary = salary;
        this.birthday = birthday;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }

    public MyDate getBirthday() {
        return birthday;
    }

    public void setBirthday(MyDate birthday) {
        this.birthday = birthday;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "name='" + name + '\'' +
                ", salary=" + salary +
                ", birthday=" + birthday +
                '}';
    }
}
```

```java
package com.aurora.generics;

import com.aurora.generics.BasicUse.Employee;
import com.aurora.generics.BasicUse.MyDate;

import java.util.ArrayList;
import java.util.Comparator;

@SuppressWarnings("all")
public class GenericPractice02 {
    public static void main(String[] args) {
        ArrayList<Employee> employees = new ArrayList<>();

        Employee tom = new Employee("tom", 8888.88, new MyDate(2001, 1, 11));
        Employee jack = new Employee("jack", 16666.66, new MyDate(1998, 6, 6));
        Employee jerry = new Employee("tom", 13333.33, new MyDate(2001, 1, 10));

        employees.add(tom);
        employees.add(jack);
        employees.add(jerry);

        System.out.println("===========排序前===========");
        for (Employee employee : employees) {
            System.out.println(employee);
        }

        //排序
        employees.sort(new Comparator<Employee>() {
            @Override
            public int compare(Employee o1, Employee o2) {
                int nameCompare = o1.getName().compareTo(o2.getName());
                if (nameCompare != 0) {
                    return nameCompare;
                }

                return o1.getBirthday().compareTo(o2.getBirthday());
            }
        });

        System.out.println("=============排序后=============");
        for (Employee employee : employees) {
            System.out.println(employee);
        }

    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764475197221-d69dec71-2d88-4edb-a53f-1dcf30ad368c.png)

+ 可以看到为了实现按照生日的排序，`MyDate`类实现了`Comparable`接口，并重写了`compareTo`方法

# 自定义泛型
泛型标识符的约定：虽然你可以用任何字母，但 Java 开发者通常遵循以下约定：

+ `**T**` (Type)：表示任意类。
+ `**E**` (Element)：通常用于集合元素（如 `List<E>`）。
+ `**K**`, `**V**` (Key, Value)：通常用于键值对（如 `Map<K, V>`）。
+ `**N**` (Number)：通常用于数字。

## 自定义泛型类
### 基本定义与语法
1. 定义：自定义泛型类是指在类定义时，声明一个或多个类型参数，供类内部的成员使用。
2. 语法结构：

```java
class 类名 <T, R...> { 	// ... 表示可以有多个泛型标识符
    String name;
    T t;
    R r;
    ...
}
```

+ **标识符约定**：通常使用单个大写字母，如 `T` (Type), `E` (Element), `K` (Key), `V` (Value) 等。

### 泛型的使用细节与规则
1. **普通成员的使用**
+ **普通属性**：可以使用泛型定义变量（如 `T t;`）。
+ **普通方法**：可以使用泛型作为参数类型或返回值类型（如 `public T getT()`, `public void setT(T t)`）。
2. **泛型数组的限制**
+ 使用泛型的数组不能初始化，例如：`T[] ts = new T[8];`
+ **原因**：Java 的泛型是伪泛型（编译时擦除）。在 `new` 的时候，JVM 不知道确切的类型，所以就不知道要分配多大的内存空间，
+ **正确写法**：声明 `T[] ts;` 但不能直接用 `new T[]` 开辟空间。
3. **静态成员的限制**
+ **规则**：**静态方法和静态属性不能使用类的泛型**。
    - ❌ 错误写法：`static T t;`
    - ❌ 错误写法：`public static void m1(T t) {}`
+ **原因**：
    - 静态成员是随着**类加载**而加载的。
    - 泛型类型（如 `T`）是在**创建对象**时才确定的。
    - 在类加载时，对象还没有创建，因此 JVM 无法知道 `T` 代表什么类型，导致无法完成初始化。
4. **泛型类型的确定时机**
+ **确定时机**：泛型的具体类型是在**创建对象**（实例化）时确定的。
+ **默认机制**：如果在创建对象时没有指定泛型类型，编译器会将其默认为 `**Object**`。

### 示例
```java
package com.aurora.generics.CustomGeneric;

import java.util.Arrays;

public class Tiger<T, R, M> {
    private String name;

    //属性使用泛型类型
    private T t;
    private R r;
    private M m;

    //使用泛型的数组不能初始化
    T[] ts;

    public Tiger(String name) {
        this.name = name;
    }

    //构造器使用泛型
    public Tiger(String name, T t, R r, M m, T[] ts) {
        this.name = name;
        this.t = t;
        this.r = r;
        this.m = m;
        this.ts = ts;
    }


    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    //方法使用泛型
    public T getT() {
        return t;
    }

    public void setT(T t) {     //参数使用泛型
        this.t = t;
    }

    public R getR() {
        return r;
    }

    public void setR(R r) {
        this.r = r;
    }

    public M getM() {
        return m;
    }

    public void setM(M m) {
        this.m = m;
    }

    public T[] getTs() {
        return ts;
    }

    public void setTs(T[] ts) {
        this.ts = ts;
    }

    @Override
    public String toString() {
        return "Tiger{" +
                "name='" + name + '\'' +
                ", t=" + t +
                ", r=" + r +
                ", m=" + m +
                ", ts=" + Arrays.toString(ts) +
                '}';
    }
}
```

```java
package com.aurora.generics.CustomGeneric;

@SuppressWarnings("all")
public class CustomGenericDemo01 {
    public static void main(String[] args) {

        //T=Double, R=String, M=Integer
        Tiger<Double, String, Integer> tiger = new Tiger<>("tom", 19.99, "aaa", 100, new Double[]{1.0, 2.0});
        System.out.println("tiger: " + tiger.toString());

//        tiger.setT("yy");     //类型不对，T实际为Double类型

        Tiger tiger2 = new Tiger<>("jerry");
        tiger2.setT("yy");  //可以，在因为创建对象时没有指定泛型类型，编译器会将其默认为 Object，String是Object的子类
        System.out.println("tiger2: " + tiger2.toString());
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764482311338-4b92d88b-2b1c-40bd-b745-5353d99f54e4.png)

## 自定义泛型接口
### 基本定义与语法
1. 定义：泛型接口与泛型类的定义非常相似，接口名后面声明类型参数。
2. 语法结构：

```java
interface 接口名<T, R...> { 
    // ... 表示可以有多个泛型
    // 抽象方法中可以使用这些泛型
    void method(T t);
}
```

### 细节与注意事项
1. **静态成员的限制**
+ **规则**：**接口中的静态成员不能使用泛型**。
+ **原因**：**在接口中，定义的变量默认是 **`**public static final**`**（静态常量）**。静态成员在类加载时初始化，而泛型类型是在使用/实现接口时确定的。在类加载阶段，JVM 无法确定泛型的具体类型，因此禁止使用。
+ 错误示例：`U name;` (等价于 `public static final U name;`)
2. **泛型类型的确定时机**：泛型接口的类型具体是什么，取决于**继承**或**实现**时的操作：
+ **继承接口时确定**：子接口继承父接口时指定类型。
+ **实现接口时确定**：类实现接口时直接指定类型。
+ **默认为 Object**：如果既没有指定也没有保留泛型，系统默认将其视作 `Object`。
3. JDK8默认方法
+ 在 JDK8 及以上版本中，接口中的 `default` (默认) 方法也可以合法地使用接口声明的泛型。

### 示例
```java
package com.aurora.generics.CustomGeneric;

public interface IUsb<U, R> {
    int n = 10;
//    U name;   不能这样用

    //普通方法中，可以使用接口泛型
    R get(U u);

    void hi(R r);

    void run(R r1, R r2, U u1, U u2);

    //在 JDK8 及以上版本中，接口中的 default (默认) 方法也可以合法地使用接口声明的泛型。
    default R method(U u) {
        return null;
    }
}
```

1. **情况A**：在继承接口时指定类型
+ 当我们去实现IA接口时，因为`IA`在继承`IUsb` 接口时，指定了`U`为`String`,`R`为`Double`
+ 在实现`IUsb`接口的方法时，使用`String`替换`U`, 是`Double`替换`R`

```java
package com.aurora.generics.CustomGeneric;

public interface IA extends IUsb<String, Double>{

}
```

```java
package com.aurora.generics.CustomGeneric;

//当我们去实现IA接口时，因为IA在继承IUsb 接口时，指定了U 为String R为Double
//在实现IUsb接口的方法时，使用String替换U, 是Double替换R
public class AA implements IA{
    @Override
    public Double get(String s) {
        return 0.0;
    }

    @Override
    public void hi(Double aDouble) {

    }

    @Override
    public void run(Double r1, Double r2, String u1, String u2) {

    }
}
```

2. **情况B**：在实现接口时指定类型

```java
package com.aurora.generics.CustomGeneric;

public class BB implements IUsb<Integer, Float>{
    @Override
    public Float get(Integer integer) {
        return 0f;
    }

    @Override
    public void hi(Float aFloat) {

    }

    @Override
    public void run(Float r1, Float r2, Integer u1, Integer u2) {

    }
}
```

3. **情况C**：没有指定类型（默认为Object）

```java
package com.aurora.generics.CustomGeneric;

public class CC implements IUsb{
    @Override
    public Object get(Object o) {
        return null;
    }

    @Override
    public void hi(Object o) {

    }

    @Override
    public void run(Object r1, Object r2, Object u1, Object u2) {

    }
}
```

+ **建议**：即使是想用 Object，也建议显式写成 `implements IUsb<Object, Object>`，以增加代码的可读性。

## 自定义泛型方法
### 基本定义与语法
1. **定义**：泛型方法是指**方法自己定义了泛型参数**。它的泛型标识符独立于类，可以定义在任何类中。
2. 语法结构

```java
修饰符 <T, R...> 返回类型 方法名(参数列表) { 
    // ... 
}
```

### 规则
1. **定义位置**
+ **灵活性**：泛型方法既可以定义在**普通类**中，也可以定义在**泛型类**中。
2. **类型确定时机**
+ **调用时确定**：泛型方法的具体类型是在**调用方法**时，根据传入的实参（参数）类型由编译器自动推断的。
+ 例如：`car.fly("宝马", 100)` -> 编译器推断 `T` 为 `String`, `R` 为 `Integer`。
3. 泛型方法vs使用了泛型的方法
+ **泛型方法**：
    - 修饰符后必须有 `<T>`。
    - 它可以独立于类的泛型存在。
    - 示例：`public <K> void hello(K k) { ... }`
+ **使用了泛型的方法**：
    - 修饰符后**没有**`<T>`。
    - 它只是使用了**类声明**的泛型（如泛型类的成员方法）。
    - 示例：`public void hi(T t) { ... }`（假设类是 `class Fish<T>`）。这**不是**泛型方法。
4. **混合使用**

在泛型类中定义泛型方法时，该方法既可以使用**类声明的泛型**，也可以使用**自己声明的泛型**。

```java
class Fish<T> {
    // R 是类定义的泛型
    // K 是方法定义的泛型
    public <K> void method(T t, K k) { ... }
}
```

### 示例
+ 普通类中定义泛型方法

```java
package com.aurora.generics.CustomGeneric;

public class Car {

    //普通方法
    public void run(){

    }

    //泛型方法
    public <T, R> void fly(T t, R r){
        System.out.println(t.getClass());
        System.out.println(r.getClass());
    }
}
```

+ 泛型类中定义泛型方法

```java
package com.aurora.generics.CustomGeneric;

public class Fish<T, R> {

    //普通方法
    public void run(){

    }

    //泛型方法
    public <U, M> void eat(U u, M m){
        System.out.println(u.getClass());
        System.out.println(m.getClass());
    }

    //使用了泛型的方法（不是泛型方法，使用的是类声明的泛型）
    public void hi(T t){

    }

    //泛型方法既可以使用类声明的泛型，也可以使用自己声明的泛型
    public <K> void hello(R r, K k){
        System.out.println(r.getClass());
        System.out.println(k.getClass());
    }
}
```

+ 测试类

```java
package com.aurora.generics.CustomGeneric;

import java.util.ArrayList;

@SuppressWarnings("all")
public class CustomGenericMethod {
    public static void main(String[] args) {
        Car car = new Car();
        //普通类中的fan'xin
        car.fly("Audi", 100);

        System.out.println("==================");

        //T->String, R->ArrayList
        Fish<String, ArrayList>  fish = new Fish<>();
        fish.eat(111, 19.99);
        //泛型类中的泛型方法
        fish.hello(new ArrayList(), 11.3f);

    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764493633842-ad9ac0ed-f8ec-4b7a-b7ed-b579460acdfc.png)

### 练习
<font style="color:rgb(31, 35, 40);">下面代码是否正确，如果有错误，修改正确，并说明输出什么?</font>

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764555712851-c2e4aece-545d-4003-9d55-2acb1904981b.png)

```java
package com.aurora.generics.CustomGeneric;

public class Apple<T,R,M> {
    public <E> void fly(E e){   //泛型方法
        System.out.println(e.getClass().getSimpleName());
    }

//    public void eat(U u){}    //错误，因为U没有声明

    public void run(M m){}
}
```

```java
package com.aurora.generics.CustomGeneric;

public class Dog {
}
```

```java
package com.aurora.generics.CustomGeneric;

public class CustomGenericMethodPractice {
    public static void main(String[] args) {
        Apple<String, Integer, Double> apple = new Apple<>();
        apple.fly(10);  //10 会被自动装箱 Integer10, 输出Integer
        apple.fly(new Dog());   //Dog
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764555819106-ed3c94c3-7262-4048-91a3-afc3d0d63482.png)

# 泛型的继承和通配符
1. **泛型不具有继承性**
+ 在Java中，虽然类之间可能存在继承关系（如 `String` 是 `Object` 的子类），但**泛型容器之间没有继承关系**。
+ **结论**：`List<Object>` 不是 `List<String>` 的父类。
+ 代码示例

```java
// 错误示范
List<Object> list = new ArrayList<String>(); // 编译错误！Type mismatch
```

2. **通配符的概念**：为了解决泛型不可继承带来的局限性（例如无法编写一个方法同时处理 `List<String>` 和 `List<Integer>`），Java 引入了通配符 `?`。
3. **无界通配符**`**<?>**`
+ **含义**：支持任意泛型类型。
+ **读取**：读取出来的对象类型只能保证是 `Object`。
+ **适用场景**：只读取数据，不关心具体类型，或者使用不依赖于类型参数的方法（如 `list.size()`）。
4. **上界通配符**`**<? extends A>**`
+ **含义**：支持 **A类** 以及 **A类的子类**。
+ **规定了泛型的上限**：最高的类型只能是 `A`。
+ **范围**：![image](https://cdn.nlark.com/yuque/__latex/2523b618d19b5cf56d2b51ec07719625.svg)（包含A及其所有子孙类）。
+ **特点**：
    - **能读取**：读取出来的对象肯定可以转型为 `A`。
    - **不能写入**（除了null）：因为不知道具体是哪个子类。
5. **下界通配符**`**<? super A>**`
+ **含义**：支持 **A类** 以及 **A类的父类**（不限于直接父类）。
+ **规定了泛型的下限**：最低的类型必须是 `A`。
+ **范围**：![image](https://cdn.nlark.com/yuque/__latex/62e2a6eb5c278698b78911ec119c92fc.svg) （包含A及其所有祖先类，直到Object）。
+ **特点**：
    - **能写入**：可以向其中添加 `A` 及其子类的对象。
    - **读取受限**：读取出来的对象只能视为 `Object`。
6. **示例**

```java
public class AA {
}

public class BB extends AA {
}

public class CC extends BB{
}

package com.aurora.generics.GenericExtends;

import java.util.ArrayList;
import java.util.List;

@SuppressWarnings("all")
public class GenericExtendsDemo {
    public static void main(String[] args) {
        //类具有继承性
        Object o = new String("hello");

        // --- 1. 泛型的非继承性演示 ---
//        List<Object> list = new ArrayList<String>();  // 编译错误

        List<Object> list1 = new ArrayList<>();
        List<String> list2 = new ArrayList<>();
        List<AA>  list3 = new ArrayList<>();
        List<BB> list4 = new ArrayList<>();
        List<CC> list5 = new ArrayList<>();

        // --- 3. 测试 List<?> (无界通配符) ---
        // 可以接受任何类型的 List
        printCollection1(list1); // √ List<Object>
        printCollection1(list2); // √ List<String>
        printCollection1(list3); // √ List<AA>
        printCollection1(list4); // √ List<BB>
        printCollection1(list5); // √ List<CC>

        // --- 4. 测试 List<? extends AA> (上界通配符) ---
        // 只能接受 AA 或 AA 的子类 (AA, BB, CC)
        // printCollection2(list1); // × List<Object> 是 AA 的父类，不行
        // printCollection2(list2); // × List<String> 与 AA 无关，不行
        printCollection2(list3);    // √ List<AA>
        printCollection2(list4);    // √ List<BB>
        printCollection2(list5);    // √ List<CC>

        // --- 5. 测试 List<? super AA> (下界通配符) ---
        // 只能接受 AA 或 AA 的父类 (AA, Object)
        printCollection3(list1);    // √ List<Object> 是 AA 的父类
        // printCollection3(list2); // × List<String> 不是 AA 的父类
        printCollection3(list3);    // √ List<AA>
        // printCollection3(list4); // × List<BB> 是 AA 的子类，不行（范围太小）
        // printCollection3(list5); // × List<CC> 是 AA 的子类，不行


    }

    /**
     * List<?>: 支持任意泛型类型
     */
    public static void printCollection1(List<?> list) {
        for (Object o : list) {
            System.out.println(o);
        }
    }

    /**
     * List<? extends AA>: 上限为 AA
     * 支持 AA 以及 AA 的所有子类
     */
    public static void printCollection2(List<? extends AA> list) {
        for (Object o : list) {
            System.out.println(o);
        }
    }

    /**
     * List<? super AA>: 下限为 AA
     * 支持 AA 以及 AA 的所有父类
     */
    public static void printCollection3(List<? super AA> list) {
        for (Object o : list) {
            System.out.println(o);
        }
    }
}
```

# 本章作业
## 作业1
<font style="color:rgb(31, 35, 40);">定义个泛型类DAO，在其中定义一个Map成员变量，Map的键为String 类型，值为T类型。</font>

<font style="color:rgb(31, 35, 40);">分别创建以下方法: </font>

+ <font style="color:rgb(31, 35, 40);">public void save(String id,T entity):保存T类型的对象到Map成员变量</font>
+ <font style="color:rgb(31, 35, 40);">public T get(String id):从map中获取id对应的对象</font>
+ <font style="color:rgb(31, 35, 40);">public void update(String id,T entity):替换 map 中key为id的内容,改为entity对象</font>
+ <font style="color:rgb(31, 35, 40);">public List list):返回map中存放的所有T对象</font>
+ <font style="color:rgb(31, 35, 40);">public void delete(String id):删除指定id对象</font>

<font style="color:rgb(31, 35, 40);">定义一个 User类:</font>

+ <font style="color:rgb(31, 35, 40);">该类包含:private成员变量(int类型) id,age; (String类型)name。</font>

<font style="color:rgb(31, 35, 40);">创建 DAO 类的对象，分别调用其save、get、update、list、delete方法来操作User对象，使用 Junit 单元测试类进行测试。</font>

```java
package com.aurora.generics.Practice;

import java.util.*;

public class DAO <T>{

    Map<String, T> map;

    public DAO(Map<String, T> map) {
        this.map = map;
    }

    public void save(String id, T entity) {
        map.put(id, entity);
    }

    public T get(String id) {
        return map.get(id);
    }

    public void update(String id, T entity) {
        map.put(id, entity);
    }

    public List<T> list() {
        return new ArrayList<>(map.values());
    }

//    public List<T> list() {
//        ArrayList<T> list = new ArrayList<>();
//        Collection<T> values = map.values();
//        for (T entity : values) {
//            list.add(entity);
//        }
//        return list;
//    }

    public void delete(String id) {
        map.remove(id);
    }
}
```

```java
package com.aurora.generics.Practice;

import java.util.HashMap;
import java.util.Map;

public class User {
    private int id;
    private int age;
    private String name;

    public User(int id, int age, String name) {
        this.id = id;
        this.age = age;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", age=" + age +
                ", name='" + name + '\'' +
                '}';
    }
}
```

```java
package com.aurora.generics.Practice;

import java.util.HashMap;
import java.util.List;

public class Practice01 {
    public static void main(String[] args) {
        DAO<User> dao = new DAO<>(new HashMap<>());

        //调用save
        dao.save("001", new User(1001, 20, "tom"));
        dao.save("002", new User(1002, 30, "jerry"));
        dao.save("003", new User(1003, 40, "jack"));
        System.out.println(dao);

        //调用get
        System.out.println(dao.get("002"));

        //调用update
        dao.update("003", new User(1010, 33, "mary"));

        //调用list
        List<User> list = dao.list();
        System.out.println(list);

        //调用delete
        dao.delete("001");
        System.out.println(dao.list());
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764565213554-7fe4ae19-5e37-4bfa-b097-33de15efecfa.png)

