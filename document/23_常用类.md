# 包装类
## 包装类的介绍
1. 概念：包装类就是八种基本数据类型对象化的类
2. 作用：某些场景必须使用对象，例如
+ 集合（如 ArrayList）不能存放基本数据类型，只能存对象；
+ 需要使用对象方法（如转换为字符串、比较大小、解析字符串）；
+ 需要使用泛型时。

## 包装类的分类
1. 八种基本数据类型与对应包装类

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763024331232-3ebc741f-4604-4f0c-b4e2-44ca177d6a33.png)

2. 八种包装类的继承关系

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763024380285-93c9f44e-6d2f-4451-a22d-9dd0cdfa7372.png)

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763024392023-71fbfa7d-7699-443b-847b-0692328860b4.png)

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763024403778-a84342eb-16b8-4f7c-b40b-a3d5846095f4.png)

## 包装类和基本数据的转换
1. <font style="color:rgb(31, 35, 40);">jdk5前的手动装箱和拆箱方式，装箱：</font>**<font style="color:rgb(31, 35, 40);">基本类型->包装类型</font>**<font style="color:rgb(31, 35, 40);">。拆箱：</font>**<font style="color:rgb(31, 35, 40);">包装类型->基本类型</font>**<font style="color:rgb(31, 35, 40);">。</font>
+ **手动拆箱**：使用构造方法拆箱、使用`valueOf()`方法拆箱
+ **手动装箱：**根据不同类型使用`intValue()、doubleValue()、booleanValue()`等方法拆箱
2. <font style="color:rgb(31, 35, 40);">jdk5以后(含jdk5)的自动装箱和拆箱方式。</font>
+ <font style="color:rgb(31, 35, 40);">自动装箱底层调用的是</font>`<font style="color:rgb(31, 35, 40);">valueOf()</font>`<font style="color:rgb(31, 35, 40);">方法，比如</font>`<font style="color:rgb(31, 35, 40);">Interger.valueOf(4)</font>`<font style="color:rgb(31, 35, 40);">，其他包装类的用法类似</font>
+ <font style="color:rgb(31, 35, 40);">自动拆箱底层调用的是</font>`<font style="color:rgb(31, 35, 40);">intValue()、doubleValue()、booleanValue()</font>`<font style="color:rgb(31, 35, 40);">等方法</font>
3. <font style="color:rgb(31, 35, 40);">示例——jdk5之间的手动装箱与拆箱</font>

```java
package com.aurora.common_class;

public class IntegerDemo01 {
    public static void main(String[] args) {
        int i = 10;
        double d = 3.14;
        boolean b = true;

        //1.手动装箱
        //方法一：使用构造方法装箱
        Integer integer01 = new Integer(i);
        Double d1 = new Double(d);
        Boolean bool1 = new Boolean(b);

        //方法二：使用valueOf()装箱
        Integer integer02 = Integer.valueOf(i);
        Double d2 = Double.valueOf(d);
        Boolean bool2 = Boolean.valueOf(b);

        //2. 手动拆箱,使用intValue()、doubleValue()、booleanValue()等方法
        int j = integer01.intValue();
        double d3 = d1.doubleValue();
        boolean bool3 = bool1.booleanValue();
    }
}
```

5. 示例——jdk5之后的自动装箱与拆箱

```java
package com.aurora.common_class;

public class IntegerDemo02 {
    public static void main(String[] args) {
        //自动装箱与拆箱
        int i1 = 1;
        double d1 = 3.14;
        boolean b1 = true;

        //自动装箱
        Integer interger01 = i1;
        Double Dou1 = d1;
        Boolean bool1 = b1;

        //自动拆箱
        int i2 = interger01;
        double d2 = Dou1;
        boolean b2 = bool1;
    }
}

```

## 包装类型和String类型的相互转换
1. **包装类->String**：三种方法
+ 方法一：直接加`""`
+ 方法二：使用包装类的`toString`方法，格式：`包装类对象.toString`
+ 方法三：`String.valueOf()`方法
2. **String->包装类**
+ `**valueOf()**`**方法**：要转换成哪个包装类对象，就使用哪个类的`valueOf()`方法，例如`Integer.valueOf(str)`
+ `**parseXXX()**`**方法：**要转换成哪个包装类对象，就是用对应的方法，例如要转换成`Integer`类型，就是用`Integer.parseInt(str)`
+ **使用构造器：**使用要转换成的包装类的构造器转换，例如要转换成`Integer`类型，就使用`Integer i = new Integer(str)`
3. 示例

```java
package com.aurora.common_class;

/*
    String类型与包装类型相互转换
 */

public class Demo03 {
    public static void main(String[] args) {
        //包装类型(以Integer为例)->String类型
        System.out.println("===============包装类型->String==============");
        Integer i = 100;
        //方法一：直接加""
        String str1 = i + "";
        System.out.println("str1 = " + str1);

        //方法二：toString方法
        String str2 = i.toString();
        System.out.println("str2 = " + str2);

        //方法三：String的valueOf()方法
        String str3 = String.valueOf(i);
        System.out.println("str3 = " + str3);


        //String类型转换为包装类型(以Integer为例)
        System.out.println("===============String->包装类型===================");
        String str = "123";
        //方法一：使用valueOf(）方法
        Integer integer1 = Integer.valueOf(str);
        System.out.println("integer1 = " + integer1);

        //方法二：使用parseXXX()方法
        Integer integer2 = Integer.parseInt(str);
        System.out.println("integer2 = " + integer2);

        //方法三：使用构造方法
        Integer integer3 = new Integer(str);
        System.out.println("integer3 = " + integer3);
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763029550118-3ad4602e-7997-48f2-9883-d82274473f10.png)

## Integer类和Character类的常用方法
1. <font style="color:rgb(31, 35, 40);">可以通过图查询到其含有的字段和方法，jump to source 可以查看到源码。</font>

<font style="color:rgb(31, 35, 40);">步骤：先进入到</font>`<font style="color:rgb(31, 35, 40);">Integer</font>`<font style="color:rgb(31, 35, 40);">的源码->右键-></font>`<font style="color:rgb(31, 35, 40);">Diagrams</font>`<font style="color:rgb(31, 35, 40);">-></font>`<font style="color:rgb(31, 35, 40);">Show Diagram</font>`

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763037176117-0c1d68c9-b047-49e5-8b16-92ac6078946b.png)

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763037705764-25fb08e8-0669-4482-8432-ab9b4345ee7d.png)

2. 常用字段与方法示例

```java
package com.aurora.common_class;

public class Demo04 {
    public static void main(String[] args) {
        System.out.println(Integer.MAX_VALUE);  //返回最小值
        System.out.println(Integer.MIN_VALUE);  //返回最大值

        System.out.println(Character.isDigit('a'));     //判断是不是数字
        System.out.println(Character.isLetter('a'));    //判断是不是字母
        System.out.println(Character.isUpperCase('a')); //判断是不是大写
        System.out.println(Character.isLowerCase('a')); //判断是不是小写
        System.out.println(Character.isWhitespace('a'));    //判断是不是空格

        System.out.println(Character.toUpperCase('a')); //转成大写
        System.out.println(Character.toLowerCase('A')); //转成小写
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763038037010-0d957971-9382-4323-a09d-312260a2a1d1.png)

## Integer经典面试题
```java
package com.aurora.common_class;

public class IntegerPractice {
    public static void main(String[] args) {
        Integer i = new Integer(1);
        Integer j = new Integer(1);
        System.out.println(i == j);     //false

        Integer m = 1;
        Integer n = 1;
        System.out.println(m == n);     //true

        Integer x = 128;
        Integer y = 128;
        System.out.println(x == y);     //false

        Integer u = 127;
        Integer v = 127;
        System.out.println(u == v);     //true

        Integer a = 128;
        int b = 128;
        System.out.println(a == b);     //true
    }
}
```

1. 先从**Integer的缓存池**引入
+  **介绍**：Java 为了提高性能，在 `Integer.valueOf()` 中使用了一个静态缓存数组，提前把一些常用的 Integer 对象创建好、存着不动。  
+ **缓存范围**：`[-128, 127]`
+ 当写`Integer i = 10;`时，实际上底层执行的是`Integer.valueOf(10)`，因为10在缓存范围内，就直接返回缓存里的一个Integer对象，而不是new一个新对象。
+ 如果数字不在`[-128, 127]`内，实际底层执行的就是`Integer i = new Integer(128)`，每次`new Integer()`都会创建新的对象
+ Integer缓存池的源码

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

```java
private static class IntegerCache {
    static final Integer cache[];
    static final int low = -128;
    static final int high = 127;

    static {
        cache = new Integer[(high - low) + 1];
        int j = low;
        for(int k = 0; k < cache.length; k++)
            cache[k] = new Integer(j++);
    }
}
```

2. 代码解释

```java
        Integer i = new Integer(1);
        Integer j = new Integer(1);
        System.out.println(i == j);     //false
```

+ 虽然1在`[-128, 127]`范围内，但是我们手动创建了对象，所以`i`和`j`是两个不同的对象，而`i == j`是比较对象的地址，所以结果为`false`

```java
        Integer m = 1;
        Integer n = 1;
        System.out.println(m == n);     //true
```

+ 1在`[-128, 127]`范围内，所以直接返回缓存里的一个Integer对象，而不是new一个新对象， 所以 `m` 和 `n` 其实指向 **同一个缓存对象**，地址相同，因此`m == n`的结果为`true`

```java
        Integer x = 128;
        Integer y = 128;
        System.out.println(x == y);     //false
```

+ 128 超过了缓存范围（-128 ～ 127），因此：  `Integer.valueOf(128)` 会创建新的 Integer 对象`x` 和 `y` 不是同一个对象，所以`x == y`的结果为`false`
3. 包装类和基本类型比较
+ 只要有基本数据类型，判断的就是值是否相同，而不是比较地址
+ 在比较的过程中会发生自动拆箱，把 Integer a 变成 a.intValue()，真正比较的是`a.intValue() == b`

```java
        Integer a = 128;
        int b = 128;
        System.out.println(a == b);     //true
```

+ 因此这里比较的是`a`和`b`的值，二者都是`128`，所以结果为`true`

# String类
## String类介绍
1. <font style="color:rgb(31, 35, 40);">String对象用于保存字符串,也就是一组字符序列</font>
2. <font style="color:rgb(31, 35, 40);">字符串常量对象是用双引号括起的字符序列。例如:"你好"、"12.97"、"boy"等</font>
3. <font style="color:rgb(31, 35, 40);">字符串的字符使用Unicode字符编码，一个字符(不区分字母还是汉字)占两个字节</font>
4. <font style="color:rgb(31, 35, 40);">String类较常用构造器(其它看手册);</font>
+ <font style="color:rgb(31, 35, 40);">String s1 =new String();</font>
+ <font style="color:rgb(31, 35, 40);">String s2 = new String(String original);</font>
+ <font style="color:rgb(31, 35, 40);">String s3 = new String(char[] a);</font>
+ <font style="color:rgb(31, 35, 40);">String s4 = new String(char[] a, int startIndex, int count)</font>
5. String类的特点

 ![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763184647483-08340131-aa1f-4d47-83f2-93ad393c3f78.png)

+ `<font style="color:rgb(31, 35, 40);">String</font>`<font style="color:rgb(31, 35, 40);">类实现了</font>`<font style="color:rgb(31, 35, 40);">Serializable</font>`<font style="color:rgb(31, 35, 40);">接口，说明可以串行化，即可以在网络上传输。</font>
+ `<font style="color:rgb(31, 35, 40);">String</font>`<font style="color:rgb(31, 35, 40);">实现接口</font>`<font style="color:rgb(31, 35, 40);">Comparable</font>`<font style="color:rgb(31, 35, 40);">，说明</font>`<font style="color:rgb(31, 35, 40);">String</font>`<font style="color:rgb(31, 35, 40);">对象可以比较大小</font>
6. 注意：
+ String类是final类，不能被其他的类继承
+ String有属性`private final char value[];`用于存放字符串内容，说明其本质还是`char`数组
+ 一定要注意：value 是一个final类型，不可以修改(地址不能修改)：即value不能指向新的地址，但是单个字符内容是可以变化

```java
package com.aurora.common_class.StringClass;

public class StringDemo01 {
    public static void main(String[] args) {
        String name = "Jack";
        name = "Tom";
        System.out.println(name);

        final char[] value = {'a', 'b', 'c'};
        value[0] = 'd';
        System.out.println(value);

        char[] value2 = {'e', 'f', 'g'};
//        value = value2;       //报错
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763185586814-0d5f7ad2-059f-412b-9cc5-6224f2d7207b.png)

+ **代码解释一：**
    - ** **`String name = "jack";` 这里 `"jack"` 是一个 **字符串常量**，放在 **字符串常量池（String Pool）** 中，`name` 指向它。
    -  `name = "tom";` 这行代码并不是修改 `"jack"`，而是：  
        * 在字符串常量池中找到 `"tom"`（若不存在就创建）
        * 让 `name` 指向 `"tom"`
        *  原来的 String对象`"jack"` 不会被修改，也不会被删除，只是引用变了。
        * 这里改变的只是`name`的引用地址，原来的字符串对象`"jack"`并没有改变地址，只是`name`不在指向它
+ **代码解释二：**
    - ` final char[] value = {'a','b','c'};`这里 `value` 是：
        * 一个 **引用变量**，是 `final`
        * 它指向一个 **可变的 char[] 数组**
        * 即`value`的地址不能改变，但`value`中单个字符内容是可以变化
    -  `value[0] = 'd';`，改变value中的单个字符，合法
+ **代码解释三：**
    - `char[] value2 = {'e', 'f', 'g'};`，新建了一个数组`value2`
    - `value = value2`，非法， 不能改变 final 变量的引用地址，即`value`必须永远指向原来的那个数组。

## 创建String对象的方式
1. **两种方式**
+ 方式一：直接赋值，例如`String name = "Tom";`
+ 方式二：调用构造器：例如`String name = new String("Tom");`
2. 示例

```java
package com.aurora.common_class.StringClass;

public class StringDemo02 {
    public static void main(String[] args) {
        String name1 = "Tom";
        System.out.println(name1);
        
        String name2 = new String("Tom");
        System.out.println(name2);

    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763200456668-b490957d-e13f-4b98-94e4-d82fcfaac950.png)

3. 两种创建方式的区别
+ 方式一：<font style="color:rgb(31, 35, 40);">先从常量池查看是否有"hsp”数据空间,如果有，直接指向;如果没有，则重新创建,然后指向。</font>**<font style="color:rgb(31, 35, 40);">s最终指向的是常量池的空间地址</font>**<font style="color:rgb(31, 35, 40);">。</font>
+ <font style="color:rgb(31, 35, 40);">方式二:先在堆中创建空间，里面维护了value属性，指向常量池的"hsp"空间。如果常量池没有"hsp"，重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址。</font>
4. 两种创建方式的内存分布图

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763200806258-d6ef0581-7bc3-4792-9e83-b64201ac6400.png)

5. 从代码上看两种创建方式的区别

```java
package com.aurora.common_class.StringClass;

/*
    两种创建方式的区别
 */

public class StringDemo03 {
    public static void main(String[] args) {
        String a = "ahu";
        String b = "ahu";
        System.out.println(a == b);         //true
        System.out.println(a.equals(b));    //true

        String c = new String("ahu");
        String d = new String("ahu");
        System.out.println(c == d);         //false
        System.out.println(c.equals(d));    //true

        System.out.println(a == c);         //false
        System.out.println(a.equals(c));    //true

        System.out.println(a == c.intern());    //true
        System.out.println(c == c.intern());    //false
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763201154195-e179c85f-5093-4001-a646-b5ac28f89c06.png)

+ **代码片段1：**
    - `a == b`的结果是`true`，这是因为创建`b`时，常量池中已经有了`"ahu"`，所以`b`会直接指向常量池中的该地址，因此`a`和`b`指向的是常量池中的同一个地址，所以`a == b`的结果是`true`
+ **代码片段2：**
    - `c == d`的结果是`false`，这是因为二者是用构造器创建的，`a`和`b`分别指向堆中的不同地址（构造器构造出的新对象），尽管堆中的这两个新对象都指向常量池中的`"ahu"`
+ **代码片段3：**
    - `a == c`的结果是`false`，因为`a`直接指向常量池中的`"ahu"`，而`c`指向堆中的一个新对象（这个对象又指向常量池中的`"ahu"`），所以`a`和`c`指向的是不同的地址
+ **代码片段4：**
    - `c.intern()`返回的是常量池的地址
    - `a == c.intern()`的结果是`true`，`c == c.intern()`的结果是`false`；因为`a`指向常量池中的`"ahu"`，虽然`c`指向的堆中的地址，但是`c.intern()`最终返回的是最终指向的常量池中的地址，即常量池中`"ahu"`的地址

## 字符串的特性
### 说明
1. **不可变性**
+ String是一个final类，代表不可变的字符序列
+ 字符串是不可变的，一个字符串对象一旦被分配，其内容是不可变的
2. 易错点：以下语句创建了几个对象

```java
String str = "ahut";
str = "ahu";
```

+ 答：只创建了一个对象，String对象`str`从指向常量池中的`"ahut"`变为了指向常量池中的`"ahu"`

### 面试题
1. 以下语句创建了几个对象？

```java
String a = "hello" + "abc";
```

+  在这行语句中，编译器会将其优化为一个常量 `"helloabc"`，并放入常量池。所以只创建了一个新的常量池对象。
+ 内存图

```plain
┌──────────────────────────────────────────────┐
│                方法区 / 常量池                │
├──────────────────────────────────────────────┤
│  "Hello"                                     │
│  "abc"                                       │
│  "Helloabc"   ← 新建并放入常量池              │
└──────────────────────────────────────────────┘

┌──────────────────────────────────────────────┐
│                    堆 Heap                   │
├──────────────────────────────────────────────┤
│   （无额外对象）                              │
└──────────────────────────────────────────────┘

┌──────────────────────────────────────────────┐
│                    栈 Stack                  │
├──────────────────────────────────────────────┤
│ x ─────────────► 指向常量池中的 "Helloabc"    │
└──────────────────────────────────────────────┘
```

2. 以下语句创建了几个对象？

```java
String a = "Hello";
String b = "abc";
String c = a + b;
```

+ **一共创建了三个对象**
+ ** **`String a = "Hello";`和` String b = "abc";`分别创建一个常量池对象（假设`"Hello"`和`"abc"`之前都不在常量池）
+ `String c = a + b;`创建了一个堆中的String对象
    - 注意这里与第一题的区别，虽然`c = a + b`，但是`a`和`b`是变量，不是字面量，因此不会像`"Hello" + "abc"`一样在编译时期进行常量折叠
    - **注意：**新生成的`"Helloabc"`并不会进入常量池，因为**a、b 是变量**，拼接发生在“运行时”，不是“编译期”，所以`a + b` 的结果 `"Helloabc"`是运行时创建的新`String`，存在堆中
+ `String c = a + b;`的底层实现代码

```java
String c = new StringBuilder()
        .append(a)
        .append(b)
        .toString();
```

+ 内存图

```plain
┌──────────────────────────────────────────────┐
│                方法区 / 常量池               │
├──────────────────────────────────────────────┤
│    "Hello"   (常量池对象)                    │
│    "abc"     (常量池对象)                    │
│    （注意："Helloabc" 不在常量池）           │
└──────────────────────────────────────────────┘


┌──────────────────────────────────────────────┐
│                    堆 Heap                    │
├──────────────────────────────────────────────┤
│  new StringBuilder()                          │
│     │                                          │
│     ▼                                          │
│   +----------------------------------+         │
│   |   StringBuilder 对象             |          │
│   |   内部 value[] = ['H','e','l'...| ...]     │
│   +----------------------------------+         │
│            │   append(a).append(b)             │
│            ▼                                   │
│   new String("Helloabc")                       │
│   +----------------------------------+         │
│   |   String 对象（堆中）            |         │
│   |   value[] = "Helloabc"          |         │
│   +----------------------------------+         │
│            ▲                                   │
│            │                                   │
│            c 引用指向此对象                     │
└──────────────────────────────────────────────┘


┌──────────────────────────────────────────────┐
│                  栈 Stack                     │
├──────────────────────────────────────────────┤
│ a ─────────────► 指向常量池中 "Hello"        │
│ b ─────────────► 指向常量池中 "abc"          │
│ c ─────────────► 指向堆中的 "Helloabc"        │
└──────────────────────────────────────────────┘
```

3. **总结**
+ `<font style="color:rgb(31, 35, 40);">String c = "Hello" + "abc";</font>`**<font style="color:rgb(31, 35, 40);">常量相加，看的是池</font>**<font style="color:rgb(31, 35, 40);">。</font>`<font style="color:rgb(31, 35, 40);">String c = a+b;</font>`**<font style="color:rgb(31, 35, 40);">变量相加,是在堆中实现</font>**

### 综合练习
```java
package com.aurora.common_class.StringClass;

public class Test1 {

    String str = new String("ahu");
    final char[] ch = {'j', 'a', 'v', 'a'};

    public void change(String str, char ch[]) {
        str = "hello";
        ch[0] = 'h';
    }

    public static void main(String[] args) {
        Test1 ex = new Test1();
        ex.change(ex.str, ex.ch);
        System.out.println(ex.str);
        System.out.println(ex.ch);
    }
    
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763214279742-74fdf824-0c21-484e-9b19-9a94088dbce3.png)

可以看到输出结果中`ex.str`仍为`"ahu"`，没有被`change`函数中的`str = "hello";`语句修改为`"hello"`

`ex.ch`已经由`"java"`变成了`"hava"`

**接下来从内存图的角度分析**

1. **阶段一：**
+ 时间点：在`ex`对象创建后，`ex.str`和`ex.ch`刚传入函数`ex.change`时（`change`函数中的`str = "hello";`和`ch[0] = 'h';`语句还未执行时）
+ 此时的内存图
    - `Test1`对象`ex`保存在堆中（栈中`main`方法的区域包含指向该处的地址），其中包含参数`str`和`ch`的地址，其中`str`通过堆中的`value`间接指向常量池中的常量`"ahu"`。数组`ch`是保存在堆中的
    - **在Java中调用方法的参数传递都是值传递，**因此在执行语句`ex.change(ex.str, ex.ch);`时，传入的参数实际是`ex.str`和`ex.ch`的值，而`ex.str`中保存的是`value`的地址，`ex.ch`中保存的是字符数组`"java"`的地址，即传入的两个参数分别为堆中`value`的地址、字符数组`"java"`的地址，所以`change`方法栈区域中的**局部变量**`str`和`ch`分别指向`value`和`"java"`
        * ps：这里可能有个疑问，为什么最后打印`ex.str`的时候打印的是最终指向的常量池字符串`"ahu"`，而不是`value`的地址，因为在执行打印语句`System.out.print(ex.str);`时，实际上底层等价于`System.out.print(ex.str.toString());`。这就保证了打印引用对象时不会显示地址，而是显示对象内容。打印`ex.ch`时也类似。

![](https://cdn.nlark.com/yuque/0/2025/jpeg/38867830/1763216540391-36ae35ae-5c57-4715-be13-8589acc79f83.jpeg)

2. **阶段2**
+ 时间点：`change`方法中的`str = "hello";`和`ch[0] = 'h';`语句执行过后
+ 内存图变化
    - `str = "hello";`执行后：`change`函数中的`str`局部变量不再指向`value`，而是在常量池中创建常量池对象`"hello"`后（若初试常量池中没有`"hello"`），指向常量池中的`"hello"`。**这里注意：**前面操作的`str`均为`change`方法中的局部变量，而对象`ex`中的`str`从始至终没有变化
    - `ch[0] = 'h';`执行后：因为`change`方法中的局部变量`ch`也指向字符数组`"java"`，因此`ch[0] = 'h';`会将字符数组中的第一个字符`"j"`改变为`"h"`

![](https://cdn.nlark.com/yuque/0/2025/jpeg/38867830/1763216559285-8ba38466-1376-4166-89f6-638abe68b26b.jpeg)

+ 这就是最终的内存图，可以看到`ex.str`仍然最终指向`"ahu"`，而`ex.ch`指向的字符数组已经由`"java"`被修改成了`"hava"`

## String类的常见方法
1. 常见方法一览（一）
+ `<font style="color:rgb(31, 35, 40);">equals</font>`<font style="color:rgb(31, 35, 40);"> //区分大小写，判断内容是否相等</font>
+ `<font style="color:rgb(31, 35, 40);">equalsIgnoreCase</font>`<font style="color:rgb(31, 35, 40);"> //忽略大小写的判断内容是否相等</font>
+ `<font style="color:rgb(31, 35, 40);">length</font>`<font style="color:rgb(31, 35, 40);"> 获取字符的个数，字符串的长度</font>
+ `<font style="color:rgb(31, 35, 40);">indexOf</font>`<font style="color:rgb(31, 35, 40);"> //获取字符（或字符串）在字符串中第1次出现的索引索引从0开始,如果找不到,返回-1</font>
+ `<font style="color:rgb(31, 35, 40);">lastIndexOf</font>`<font style="color:rgb(31, 35, 40);"> //获取字符在字符串中最后1次出现的索引,索引从0开始,如找不到,返回-1</font>
+ `<font style="color:rgb(31, 35, 40);">substring</font>`<font style="color:rgb(31, 35, 40);"> //截取指定范围的子串</font>
+ `<font style="color:rgb(31, 35, 40);">trim</font>`<font style="color:rgb(31, 35, 40);"> //去前后空格</font>
+ `<font style="color:rgb(31, 35, 40);">charAt</font>`<font style="color:rgb(31, 35, 40);"> // 获取某索引处的字符, 注意不能使用Str[index]这种方式.</font>
2. 示例（一）

```java
package com.aurora.common_class.StringClass;

/*
    String的常用方法
 */

public class StringMethod01 {
    public static void main(String[] args) {
        //1.equals
        String str1 = "hello";
        String str2 = "Hello";
        System.out.println(str1.equals(str2));  //false

        //2.equalsIgnoreCase,可用于登录
        String name = "joHn";
        if ("john".equalsIgnoreCase(name)) {
            System.out.println("Success!");     //Success
        } else  {
            System.out.println("Fail!");
        }

        //3.length
        System.out.println("ahu".length());     //3

        //4.indexof
        String s1 = "eahu@fjahu@fjk";
        int index1 = s1.indexOf("@");    //4
        System.out.println(index1);      //获取字符串的位置
        System.out.println(s1.indexOf("ahu"));  //1

        //5.lastIndexof
        int index2 = s1.lastIndexOf("@");
        System.out.println(index2);     //10
        System.out.println(s1.lastIndexOf("ahu"));  //7

        //6.substring,截取指定范围的字符串
        String str3 = "Hello,World";
        System.out.println(str3.substring(6));  //截取从索引6（包含）之后的所有内容。World
        System.out.println(str3.substring(0,5));    //截取从索引0（包含）到索引5（不包含）之间的所有内容.Hello
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763260275213-57debc55-dcdf-43fd-81e8-732834d4a12f.png)

3. 常见方法一览（二）
+ `<font style="color:rgb(31, 35, 40);">toUpperCase</font>`<font style="color:rgb(31, 35, 40);">：转为大写</font>
+ `<font style="color:rgb(31, 35, 40);">toLowerCase</font>`<font style="color:rgb(31, 35, 40);">：转为小写</font>
+ `<font style="color:rgb(31, 35, 40);">concat</font>`<font style="color:rgb(31, 35, 40);">：拼接字符串</font>
+ `<font style="color:rgb(31, 35, 40);">replace</font>`<font style="color:rgb(31, 35, 40);"> 替换字符串中的字符</font>
    - <font style="color:rgb(31, 35, 40);">注意：使用该方法返回的字符串才是才是替换过的，对元字符串没有影响</font>
+ `<font style="color:rgb(31, 35, 40);">split</font>`<font style="color:rgb(31, 35, 40);"> 分割字符串,对于某些分割字符（如文件夹地址），我们需要转义比如 </font>`<font style="color:rgb(31, 35, 40);">\\</font>`<font style="color:rgb(31, 35, 40);">等</font>

<font style="color:rgb(31, 35, 40);">案例: String poem="锄禾日当午,汗滴未下土,谁知盘中餐,粒粒皆辛苦";和文件路径.</font>

+ `<font style="color:rgb(31, 35, 40);">toCharArray</font>`<font style="color:rgb(31, 35, 40);"> //转换成字符数组</font>
+ `<font style="color:rgb(31, 35, 40);">compareTo</font>`<font style="color:rgb(31, 35, 40);"> //比较两个字符串的大小，</font>`<font style="color:rgb(31, 35, 40);">compareTo</font>`<font style="color:rgb(31, 35, 40);">的比较逻辑是前面</font>**<font style="color:rgb(31, 35, 40);">逐字符比较</font>**<font style="color:rgb(31, 35, 40);">字符编码，有不同的就返回字符编码差值；当直到一个字符到了终点都与另一个字符的前面部分一样时，就返回字符长度的差值</font>
    - <font style="color:rgb(31, 35, 40);">如果前者大，就返回正数，如果后者大，就返回负数，如果相等，就返回0</font>
    - <font style="color:rgb(31, 35, 40);">如果长度相同，并且每个字符也相同，就返回0</font>
    - <font style="color:rgb(31, 35, 40);">如果长度相同或者不同，但是在进行比较时，有字符编码不一致的情况，就返回字符编码差值</font>
    - <font style="color:rgb(31, 35, 40);">如果前面部分都相同，就返回长度差值</font>
+ `<font style="color:rgb(31, 35, 40);">format</font>`<font style="color:rgb(31, 35, 40);"> //格式字符串,%s字符串 %c字符 %d整型 %.2f 浮点型案例，这些占位符会由传入</font>`<font style="color:rgb(31, 35, 40);">format</font>`<font style="color:rgb(31, 35, 40);">函数的后面的参数来替换。使用场景例如将一个人的信息格式化输出。</font>
4. 示例（二）

```java
package com.aurora.common_class.StringClass;

public class StringMethod02 {
    public static void main(String[] args) {

        //1.toUpperCase
        String str1 = "hELlo";
        System.out.println(str1.toUpperCase());     //HELLO

        //2.toLowerCase
        System.out.println(str1.toLowerCase());     //hello

        //3.concat拼接字符串
        String str2 = "hello";
        str2 = str2.concat(",").concat("world").concat("!");    //hello,world!
        System.out.println(str2);

        //4.replace
        String older_str = "宝玉 and 林黛玉 林黛玉 林黛玉";
        String newer_str = older_str.replace("林黛玉", "薛宝钗");
        System.out.println(older_str);  //宝玉 and 林黛玉 林黛玉 林黛玉
        System.out.println(newer_str);  //宝玉 and 薛宝钗 薛宝钗 薛宝钗

        //5.split
        String poem = "锄禾日当午,汗滴禾下土,谁知盘中餐,粒粒皆辛苦";
        String[] split = poem.split(",");
        for (int i = 0; i < split.length; i++) {
            System.out.println(split[i]);
        }
        //需要转义符的情况
        String address = "E:\\aaa\\bbb";
        String[] address_split = address.split("\\\\"); //一个\符号加一个\转义
        for (int i = 0; i < address_split.length; i++) {
            System.out.println(address_split[i]);
        }

        //6.toCharArray
        String str3 = "hello";
        char[] chs = str3.toCharArray();
        for (int i = 0; i < chs.length; i++) {
            System.out.println(chs[i]);
        }

        //7.compareTo
        String a = "jack";
        String b = "jcck";
        System.out.println(a.compareTo(b));     //-2，返回的是'a' - 'c'的值
        a = "jack";
        b = "jackt";
        System.out.println(a.compareTo(b));     //-1,前面都一致，返回的是长度差值，并不是字符编码差值
        a = "jack";
        b = "jcckt";
        System.out.println(a.compareTo(b));     //-2,尽管长度不一样，但是逐字符比较过程中出现了不一致，所以返回字符编码的差值

        //8.format
        String name = "john";
        int age = 10;
        double score = 56.857;
        char gender = '男';

        //常规方法
        System.out.println("我的姓名是" + name + ", 年龄是" + age + ", 成绩是" + score + ", 性别是" + gender + "，希望大家喜欢我");

        String formatStr = "我的姓名是%s, 年龄是%d, 成绩是%.2f, 性别是%c, 希望大家喜欢我";
        String info = String.format(formatStr, name, age, score, gender);
        System.out.println(info);
    }
}
```

+ `**toUpperCase**`**&**`**toLowerCase**`**&**`**concat**`**&**`**replace**`

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763264661645-37221815-8a3d-42f5-a6eb-7a3271a3bbd9.png)

+ `**split**`

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763264709868-85d7b691-8af9-4728-87e9-02359e308d6f.png)

+ `**toCharArray**`

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763264739438-16ec6d29-b64b-4083-a6bc-cfa1af9d64ad.png)

+ `**compareTo**`

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763264767288-1663477e-3511-444b-af1d-c949d20aac9d.png)

+ `**format**`

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763264903847-111917c4-3669-4bb6-9f1f-ea48d7be38ab.png)

# StringBuffer类
## 基本介绍
1. `StringBuffer` 是 Java 提供的 **可变字符序列**，位于 `java.lang` 包中，用来解决 `String` 不可变导致的性能问题。  
2. `StringBuffer`的很多方法与`String`相同，但`StringBuffer`是可变长度的
3. `<font style="color:rgb(31, 35, 40);">StringBuffer</font>`<font style="color:rgb(31, 35, 40);">的直接父类是</font>`<font style="color:rgb(31, 35, 40);">AbstractStringBuilder</font>`
4. `<font style="color:rgb(31, 35, 40);">StringBuffer</font>`<font style="color:rgb(31, 35, 40);">实现了</font>`<font style="color:rgb(31, 35, 40);">Serializable</font>`<font style="color:rgb(31, 35, 40);">, 即</font>`<font style="color:rgb(31, 35, 40);">StringBuffer</font>`<font style="color:rgb(31, 35, 40);">的对象可以串行化</font>
5. 注意
+ <font style="color:rgb(31, 35, 40);">在父类中 </font>`<font style="color:rgb(31, 35, 40);">AbstractStringBuilder</font>`<font style="color:rgb(31, 35, 40);"> 有属性 </font>`<font style="color:rgb(31, 35, 40);">char[] value</font>`<font style="color:rgb(31, 35, 40);">,不是</font>`<font style="color:rgb(31, 35, 40);">final</font>`<font style="color:rgb(31, 35, 40);">，该 value 数组存放 字符串内容，因此存放在堆中的。</font>
+ `<font style="color:rgb(31, 35, 40);">StringBuffer</font>`<font style="color:rgb(31, 35, 40);">是一个 final类，不能被继承</font>
6. **提高效率的方式：****<font style="color:rgb(31, 35, 40);">因为StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除)不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String</font>**<font style="color:rgb(31, 35, 40);">。</font>

```java
public final class StringBuffer extends AbstractStringBuilder {
    char[] value;  // 实际存在父类中
}
```

## String VS StringBuffer
1. `<font style="color:rgb(31, 35, 40);">String</font>`<font style="color:rgb(31, 35, 40);">保存的是字符串</font>**<font style="color:rgb(31, 35, 40);">常量</font>**`<font style="color:rgb(31, 35, 40);">private final char value[];</font>`<font style="color:rgb(31, 35, 40);">。里面的值不能更改，每次String类的更新实际上就是更改地址，效率较低</font>
2. `<font style="color:rgb(31, 35, 40);">StringBuffer</font>`<font style="color:rgb(31, 35, 40);">保存的是字符串</font>**<font style="color:rgb(31, 35, 40);">变量</font>**<font style="color:rgb(31, 35, 40);">，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次更新地址（空间大小不够的时候才会进行扩展），效率较高。</font>

## StringBuffer的构造器
1. `StringBuffer()`：构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763282270475-43f57399-384a-40d7-a6fa-d697096f8915.png)

2. `StringBuffer(int capacity)`，构造一个不带字符，但具有指定初始容量的字符串缓冲区，即对`char[]`大小进行指定

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763282279781-d229ed02-bb99-4e59-8742-d54b02410785.png)

3. `StringBuffer(String str)`：构造一个字符串缓冲区。并将其内容初始化为指定的字符串内容，与`StringBuffer(CharSequence)`类似

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763282309232-920ba931-c8c4-493d-8df2-3b451e5b8a08.png)

4. `StringBuffer(CharSequence)`：构造一个字符缓冲区，它包含与指定的`CharSequence`相同的字符。

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763282321098-daf7e32e-286d-48fd-becf-c39bc36ed0c2.png)

5. 使用示例

```java
package com.aurora.common_class.StringClass;

public class StringBuffer01 {
    public static void main(String[] args) {
        //1. 创建一个 大小为 16的 char[] ,用于存放字符内容
        StringBuffer stringBuffer1 = new StringBuffer();

        //2 通过构造器指定 char[] 大小
        StringBuffer stringBuffer2 = new StringBuffer(100);

        //3. 通过 给一个String 创建 StringBuffer, char[] 大小就是 str.length() + 16
        StringBuffer hello = new StringBuffer("hello");
    }
}
```

## String和StringBuffer相互转换
1. String->StringBuffer的转换方法一：通过构造器
+ 使用构造器`StringBuffer(String str)`
+ 源码如下所示

```java
public StringBuffer(String str) {
    super(str.length() + 16);
    append(str);
}

//super的源码
AbstractStringBuilder(int capacity) {
    value = new char[capacity];
}
```

+ 可以从源码看出底层的原理：构造函数内部新建`char[]`数组，然后再通过`append`将str复制到新数组中
2. String->StringBuffer的转换方法二：使用`append`方法
+ 原理同样是使用`append`复制字符，只不过这里先使用`StringBuffer()`创建一个不带字符的缓冲区，再单独使用`append`方法复制
+ `StringBuffer()`构造器源码

```java
    public StringBuffer() {
        super(16);
    }
```

+ 看到其中并没有`append`
3. String->StringBuffer的两种方式使用示例

```java
package com.aurora.common_class.StringClass;

/*
    String和StringBuffer的相互转换
 */

public class StringBuffer02 {
    public static void main(String[] args) {
        //String->StringBuffer
        //方式一：使用构造器
        String str = "hello";
        StringBuffer stringBuffer1 = new StringBuffer(str);

        //方式二：使用append方法
        StringBuffer stringBuffer2 = new StringBuffer();
        stringBuffer2.append("hello");
    }
}
```

注意：上述的两种方式中，都不影响原来的str

4. StringBuffer->String的转换
+ 方式一：使用StringBuffer提供的`toString`方法
+ 方式二：使用构造器
5. StringBuffer->String的转换示例

```java
package com.aurora.common_class.StringClass;

/*
    StringBuffer->String的转换
 */

public class StringBuffer03 {
    public static void main(String[] args) {
        //方式一：使用toString
        StringBuffer stringBuffer = new StringBuffer("hello");
        String str1 = stringBuffer.toString();


        //方式二：使用构造器
        String str2 = new String(stringBuffer);
    }
}
```

## StringBuffer类常见方法
1. 常见方法一览
+ `append()`： 在 StringBuffer 末尾追加任何类型的数据（字符串、数字、对象等）。  
+ `delete()`：删除`[start, end)`范围内的字符，包含start，不包含end
+ `replace()`： 将 `[start, end)` 内的内容替换成新的字符串。  包含start，不包含end
+ `insert()`： 在指定`index`位置插入任意类型的数据，原来索引为`index`及以后的内容自动后移
+ `length()`：获取当前内容的字符数
2. 使用示例

```java
package com.aurora.common_class.StringClass;

public class StringBufferMethod1 {
    public static void main(String[] args) {
        //1.append
        StringBuffer s1 = new StringBuffer("hello");
        s1.append(",");
        s1.append("world");
        s1.append(1).append(true);
        System.out.println(s1);     //hello,world1true

        //2.delete
        StringBuffer s2 = new StringBuffer("hello,world");
        s2.delete(5, 11);
        System.out.println(s2);     //hello

        //3.replace
        StringBuffer s3 = new StringBuffer("hello,world");
        s3.replace(6, 11, "Java");
        System.out.println(s3);     //hello,Java

        //4.insert
        StringBuffer s4 = new StringBuffer("hello,world");
        s4.insert(5, "Tom");
        System.out.println(s4);

        //5.length()
        StringBuffer s5 = new StringBuffer("hello,world");
        System.out.println(s5.length());
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763346462056-cff98cf3-ced6-4654-86fa-3b099cb5b5b1.png)

## 需要注意的点
```java
package com.aurora.common_class.StringClass;

public class StringBufferTest1 {
    public static void main(String[] args) {
        //append(null)可执行
        String str = null;
        StringBuffer stringBuffer1 = new StringBuffer();    //ok
        stringBuffer1.append(str);  //ok
        System.out.println(stringBuffer1);  //null

        //new StringBuffer(null)不可执行
        StringBuffer stringBuffer2 = new StringBuffer(str);
        System.out.println(stringBuffer2);
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763347053533-eb21243d-3496-40c0-be44-98e1047e3431.png)

1. 先来看看`append(null)`为什么可执行
+ 点开语句`stringBuffer1.append(str);`中`append()`方法的源码，如下：

```java
    public synchronized StringBuffer append(String str) {
        toStringCache = null;
        super.append(str);
        return this;
    }
```

+ 看到调用的是其父类的`append()`方法，再点开该`append()`方法源码，如下

```java
    public AbstractStringBuilder append(String str) {
        if (str == null)
            return appendNull();
        int len = str.length();
        ensureCapacityInternal(count + len);
        str.getChars(0, len, value, count);
        count += len;
        return this;
    }
```

+ 可以看到，如果`str = null` ，那么调用`appendNull()`方法，再点开`appendNull()`方法的源码，如下：

```java
    private AbstractStringBuilder appendNull() {
        int c = count;
        ensureCapacityInternal(c + 4);
        final char[] value = this.value;
        value[c++] = 'n';
        value[c++] = 'u';
        value[c++] = 'l';
        value[c++] = 'l';
        count = c;
        return this;
    }
```

+ 可以看到， null 被自动转成字符数组：`{'n','u','l','l'}`
2. `new StringBuffer(null)`为什么不可执行
+ 来看看构造器`StringBuffer(str)`的源码

```java
    public StringBuffer(String str) {
        super(str.length() + 16);
        append(str);
    }
```

+ 在语句`super(str.length() + 16);`中，`str.length()`会报空指针异常`NullPointerException`

## StringBuffer类练习
1. 需求

输入商品名称和商品价格，要求打印效果示例, 使用前面学习的方法完成：

 商品名	商品价格

手机	123,564.59  //比如 价格 3,456,789.88

要求：价格的小数点前面每三位用逗号隔开, 在输出。

思路分析

1. 定义一个Scanner 对象，接收用户输入的 价格(String)

2. 希望使用到 StringBuffer的 insert ，需要将 String 转成 StringBuffer

3. 然后使用相关方法进行字符串的处理

2. 实现

```java
package com.aurora.common_class.StringClass;

import java.util.Scanner;

public class StringBufferPractice1 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String price = sc.next();
        StringBuffer stringBuffer = new StringBuffer(price);

        /*
            1.找到小数点的位置索引
            2.在小数点的前三位开始，循环每三位插入一个","
         */
        for (int i = stringBuffer.lastIndexOf(".") - 3; i > 0; i -= 3) {
            stringBuffer = stringBuffer.insert(i, ",");
        }

        System.out.println(stringBuffer);
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763348722056-ee315f66-e59c-4b2c-8138-f10cae83bb41.png)

# StringBuilder类
## 基本介绍
1. <font style="color:rgb(31, 35, 40);">一个可变的字符序列。此类提供一个</font>**<font style="color:rgb(31, 35, 40);">与 StringBuffer兼容的API</font>**<font style="color:rgb(31, 35, 40);">，但不保证同步(StringBuilder不是线程安全)。该类被设计用作 StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类。因为</font>**<font style="color:rgb(31, 35, 40);">在大多数实现中，它比 StringBuffer 要快</font>**<font style="color:rgb(31, 35, 40);">。</font>
2. <font style="color:rgb(31, 35, 40);">在 StringBuilder上的主要操作是append 和 insert方法，可重载这些方法, 以接受任意类型的数据。</font>

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763349183460-edd31dbd-bf6b-47a3-ae11-9b295a5529fa.png)

3. <font style="color:rgb(31, 35, 40);">StringBuilder 继承 AbstractStringBuilder 类</font>
4. <font style="color:rgb(31, 35, 40);">实现了 Serializable ,说明StringBuilder对象是可以串行化(对象可以网络传输,可以保存到文件)</font>
5. <font style="color:rgb(31, 35, 40);">StringBuilder 是final类, 不能被继承</font>
6. <font style="color:rgb(31, 35, 40);">StringBuilder 对象字符序列仍然是存放在其父类 AbstractStringBuilder的 char[] value;因此，字符序列是堆中</font>
7. <font style="color:rgb(31, 35, 40);">StringBuilder 的方法，没有做互斥的处理，即没有synchronized 关键字,因此在单线程的情况下使用 StringBuilder</font>

## String、StringBuffer、StringBuilder的比较
<font style="color:rgb(31, 35, 40);">StringBuilder 和 StringBuffer 均代表可变的字符序列，方法是一样的，所以使用和StringBuffer一样。</font>

1. <font style="color:rgb(31, 35, 40);">StringBuilder和 StringBuffer非常类似，均代表可变的字符序列，而且方法也一样</font>
2. <font style="color:rgb(31, 35, 40);">String:不可变字符序列,效率低,但是复用率高（地址都指向它）。</font>
3. <font style="color:rgb(31, 35, 40);">StringBuffer:可变字符序列、效率较高(增删)、线程安全,看源码</font>
4. <font style="color:rgb(31, 35, 40);">StringBuilder:可变字符序列、效率最高、线程不安全</font>
5. <font style="color:rgb(31, 35, 40);">String使用注意说明: </font>
+ `<font style="color:rgb(31, 35, 40);">string s="a";</font>`<font style="color:rgb(31, 35, 40);">//创建了一个字符串</font>
+ `<font style="color:rgb(31, 35, 40);">s +="b";</font>`<font style="color:rgb(31, 35, 40);">//实际上原来的"a"字符串对象已经丢弃了，现在又产生了一个字符串</font>`<font style="color:rgb(31, 35, 40);">s+"b”</font>`<font style="color:rgb(31, 35, 40);">(也就是</font>`<font style="color:rgb(31, 35, 40);">"ab"</font>`<font style="color:rgb(31, 35, 40);">)。</font>
+ <font style="color:rgb(31, 35, 40);">如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大,影响程序的性能</font>

**结论：如果我们对String做大量修改，不要用String**

## String、StringBuffer、StringBuilder的效率测试
每种方式拼接100000次

```java
package com.aurora.common_class.StringClass;

/*
    String、StringBuffer、StringBuilder的效率测试
 */

public class StringVsStringBufferVsStringBuilder {
    public static void main(String[] args) {
        long startTime = 0L;
        long endTime = 0L;

        //String拼接100000次
        String text = "";
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 100000; i++) {
            text = text + i;
        }
        endTime = System.currentTimeMillis();
        System.out.println("String拼接100000次的执行时间" + (endTime - startTime) + "ms");

        //StringBuffer拼接100000次
        StringBuffer stringBuffer = new StringBuffer("");
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 100000; i++) {
            stringBuffer.append(i);
        }
        endTime = System.currentTimeMillis();
        System.out.println("StringBuffer拼接100000次的执行时间"  + (endTime - startTime) + "ms");

        //StringBuilder拼接100000次
        StringBuilder stringBuilder = new StringBuilder("");
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 100000; i++) {
            stringBuilder.append(i);
        }
        endTime = System.currentTimeMillis();
        System.out.println("StringBuilder拼接100000次的执行时间"  + (endTime - startTime) + "ms");
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763350082479-b75f23f9-1eca-41d6-b667-849e68c9b969.png)

## String、StringBuffer、StringBuilder的选择
<font style="color:rgb(31, 35, 40);">使用的原则,结论:</font>

1. <font style="color:rgb(31, 35, 40);">如果字符串存在大量的修改操作，一般使用StringBuffer 或StringBuilder</font>
2. <font style="color:rgb(31, 35, 40);">如果字符串存在大量的修改操作，并在单线程的情况, 使用 StringBuilder</font>
3. <font style="color:rgb(31, 35, 40);">如果字符串存在大量的修改操作，并在多线程的情况，使用 StringBuffer</font>
4. <font style="color:rgb(31, 35, 40);">如果我们字符串很少修改。被多个对象引用，使用String, 比如配置信息等</font>

# Math类
## 基本介绍
<font style="color:rgb(31, 35, 40);">Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。</font>

## <font style="color:rgb(31, 35, 40);">方法一览（均为静态方法）</font>
1. 绝对值方法
+  用于返回各种数值类型的绝对值。  

| 方法 | 说明 |
| --- | --- |
| `static int abs(int a)` | 返回 `int`的绝对值 |
| `static long abs(long a)` | 返回 `long`的绝对值 |
| `static float abs(float a)` | 返回 `float`的绝对值 |
| `static double abs(double a)` | 返回 `double`的绝对值 |


2. 三角函数方法

| 方法 | 作用 |
| --- | --- |
| `sin(double a)` | 返回正弦值 |
| `cos(double a)` | 返回余弦值 |
| `tan(double a)` | 返回正切值 |


注意： Java 中参数单位都是“弧度 radian”，不是角度 degrees！  例如这里应该传入的参数应该类似于`PI`、`PI/2`，而不是角度

3. 反三角函数方法

| 方法 | 作用 | 返回范围 |
| --- | --- | --- |
| `asin(double a)` | 反正弦 | `[-π/2, π/2]` |
| `acos(double a)` | 反余弦 | `[0, π]` |
| `atan(double a)` | 反正切 | `[-π/2, π/2]` |


4. `atan2(double y, double x)`： 将直角坐标系 (x,y) 转换为极坐标角度 θ（弧度）， 可以自动判断象限，比 `atan(y/x)` 更准确。  
5. 立方根`cbrt(double a)`：返回double值的立方根
6. 取整函数

| 方法 | 含义 |
| --- | --- |
| `ceil(double a)` | 向上取整（返回 ≥ a 的最小整数） |
| `floor(double a)` | 向下取整（≤ a 的最大整数） |


7. 四舍五入函数

| 方法 | 返回类型 |
| --- | --- |
| `round(float a)` | int |
| `round(double a)` | long |


实现的原理是先对传入的参数`+0.5`，然后再取`floor`（向下取整），所以与我们数学中学的四舍五入不完全一样，例如数学中对`3.45`四舍五入的结果应该是`4`，而`Math.round(3.45)`的结果是`3`

8. 最大值最小值函数：`Math.max()`、`Math.min()`
9. 指数函数/幂函数方法

| 方法 | 含义 |
| --- | --- |
| `pow(a, b)` | a 的 b 次方 |
| `sqrt(a)` | 平方根 |
| `exp(a)` | e^a |
| `log(a)` | 自然对数 ln(a) |
| `log10(a)` | 以 10 为底的对数 |


10. 随机数：`random`， 返回 `[0.0, 1.0)` 的 double
+ 要生成区间`[a, b)`之间的整数，有公式`(int)(a + Math.random() * (b - a))`
+ 要生成区间`[a, b]`（闭区间）之间的整数，有公式`(int)(a + Math.random() * (b - a + 1))`
+ 其他情况类似
11. 常量：`Math.PI`，`Math.E`

## Math类常见方法使用案例
```java
package com.aurora.common_class;

public class MathClass {
    public static void main(String[] args) {
        //1.abs 绝对值
        int abs = Math.abs(-10);
        System.out.println(abs);    //10

        //2.pow 求幂
        double pow = Math.pow(2, 4);
        System.out.println(pow);    //16.0

        //3.ceil 向上取整
        double ceil = Math.ceil(3.9);
        System.out.println(ceil);   //4.0

        //4.floor 向下取整
        double floor = Math.floor(3.9);
        System.out.println(floor);  //3.0

        //5.round 四舍五入 +0.5后取floor
        long round = Math.round(3.45);
        System.out.println(round);  //3

        //6.sqrt 求开平方
        double sqrt = Math.sqrt(9.0);
        System.out.println(sqrt);   //3.0

        //7.random 随机数
        double random1 = Math.random(); //取[0, 1)之间的随机数
        System.out.println(random1);
        double random2 = (int) (Math.random() * 10); //取[0, 10)之间的随机整数
        System.out.println(random2);
        double random3 = (int) (Math.random() * 5 + 2); //取[2, 7)之间的随机整数
        System.out.println(random3);

        //8.返回最大值和最小值
        int max = Math.max(10, 20);
        System.out.println(max);
        double min = Math.min(3.5, 4.5);  //参数和返回值都有多种类型，返回值随着参数变化而变化
        System.out.println(min);
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763354153868-6a4d26dc-1a37-4e57-b269-a236f9f20bca.png)

# Arrays类
## 方法一览
<font style="color:rgb(31, 35, 40);">Arrays里面包含了一系列静态方法，用于管理或操作数组(比如排序和搜索)</font>

1. `toString`：返回数组的字符串形式，使用方式`Arrays.toString(arr)`， 找到时返回索引，找不到返回 -(插入点)-1  
2. <font style="color:rgb(31, 35, 40);">sort 排序(自然排序和定制排序) ，详细理解见后面</font>
3. `<font style="color:rgb(31, 35, 40);">binarySearch(arr)</font>`<font style="color:rgb(31, 35, 40);">：通过二分搜索法进行查找，要求必须先排好序。</font>
4. `<font style="color:rgb(31, 35, 40);">copyOf(arr, newLength)</font>`<font style="color:rgb(31, 35, 40);">：数组元素的复制</font>
+ <font style="color:rgb(31, 35, 40);">从 arr 数组中，拷贝 </font>`<font style="color:rgb(31, 35, 40);">newLength </font>`<font style="color:rgb(31, 35, 40);">个元素到 newArr数组中</font>
+ <font style="color:rgb(31, 35, 40);">如果拷贝的长度 > </font>`<font style="color:rgb(31, 35, 40);">arr.length</font>`<font style="color:rgb(31, 35, 40);"> 就在新数组的后面增加 </font>`<font style="color:rgb(31, 35, 40);">null</font>`
+ <font style="color:rgb(31, 35, 40);">如果拷贝长度 < 0 就抛出异常 NegativeArraySizeException</font>
5. `<font style="color:rgb(31, 35, 40);">fill(arr, val)</font>`<font style="color:rgb(31, 35, 40);">：数组元素的填充, 把数组中</font>`<font style="color:rgb(31, 35, 40);">arr</font>`<font style="color:rgb(31, 35, 40);">的所有元素设置为同一个值</font>`<font style="color:rgb(31, 35, 40);">val</font>`<font style="color:rgb(31, 35, 40);">。</font>
6. `<font style="color:rgb(31, 35, 40);">equals(arr1, arr2)</font>`<font style="color:rgb(31, 35, 40);">：比较两个数组元素的内容是否完全一致</font>
7. `<font style="color:rgb(31, 35, 40);">asList</font>`<font style="color:rgb(31, 35, 40);">：将一组值，转换成list</font>
+ 注意：asList() 返回的不是 java.util.ArrayList，而是 **Arrays 中的内部类 **`**Arrays$ArrayList**`

## 使用示例
```java
package com.aurora.common_class.ArraysClass;

import java.util.Arrays;
import java.util.List;

public class ArraysMethod01 {
    public static void main(String[] args) {
        //1.toString
        Integer[] integers = {10, 20, 90};
        System.out.println(Arrays.toString(integers));

        //2.binarySearch
        Integer[] arr1 = {1, 2, 90, 123, 567};
        int index1 = Arrays.binarySearch(arr1, 567);
        System.out.println(index1); //4
        int index2 = Arrays.binarySearch(arr1, 10); //找不到
        System.out.println(index2); //-3

        //3.copyOf
        Integer[] new_arr1 = Arrays.copyOf(integers, 2);
        System.out.println(Arrays.toString(new_arr1));  //[10, 20]
        Integer[] new_arr2 = Arrays.copyOf(integers, 4);
        System.out.println(Arrays.toString(new_arr2));  //[10, 20, 90, null]

        //4.fill数组元素的填充
        Integer[] arr2 = {1, 2, 90, 123};
        Arrays.fill(arr2, 3);
        System.out.println(Arrays.toString(arr2));  //[3, 3, 3, 3]

        //5.equals
        Integer[] arr3 = {1, 2, 90, 123};
        Integer[] arr4 = {1, 2, 90, 123, 567};
        boolean equals = Arrays.equals(arr3, arr4);
        System.out.println(equals);     //false

        //6.asList
        List list = Arrays.asList(1, 2, 3, 4, 5, 6);
        System.out.println(list);   //[1, 2, 3, 4, 5, 6]
        System.out.println("list的与逆行类型" + list.getClass());     //list的与逆行类型class java.util.Arrays$ArrayList
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763374922130-da8caade-c478-4606-8dc0-4de16487858b.png)

## sort方法
+ 因为数组是引用类型，所以通过sort排序后，会直接影响到实参`arr`

这个方法很重要，并且可以**自然排序**，也可以根据自己的要求进行**定制排序**

### 自然排序
1. 适用数据类型
+ **基本类型数组**：int、double、char 等
+ **包装类/引用类型数组**：Integer、String、Double 等（这些类实现了 `Comparable` 接口）
2. 使用方式：`Arrays.sort(arr);`
3. 原理
+ 如果是 **基本类型数组**：使用 **Dual-Pivot Quicksort（双轴快排）**
+ 如果是 **对象数组**：调用对象的 **compareTo()** 方法，例如 String 的 compareTo 按字典序（字符编码）比较字符。
4. 使用示例

```java
package com.aurora.common_class.ArraysClass;

/*
    自然排序的使用
 */

import java.util.Arrays;

public class sortDemo01 {
    public static void main(String[] args) {
        //基本数据类型
        int[] arr = {1, -1, 7, 0 , 89};
        Arrays.sort(arr);
        System.out.println(Arrays.toString(arr));

        //对象数组
        String[] strs = {"jack", "tom", "alice"};
        Arrays.sort(strs);
        System.out.println(Arrays.toString(strs));
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763369141717-0d68a52e-737f-4e38-a890-38a674e86326.png)

### 定制排序
1. 适用条件： **对象**没有想要的自然顺序，需要 **自己指定比较规则**，通过：  

```java
Arrays.sort(array, new Comparator<T>() {
    @Override
    public int compare(T o1, T o2) {
        return ...;  // 返回 int
    }
});
```

+ 其中`compare(o1, o2)`返回值的含义：
    - **>0**：o1 > o2（交换o1和o2）
    - **<0**：o1 < o2（不交换o1和o2）
    - **0**：认为相等
+ 于是就可以通过改变返回值来达到想要的顺序，例如：
    - `return o1 - o2;`：而`o1 - o2 > 0`时会发生交换，此时`o1 > o2`，那么交换`o1` 和`o2`的位置，最终就是升序排序（较大的`o1`换到后面了）
    - 如果想要降序排序，那就可以`return o2 - o1;`，`o2 - o1 > 0`时发生交换，此时`o2 > o1`，那么交换`o1` 和`o2`的位置，最终就是降序排序（较大的`o2`换到前面了）
+ 注意：只能用于**对象**数组的排序，因为普通数据类型，例如`int`，它们没有`Comparator`（比较器），所以根本不可能进行定制排序
2. 整数倒序的示例

```java
package com.aurora.common_class.ArraysClass;

import java.util.Arrays;
import java.util.Comparator;

public class sortDemo02 {
    public static void main(String[] args) {
        Integer[] arr = {3, 1, 5, 7, 2};
        Arrays.sort(arr, new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2 - o1;
            }
        });
        System.out.println(Arrays.toString(arr));
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763369938602-a5c92e9a-709d-4f4a-a03c-13ab20feca59.png)

3. 也可以不按照数字大小排序，例如传入字符串数组，按照字符串的长度排序

```java
package com.aurora.common_class.ArraysClass;

import java.util.Arrays;
import java.util.Comparator;

public class sortDemo03 {
    public static void main(String[] args) {
        String[] arr = {"jack", "tom", "a", "alice"};
        Arrays.sort(arr, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return o1.length() - o2.length();
            }
        });

        System.out.println(Arrays.toString(arr));
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763370623497-9bf1b27d-b9c3-4105-b86a-fdf0d92dd7ca.png)

4. 也可以按照对象的某个属性进行排序

```java
package com.aurora.common_class.ArraysClass;

public class Person {
    String name;
    int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

```java
package com.aurora.common_class.ArraysClass;

import java.util.Arrays;
import java.util.Comparator;

public class sortDemo04 {
    public static void main(String[] args) {
        Person person1 = new Person("Tom", 20);
        Person person2 = new Person("Jack", 10);
        Person person3 = new Person("Alice", 30);

        Person[] persons = {person1, person2, person3};

        Arrays.sort(persons, new Comparator<Person>() {
            @Override
            public int compare(Person o1, Person o2) {
                return o1.age - o2.age;
            }
        });

        for (Person person : persons) {
            System.out.println(person.toString());
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763370963915-b078c980-7ddb-4653-a508-32c1f6607fc2.png)

5. `Comparator`的简易写法：`Lambda`表达式
+ 例如对`Integer`数组的定制排序代码：

```java
Arrays.sort(arr, new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return o2 - o1;
    }
});
```

+ 使用Lambda表达式后可写为：

```java
Arrays.sort(arr, ((o1, o2) -> o2 - o1));
```

6. 定制冒泡排序
+ 整体功能： 这是对 `Integer[]` 数组进行冒泡排序，并且排序规则由外部传入的 `Comparator<Integer>` 来决定。  也就是说：
    - 不是固定升序、降序
    - 排序行为由 `c.compare(x, y)` 的返回值决定
    - 是一个“可定制”的冒泡排序

```java
package com.aurora.common_class.ArraysClass;

import java.util.Arrays;
import java.util.Comparator;

public class sortAndBubble {
    public static void main(String[] args) {
        Integer[] arr = {3, 1, 5, 7, 2};
        bubbleSort(arr, new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2 - o1; //降序
            }
        });

        System.out.println(Arrays.toString(arr));
    }

    public static void bubbleSort(Integer[] arr, Comparator<Integer> comparator) {
        for (int i = 0; i < arr.length - 1; i++) {
            for (int j = 0; j < arr.length - i - 1; j++) {
                if (comparator.compare(arr[j], arr[j + 1]) > 0) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763372865245-5439da50-dc73-473e-8f8e-3fd1c38e56d9.png)

+ 扩展：也可以将定制冒泡排序扩展到对`String`数组进行排序，通过对象的某个属性对对象排序等

# System类
## System的常见方法
1. ` System.exit(int status)`：退出当前程序，并返回一个操作码给系统。
+ 参数含义：
    - `0` → **正常退出**（无错误）  
    - 非 0 → **异常退出**（一般用作错误码）
2. ` System.arraycopy`：从一个数组复制元素到另一个数组，效率非常高
+ 方法原型

```java
System.arraycopy(Object src, int srcPos,
                 Object dest, int destPos,
                 int length)
```

+ 参数含义：
    - `src`：源数组
    - `srcPos`：从源数组的那个索引位置开始拷贝
    - `dest`：目标数组
    - `destPos`：把源数组的数据拷贝到目标数组的哪个索引
    - `length`：从源数组拷贝多少个数据到目标数组
+ 一般还是使用`Arrays.copyOf()`，因为更简单，只需要两个参数
3. `System.currentTimeMillis()`： 返回当前时间距离 **1970-01-01 00:00:00 UTC** 的毫秒数，返回值类型为`long`
4. `System.gc()`： 通知 JVM 执行垃圾回收，但 **不保证立刻执行**。实际行为：
+ JVM **可能收**
+ JVM **可能不收**
+ JVM 会根据自己的优化策略决定何时执行

## 常见方法示例
```java
package com.aurora.common_class.SystemClass;

public class exitDemo {
    public static void main(String[] args) {
        System.out.println("aaa");
        System.exit(0);
        System.out.println("bbb");  //不会执行
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763380074587-3dc1c363-465e-4f05-898f-d514147a54f3.png)

```java
package com.aurora.common_class.SystemClass;

import java.util.Arrays;

public class SystemMethod1 {
    public static void main(String[] args) {
        //arraycopy
        int[] src = {1, 2, 3, 4, 5};
        int[] dest = new int[5];

        //从源数组src的索引位置1开始，复制三个元素到目标数组dest(从索引位置2开始)
        System.arraycopy(src, 1, dest, 2, 3);
        System.out.println(Arrays.toString(dest));

        //System.currentTimeMillis()
        System.out.println(System.currentTimeMillis());
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763380850724-e04992bd-fe24-49ec-b795-dbf38aa50cd6.png)

# BigInteger和BigDecimal类
## 介绍
<font style="color:rgb(31, 35, 40);">应用场景:</font>

1. <font style="color:rgb(31, 35, 40);">Biglnteger 适合保存比较大的整型</font>
2. <font style="color:rgb(31, 35, 40);">BigDecimal 适合保存精度更高的浮点型(小数)</font>

## 构造方式
1. `BigInteger`
+ 通过字符串构造：`BigInteger b1 = new BigInteger("123456789123456789123456789");`
+ 不能写成数字（会溢出）：`BigInteger b2 = new BigInteger(123456789123456789L); `
2. `BigDecimal`
+ 通过字符串构造：`BigDecimal b1 = new BigDecimal("0.1");`
+ 错误方式：直接使用double，`BigDecimal b1 = new BigDecimal(0.1);`，这种方式不精确

## <font style="color:rgb(31, 35, 40);">常见方法及使用示例</font>
<font style="color:rgb(31, 35, 40);">在</font><font style="color:rgb(31, 35, 40);">对 </font>`<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">BigInteger</font>`<font style="color:rgb(31, 35, 40);"> 和</font>`<font style="color:rgb(31, 35, 40);">bigDecimal</font>`<font style="color:rgb(31, 35, 40);">进行加减乘除的时候，需要使用对应的方法，不能直接进行 + - * /</font>

1. `<font style="color:rgb(31, 35, 40);">add</font>`<font style="color:rgb(31, 35, 40);"> 加</font>
2. `<font style="color:rgb(31, 35, 40);">subtract</font>`<font style="color:rgb(31, 35, 40);"> 减</font>
3. `<font style="color:rgb(31, 35, 40);">multiply</font>`<font style="color:rgb(31, 35, 40);"> 乘</font>
4. `<font style="color:rgb(31, 35, 40);">divide</font>`<font style="color:rgb(31, 35, 40);"> 除</font>

**注意：**对于`BigDecimal`，很多情况下小数除法不能整除，所以必须进行舍入，而`BigDecimal`的`divide`方法在使用时必须传入舍入方式的参数，常见的舍入方式如下：

| 模式 | 含义 | 场景 | 是否常用 |
| --- | --- | --- | --- |
| HALF_UP | 四舍五入 | 金融金额 | ⭐⭐⭐⭐⭐（最常用） |
| HALF_EVEN | 银行家算法 | 银行利息、金融统计 | ⭐⭐⭐⭐ |
| UP | 绝对值方向进 1 | 税率计算 | ⭐⭐ |
| DOWN | 截断 | 精度要求不严格 | ⭐⭐ |
| CEILING | 向正无穷 | 价格上调（如商品价） | ⭐⭐ |
| FLOOR | 向负无穷 | 成本下调 | ⭐⭐ |
| HALF_DOWN | 五舍六入 | 较少用 | ⭐ |
| UNNECESSARY | 不允许舍入 | 特殊算法 | ⭐ |


```java
package com.aurora.common_class.BigIntegerAndBigDecimal;

import java.math.BigInteger;

public class BigIntegerMethod {
    public static void main(String[] args) {
        BigInteger bigInteger1 = new BigInteger("9999999999999999999999999999999999999999999999999");
        BigInteger bigInteger2 = new BigInteger("8888888888888888888888888888888888888");

        //1.add
        BigInteger add = bigInteger1.add(bigInteger2);
        System.out.println("add:"+add);

        //2.subtract
        BigInteger sub = bigInteger1.subtract(bigInteger2);
        System.out.println("sub:"+sub);

        //3.multiply
        BigInteger mul = bigInteger1.multiply(bigInteger2);
        System.out.println("mul:"+mul);

        //4.divide
        BigInteger div = bigInteger1.divide(bigInteger2);
        System.out.println("div:"+div);
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763384125125-192abacc-b73c-4ecb-8fb4-445dd3dfcac4.png)

```java
package com.aurora.common_class.BigIntegerAndBigDecimal;

import java.math.BigDecimal;

public class BigDecimalMethod {
    public static void main(String[] args) {
        //普通的double运算不精确
        double d1 = 0.1;
        double d2 = 0.2;
        double result = d1 + d2;
        System.out.println("result = " + result);

        //BigDecimal
        BigDecimal b1 = new BigDecimal("0.1");
        BigDecimal b2 = new BigDecimal("0.2");

        //1.add
        BigDecimal add = b1.add(b2);
        System.out.println("add = " + add);

        //2.subtract
        BigDecimal sub = b1.subtract(b2);
        System.out.println("sub = " + sub);

        //3.multiply
        BigDecimal mul = b1.multiply(b2);
        System.out.println("mul = " + mul);

        //4.divide
        BigDecimal div = b1.divide(b2, 10, BigDecimal.ROUND_HALF_UP);
        System.out.println("div = " + div);
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763386010450-4a82d773-66fa-4868-a010-a2a754c04b3b.png)

# 日期类
## 第一代日期类
1. `**<font style="color:rgb(31, 35, 40);">Date</font>**`**<font style="color:rgb(31, 35, 40);">类</font>**
+ <font style="color:rgb(31, 35, 40);">精确到毫秒,代表特定的瞬间</font>
+ <font style="color:rgb(31, 35, 40);">获取当前系统的时间：</font>`<font style="color:rgb(31, 35, 40);">Date d = new Date();</font>`
+ <font style="color:rgb(31, 35, 40);">也可以通过指定毫秒数生成日期：</font>`<font style="color:rgb(31, 35, 40);">new Date(9234567);</font>`
+ <font style="color:rgb(31, 35, 40);"> Date 默认输出格式比较难看，可读性差，因此通常需要格式化。  </font>
2. `**<font style="color:rgb(31, 35, 40);">SimpleDateFormat</font>**`**<font style="color:rgb(31, 35, 40);">类</font>**
+ <font style="color:rgb(31, 35, 40);">作用：格式和解析日期的类， 格式化（Date → String）， 解析（String → Date）</font>
+ <font style="color:rgb(31, 35, 40);">常用时间格式字母表（不能乱写，这是规则）：</font>

| 字母 | 含义 | 示例 |
| --- | --- | --- |
| yyyy | 年 | 2023 |
| MM | 月 | 04 |
| dd | 日 | 24 |
| HH | 小时（24 小时制） | 13 |
| hh | 小时（12 小时制） | 01 |
| mm | 分钟 | 40 |
| ss | 秒 | 14 |
| E | 星期 | 星期一 |
| a | 上午/下午 | 上午 |


+ 格式化：`<font style="color:rgb(31, 35, 40);">format()</font>`
+ <font style="color:rgb(31, 35, 40);">解析：</font>`<font style="color:rgb(31, 35, 40);">parse()</font>`
3. 使用示例

```java
package com.aurora.common_class.DateClass;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class DateDemo01 {
    public static void main(String[] args) throws ParseException {
        //获取当前系统的时间
        Date date1 = new Date();
        System.out.println("当前时间 = " + date1);

        //通过指定毫秒数获得时间
        Date date2 = new Date(9234567);
        System.out.println("date2 = " + date2);

        //创建SimpleDateFormat对象，指定格式
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 hh:mm:ss E");

        //格式化
        String format = sdf.format(date1);
        System.out.println("format = " + format);

        //解析
        Date parse = sdf.parse(format);
        System.out.println("parse = " + parse);
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763387451415-54aa14aa-efd2-49cb-a6da-cc31652131ae.png)

## 第二代日期类
1. <font style="color:rgb(31, 35, 40);">第二代日期类，主要就是Calendar类(日历)。 </font>`<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">public abstract class Calendar extends Object implements Serialzable,Cloneable, Comparable<Calendar></font>`
2. <font style="color:rgb(31, 35, 40);">Calendar类是一个抽象类，它为特定瞬间与一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等日历定股之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期)提供了一些方法。</font>
3. `<font style="color:rgb(31, 35, 40);">Calender</font>`<font style="color:rgb(31, 35, 40);">的构造器是</font>`<font style="color:rgb(31, 35, 40);">private</font>`<font style="color:rgb(31, 35, 40);">的，所以不能直接通过构造器类创建对象，通常通过</font>`<font style="color:rgb(31, 35, 40);">Calender.getInstance()</font>`<font style="color:rgb(31, 35, 40);">来获得对象</font>
4. `<font style="color:rgb(31, 35, 40);">Calender</font>`<font style="color:rgb(31, 35, 40);">没有对应的格式化的类，所以需要程序员自己来组合输出</font>
5. <font style="color:rgb(31, 35, 40);">如果我们需要按照 24小时进制来获取时间， </font>`<font style="color:rgb(31, 35, 40);">Calendar.HOUR</font>`<font style="color:rgb(31, 35, 40);"> ==改成=> </font>`<font style="color:rgb(31, 35, 40);">Calendar.HOUR_OF_DAY</font>`
6. <font style="color:rgb(31, 35, 40);">使用示例</font>

```java
package com.aurora.common_class.DateClass;

import java.util.Calendar;

public class CalenderClass {
    public static void main(String[] args) {
        //1.创建对象
        Calendar calendar = Calendar.getInstance();
        System.out.println("calendar = " + calendar);

        //2.获取日历对象的某个日历字段
        System.out.println("年: " + calendar.get(Calendar.YEAR));
        System.out.println("月: " + calendar.get(Calendar.MONTH) + 1);   //+1的原因是Calender返回月时，从0开始编号
        System.out.println("日: " + calendar.get(Calendar.DAY_OF_MONTH));
        System.out.println("时(12小时制): " + calendar.get(Calendar.HOUR));    //12小时制的
        System.out.println("时(24小时制): " + calendar.get(Calendar.HOUR_OF_DAY));  //24小时制
        System.out.println("分: " + calendar.get(Calendar.MINUTE));
        System.out.println("秒: " + calendar.get(Calendar.SECOND));

        //3.只能手动格式化输出
        System.out.println(calendar.get(Calendar.YEAR) + "-" + calendar.get(Calendar.MONTH) + "-" +
                calendar.get(Calendar.DAY_OF_MONTH) + "-" + calendar.get(Calendar.HOUR_OF_DAY) + "-" +
                calendar.get(Calendar.MINUTE) + "-" + calendar.get(Calendar.SECOND));
    }
}

```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763471185372-115800e7-0b0f-4d47-ab5c-98e72dedbd24.png)

第一行的完整输出是：calendar = `java.util.GregorianCalendar[time=1763471138825,areFieldsSet=true,areAllFieldsSet=true,lenient=true,zone=sun.util.calendar.ZoneInfo[id="GMT+08:00",offset=28800000,dstSavings=0,useDaylight=false,transitions=0,lastRule=null],firstDayOfWeek=1,minimalDaysInFirstWeek=1,ERA=1,YEAR=2025,MONTH=10,WEEK_OF_YEAR=47,WEEK_OF_MONTH=4,DAY_OF_MONTH=18,DAY_OF_YEAR=322,DAY_OF_WEEK=3,DAY_OF_WEEK_IN_MONTH=3,AM_PM=1,HOUR=9,HOUR_OF_DAY=21,MINUTE=5,SECOND=38,MILLISECOND=825,ZONE_OFFSET=28800000,DST_OFFSET=0]`

## 第三代日期类
### 基本介绍
1. 前面两代日期类的不足分析

<font style="color:rgb(31, 35, 40);">J</font><font style="color:rgb(31, 35, 40);">DK 1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。而Calendar也存在问题是:</font>

+ <font style="color:rgb(31, 35, 40);">可变性:像日期和时间这样的类应该是不可变的。</font>
+ <font style="color:rgb(31, 35, 40);">偏移性:Date中的年份是从1900开始的，而月份都从0开始。格式化:格式化只对Date有用，Calendar则不行。</font>
+ <font style="color:rgb(31, 35, 40);">此外，它们也不是线程安全的;不能处理闰秒等(每隔2天，多出1s).</font>
2. jdk8中加入了三个类：

| 类名 | 含义 | 包含内容 |
| --- | --- | --- |
| `**LocalDate**` | 日期 | 年、月、日 |
| `**LocalTime**` | 时间 | 时、分、秒、纳秒 |
| `**LocalDateTime**` | 日期+时间 | 年、月、日 + 时、分、秒、纳秒 |


+ 它们都是 **不可变类（immutable）且线程安全**。
+  `LocalDateTime` 可以由 `LocalDate` 和 `LocalTime` 组合得到， 在绝大多数业务场景下，**直接用 **`**LocalDateTime**`** 是最方便、最通用的选择**。  因此直接看`LocalDateTime`的例子
3. 创建`LocalDateTime`对象
+ 获取当前时间（最常用）：`LocalDateTime now = LocalDateTime.now();`
+ 指定日期+时间创建对象：例如`LocalDateTime dt = LocalDateTime.of(2025, 11, 18, 14, 30, 0);`
+ 创建`LocalDate`和`LocalTime`对象也是一样的方式

### `DateTimeFormatter`类
1. 作用：格式化日期
2. 方式一：自定义格式（最常用）：

```java
DateTimeFormatter fmt =DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
String s1 = fmt.format(ldt);	//方式一：格式化器调用 format()
String s2 = ldt.format(fmt);	//方式二：日期对象调用 format()
```

3. 方式二：使用内置格式

| 常量 | 示例 |
| --- | --- |
| `ISO_LOCAL_DATE` | 2025-11-18 |
| `ISO_LOCAL_TIME` | 14:30:00 |
| `ISO_LOCAL_DATE_TIME` | 2025-11-18T14:30:00 |


```java
LocalDateTime now = LocalDateTime.now();
String s = now.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
// 例如: 2025-11-18T14:30:00
```

### `LocalDateTime`及`DateTimeFormatter`使用示例
```java
package com.aurora.common_class.DateClass;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class LocalDateTimeDemo01 {
    public static void main(String[] args) {
        //1.创建表示当前时间的LocalDateTime对象
        LocalDateTime ldt = LocalDateTime.now();
        System.out.println(ldt);    //2025-11-18T21:28:46.438

        //2.获取年月日时分秒
        System.out.println("年 = " + ldt.getYear());
        System.out.println("月 = " + ldt.getMonth());        //月 = NOVEMBER
        System.out.println("月 = " + ldt.getMonthValue());   //月 = 11
        System.out.println("日 = " + ldt.getDayOfMonth());
        System.out.println("时 = " + ldt.getDayOfYear());
        System.out.println("分 = " + ldt.getDayOfWeek());
        System.out.println("秒 = " + ldt.getDayOfMonth());

        //3.使用DateTimeFormatter对象来格式化日期
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String format1 = dtf.format(ldt);    //方式一：格式化器调用 format()
        String format2 = ldt.format(dtf);         //方式二：日期对象调用 format()
        System.out.println(format1);
        System.out.println(format2);

        //4.对当前日加减
        LocalDateTime tomorrow = LocalDateTime.now().plusDays(1);   //加一天
        System.out.println("tomorrow =  " + tomorrow);

        LocalDateTime past = LocalDateTime.now().minusHours(1);     //减一小时
        System.out.println("past = " + past);
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763473853801-daee616a-c83e-4e11-a08e-10e2e660ef3f.png)

```java
package com.aurora.common_class.DateClass;

import java.time.LocalDate;
import java.time.LocalTime;

public class LocalDateAndLocalTime {
    public static void main(String[] args) {
        LocalDate  date = LocalDate.now();
        LocalTime time = LocalTime.now();

        System.out.println("date = " + date);
        System.out.println("time = " + time);
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763474096800-daaabbe7-0954-4d24-93fa-b36ae5f222cf.png)

### Instant时间戳
1. 介绍
+ 从 1970-01-01 00:00:00 UTC（Unix Epoch）开始到某个时间点的 “秒 + 纳秒”。例如`1697331123 秒 + 123456789 纳秒`
+ 输出时实际上输出的是`Instant对象.toString()`
2. 创建`Instant`对象
+ 创建表示当前时间戳的对象：`Instant now = Instant.now();`
3. `Instant`->`Date`
+ `Date date = Date.from(Instant对象)`
4. `Date`->`Instant`
+ `Instant instant = Date对象.toInstant();`
5. 使用示例

```java
package com.aurora.common_class.DateClass;

import java.time.Instant;
import java.util.Date;

public class InstantDemo {
    public static void main(String[] args) {
        //1.创建表示当前时间戳的Instant对象
        Instant now = Instant.now();
        System.out.println("now = " + now);		//实际输出的是now.toString()
        //2.Instant -> Date
        Date date = Date.from(now);
        System.out.println("date = " + date);

        //3.Date -> Instant
        Instant instant = date.toInstant();
        System.out.println("instant = " + instant);
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763474659036-237024e6-ccd7-435c-97fb-432db656ab60.png)

# 本章作业
## 反转字符串
1. 需求
    1. <font style="color:rgb(31, 35, 40);">将字符串中指定部分进行反转。比如将"abcdef"反转为"aedcbf"。</font>
    2. <font style="color:rgb(31, 35, 40);">编写方法 public static String reverse(String str, int start , int end)搞定。</font>
2. 实现

```java
package com.aurora.common_class.Practice;

/*
    字符串反转
 */

public class Practice01 {
    public static void main(String[] args) {
        String str = "abcdefg";
        System.out.println("reverse之前str = " + str);
        try {
            String reversed = reverse(str, 2, 5);
            System.out.println("reverse之后reversed = " + reversed);
        } catch (Exception e) {
            System.out.println(e.getMessage());
            return;     //程序结束
        }
    }

    public static String reverse(String str, int start, int end) {

        //参数异常的情况
        if (!(str != null && start >0 && end < str.length() && start <= end)) {
            throw new RuntimeException("参数不正确");
        }

        char[] arr = str.toCharArray();
        for (int i = 0; i <= (end - start) / 2; i++) {
            char temp = arr[start + i];
            arr[start + i] = arr[end - i];
            arr[end - i] = temp;
        }
        return new String(arr);
    }
}
```

3. `reverse`函数更直观的实现方式

```java
public static String reverse(String str, int start, int end) {

    char[] arr = str.toCharArray();
    for (int i = start, j = end; i < j; i++, j--) {
        char temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    return new String(arr);
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763529955757-daca3808-eb0a-4b87-8a28-fbd2553b6b65.png)

## 用户注册
1. <font style="color:rgb(31, 35, 40);">需求：输入用户名、密码、邮箱，如果信息录入正确，则提示注册成功，否则生成异常对象 要求:</font>
    1. <font style="color:rgb(31, 35, 40);">用户名长度为2或3或4</font>
    2. <font style="color:rgb(31, 35, 40);">密码的长度为6</font>
    3. <font style="color:rgb(31, 35, 40);">要求全是数字（这里需要实现</font>`<font style="color:rgb(31, 35, 40);">isDigital</font>`<font style="color:rgb(31, 35, 40);">函数）</font>
    4. <font style="color:rgb(31, 35, 40);">邮箱中包含</font>`<font style="color:rgb(31, 35, 40);">@</font>`<font style="color:rgb(31, 35, 40);">和</font>`<font style="color:rgb(31, 35, 40);">.</font>`<font style="color:rgb(31, 35, 40);">，并且@在</font>`<font style="color:rgb(31, 35, 40);">.</font>`<font style="color:rgb(31, 35, 40);">前面</font>
2. 实现

```java
package com.aurora.common_class.Practice;

import java.util.Scanner;

public class Practice02 {
    public static void main(String[] args) {
        //用户信息输入
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入用户名：");
        String username = sc.next();
        System.out.println("请输入密码：");
        String password = sc.next();
        System.out.println("请输入邮箱：");
        String email = sc.next();

        try {
            userRegister(username, password, email);
            System.out.println("恭喜您，注册成功！");
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

    }

    public static void userRegister(String username, String password, String email) {
        //1.检查用户名是否符合要求
        if (!(username.length() >= 2 && username.length() <= 4)) {
            throw new RuntimeException("要求用户名长度为2或3或4");
        }

        //2.检查密码是否符合要求
        if (!(password.length() == 6 && isDigit(password))) {
            throw new RuntimeException("要求密码的长度为6");
        }

        //3.检查邮箱是否符合要求
        if (!(email.indexOf("@") > 0 && email.indexOf("@") < email.indexOf("."))){
            throw new RuntimeException("要求邮箱中包含@和.，并且@在.前面");
        }
    }

    public static boolean isDigit(String str) {
        char[] chars = str.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            if  (chars[i] < '0' || chars[i] > '9')
                return false;
        }

        return true;
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763529998251-96fcf060-859a-48a3-8ac9-4e3b6f3b5e5f.png)

## 名字缩写
1. 需求
    1. <font style="color:rgb(31, 35, 40);">编写java程序，输入形式为: Han shun Ping的人名，以Ping,Han .S的形式打印 出来。其中.S是中间单词的首字母。</font>
    2. <font style="color:rgb(31, 35, 40);">例如输入“Willian Jefferson Clinton”，输出形式为:Clinton, Willian .J</font>
2. 实现

```java
package com.aurora.common_class.Practice;

public class Practice03 {
    public static void main(String[] args) {
        String name = "Han shun Ping";
        String format = formatName(name);
        System.out.println(format);
    }

    public static String formatName(String name){
        if (name==null){
            System.out.println("姓名不能为空");
            return "";
        }

        String[] strs = name.split(" ");

        //名字输入不规范
        if (strs.length != 3) {
            throw new RuntimeException("姓名输入格式不正确！");
        }

        String format = String.format("%s,%s .%c", strs[2], strs[0], strs[1].toUpperCase().charAt(0));
        return format;
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763529919816-4f9130ec-9e07-48ea-90ef-a240e42b0621.png)

## 统计大小写字母个数
1. 需求
+ <font style="color:rgb(31, 35, 40);">输入字符串，判断里面有多少个大写字母，多少个小写字母，多少个数字。</font>
2. 实现

```java
package com.aurora.common_class.Practice;

import java.util.Scanner;

public class Practice04 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = sc.next();
        countStr(str);
    }

    public static void countStr(String str) {
        if (str == null) {
            System.out.println("字符串不能为空");
            return;
        }

        int upperCount = 0;
        int lowerCount = 0;
        int numCount = 0;
        int otherCount = 0;
        char[] chars = str.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            if (chars[i] >= 'A' && chars[i] <= 'Z') {upperCount++;}
            else if (chars[i] >= 'a' && chars[i] <= 'z') {lowerCount++;}
            else if (chars[i] >= '0' && chars[i] <= '9') {numCount++;}
            else {otherCount++;}
        }

        System.out.println("大写字母的个数 = " + upperCount);
        System.out.println("小写字母的个数 = " + lowerCount);
        System.out.println("数字的个数 = " + numCount);
        System.out.println("其他字符的个数 = " + otherCount);
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763529898340-e7bc8d1c-e216-421f-8594-2d994a344cb6.png)

## 分析题
```java
package com.aurora.common_class.Practice;

public class Person {
    String name;

    public Person(String name) {
        this.name = name;
    }
}
```

```java
package com.aurora.common_class.Practice;

import com.aurora.InnerClassDemo.AnonimousInnerClass.Animal;

public class Practice05 {
    public static void main(String[] args) {
        String s1 = "hspedu";
        Person a = new Person(s1);
        Person b = new Person(s1);

        System.out.println(a == b); //false
        System.out.println(a.equals(b));    //false
        System.out.println(a.name == b.name);   //true

        String s4 = new String("hspedu");
        String s5 = "hspedu";

        System.out.println(s1 == s4);   //false
        System.out.println(s4 == s5);   //false

        String t1 = "hello" + s1;
        String t2 = "hellohspedu";
        System.out.println(t1.intern() == t2);  //true
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763530711639-9705be8e-60ab-41ed-90ad-905bbfafca11.png)

1. **第一部分：**`**a == b **`**(false)**

```plain
Person a = new Person(s1);
Person b = new Person(s1);
System.out.println(a == b); //false
```

+ `new Person()` 每次都会创建一个新对象
+ 所以 `a` 和 `b` 的引用地址不同

👉 **结果：false**

2. **第二部分：**`**a.equals(b)**`** (false)**
+ Person 类没有重写 equals
+ 默认 equals 和 == 是一样的（Object 的默认实现）
+ 即 **比较对象地址**

👉 **结果：false**

3. ** 第三部分：**`**a.name == b.name**`** (true)  **

关键点：`s1 = "hspedu"` 是字符串常量池中的对象。

两次传入 Person 构造器的都是 **同一个 s1 常量池地址**。

所以：

+ `a.name` 指向 "hspedu"（常量池）
+ `b.name` 也指向 "hspedu"（常量池）

所以引用相同。

👉 **结果：true**

4. ** 第四部分：**`**new String("hspedu")**`** 与常量池**

```java
String s4 = new String("hspedu");
String s5 = "hspedu";

System.out.println(s1 == s4);   //false
System.out.println(s4 == s5);   //false
```

解释：

✔ `new String("hspedu")` 会创建两个对象：

1. 常量池中的 "hspedu"（如果不存在）
2. 堆中的 new String 对象

因此：

+ `s1` 指向常量池
+ `s4` 指向堆中的对象
+ `s5` 指向常量池中的同一个对象

所以：

+ `s1 == s4` → false（常量池 vs 堆）
+ `s4 == s5` → false（堆 vs 常量池）
5. ** 第五部分：**`**intern() **`**让字符串回到常量池**

**t1:**

```java
String t1 = "hello" + s1;
```

注意：s1 是变量（不是常量表达式），在编译期不能合并，所以：

👉 **t1 是运行时在堆中创建的新对象**

**t2:**

```java
String t2 = "hellohspedu";
```

这是完全由字面量组成的，编译期就会放进常量池。

**intern() 的作用：**

```java
t1.intern()
```

intern() 的规则：

+ 如果常量池中已经存在等值字符串，返回常量池的对象地址
+ 如果不存在，就把当前字符串放入常量池并返回它的地址

常量池中 **已经有 "hellohspedu"**，就是 t2。

**所以：**

```java
t1.intern()  → 常量池中的 "hellohspedu"
t2            → 常量池中的 "hellohspedu"
```

引用相同。

👉 **结果：true**

6. **总结**

| 表达式 | 结果 | 原因 |
| --- | --- | --- |
| a == b | false | Person 每次 new 新对象 |
| a.equals(b) | false | 未重写 equals，按地址比较 |
| a.name == b.name | true | 都引用常量池的同一个 "hspedu" |
| s1 == s4 | false | 常量池 vs new 堆对象 |
| s4 == s5 | false | 堆 vs 常量池 |
| t1.intern() == t2 | true | intern 返回常量池对象 |


