# Java绘图坐标体系
## 坐标体系介绍
<font style="color:rgb(31, 35, 40);">下图说明了Java坐标系。坐标原点位于左上角，以像素为单位。在Java坐标系中,第一个是x坐标,表示当前位置为水平方向，距离坐标原点x个像素;第二个是y坐标，表示当前位置为垂直方向，距离坐标原点y个像素。</font>

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764579422117-978d76e7-e90b-48ae-8044-37545c3f0c0b.png)

## 像素介绍
<font style="color:rgb(31, 35, 40);">计算机在屏幕上显示的内容都是由屏幕上的每一个像素组成的。例如，计算机显示器的分辨率是800×600，表示计算机屏幕上的每一行由800个点组成，共有600行,整个计算机屏幕共有480 000个像素。</font>**<font style="color:rgb(31, 35, 40);">像素是一个密度单位,而厘米是长度单位,两者无法比较</font>**<font style="color:rgb(31, 35, 40);">。</font>

## <font style="color:rgb(31, 35, 40);">绘图原理</font>
`Component`类提供了两个最关键的方法：`paint()`和`repaint()`

1. `**paint(Graphics g)**`
+ **作用**：这是真正执行绘制代码的地方。你在这里写 `g.drawOval(...)`, `g.drawLine(...)`。
+ **特点**：**永远不要自己在代码里直接调用这个方法！**
    - 因为你无法手动提供 `Graphics g` 这个系统画笔对象。
    - 它是被系统（JVM/操作系统）自动调用的（回调方法）。
2. `**repaint()**`
+ **作用**：请求系统尽快刷新组件的外观。
+ **特点**：**这是你在代码中唯一应该调用的方法**。
    - 当你改变了数据（比如把圆移动了位置），你需要告诉系统：“嘿，画面脏了，麻烦重新画一下”。
    - `repaint()` 不会立即画图，它只是向系统发送一个**“重绘请求”**。系统会在空闲时尽快调用 `paint()`。
3. `**paint()**`**被调用的时机**
    1. **系统自动触发（被动）：**当操作系统认为这块屏幕区域“脏了”或“失效了”，需要重新显示时：
        1. **程序启动时：**组件第一次在屏幕上显示。
        2. **窗口状态改变：**窗口从最小化恢复到最大化/正常状态。
        3. **窗口大小改变：**拉伸窗口边缘，导致显示区域变化。
        4. **遮挡恢复：**被其他窗口遮挡的部分移开后，露出的部分需要重绘。
    2. **程序逻辑出发（主动）**：当你的程序逻辑改变了显示内容时： 
        1. 例如：在一个定时器中，每隔 100ms 修改圆的坐标 `x++`，然后调用 `repaint()`。
        2. 流程：`修改数据` -> `repaint()` -> `系统排队` -> `系统调用 paint()` -> `画面更新`。

## Graphics类
`Graphics` 类可以理解为你的“画笔”，它提供了各种绘制图形的方法。

### 常用方法速查
1. **画直线**: `drawLine(int x1, int y1, int x2, int y2)`
+ `x1`, `y1`: **起点**坐标。
+ `x2`, `y2`: **终点**坐标。
+ **效果**: 在两点之间画一条细线（宽度为1像素，除非使用 Graphics2D 设置 Stroke）。
2. **画矩形边框**: `drawRect(int x, int y, int width, int height)`
+ `x`, `y`: 矩形**左上角**的坐标。
+ `width`: 矩形的宽度（向右延伸的像素数）。
+ `height`: 矩形的高度（向下延伸的像素数）。
3. **画椭圆边框**: `drawOval(int x, int y, int width, int height)`
+ 它画的是一个**内切于指定矩形的椭圆**。
+ `x`, `y`: **外接矩形左上角**的坐标（注意：**不是圆心！**）。
+ `width`: 外接矩形的宽（如果是正圆，即为**直径**）。
+ `height`: 外接矩形的高。
4. **填充矩形**: `fillRect(int x, int y, int width, int height)`
5. **填充椭圆**: `fillOval(int x, int y, int width, int height)`
6. **画图片**: `drawImage(Image img, int x, int y, ...)`
+ `img`: 要绘制的图片对象（通常通过 `Toolkit.getDefaultToolkit().getImage(...)` 获取）。
+ `x`, `y`: 图片**左上角**在面板上的坐标。
+ `observer`: 图片加载监视器。因为加载图片是异步的，这里通常传 `this`（即当前的 JPanel 对象），让它在图片加载完成时通知重绘。
7. **画字符串**: `drawString(String str, int x, int y)`
+ **注意**: 这里的 `(x, y)` 是文字的**基线(baseline)左下角**，而不是字体的左上角。
+ `str`: 要显示的文字内容。
+ `x`: 文字开始的横坐标。
+ `y`: 文字**基线 (Baseline)** 的纵坐标。
8. **设置字体**: `setFont(new Font(String name, int style, int size))`
+ `name`: 字体名称（如 "宋体", "Arial"）。
+ `style`: 样式常量。
    - `Font.PLAIN` (普通)
    - `Font.BOLD` (加粗)
    - `Font.ITALIC` (斜体)
+ `size`: 字体大小（像素点）。
9. **设置颜色**: `setColor(Color c)`

### 使用示例
```java
package com.aurora.TankBattle.Test;

import javax.swing.*;

public class DrawCircle extends JFrame {

    //定义一个面板
    private MyPanel mp = null;

    public DrawCircle() {   //构造器
        //初始化面板
        mp = new MyPanel();
        //把面板放到窗口里
        this.add(mp);
        //设置窗口的大小
        this.setSize(1000, 800);
        //当点击窗口的小×时，程序完全退出
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        this.setVisible(true);  //可以显示
    }

}
```

```java
package com.aurora.TankBattle.Test;

import javax.swing.*;
import java.awt.*;

/**
 * 定义一个MyPanel，继承JPanel类，画图形，就在面板上画
 * 1.MyPanel就是一个画板
 * 2.Graphics g, 把 g 理解成一支画笔
 * 3.Graphics提供了很多绘图的方法
 */
public class MyPanel extends JPanel {
    @Override
    public void paint(Graphics g) {
        super.paint(g);     //调用父类的方法完成初始化
        System.out.println("paint方法被调用了");

        //画出一个圆形
        g.drawOval(10, 10, 100, 100);

        //画直线
        g.drawLine(150, 10, 200, 100);

        //画矩形边框
        g.drawRect(300, 10, 100, 100);

        //画椭圆边框
        g.drawOval(450, 10, 60, 100);

        //画填充矩形
        g.fillRect(600, 10, 60, 100);

        //设置画笔的颜色
        g.setColor(Color.blue);
        g.fillRect(750, 10, 60, 100);

        //红色填充椭圆
        g.setColor(Color.red);
        g.fillOval(10, 150, 100, 60);

        //画图片
        Image image = Toolkit.getDefaultToolkit().getImage(MyPanel.class.getResource("/img/picture.jpg"));
        g.drawImage(image, 150, 150, 300, 300, this);

        //画字符串
        g.drawString("hello", 500, 200);

        //设置颜色字体后画字符串
        g.setColor(Color.red);
        g.setFont(new Font("隶书", Font.BOLD, 50));
        g.drawString("hello", 650, 200);

    }
}
```

```java
package com.aurora.TankBattle.Test;

public class DrawCircleTest01 {
    public static void main(String[] args) {
        new DrawCircle();
        System.out.println("退出程序~");
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764645441114-424a5310-52d3-4ae7-976f-7d9f92b30292.png)

+ `**MyPanel**`** (画纸/画板)**：这是最核心的部分，负责具体的“画画”动作（画圆、画线）。
+ `**DrawCircle**`** (画框)**：这是一个窗口，它负责把“画纸”装裱起来，挂在屏幕上。
+ `**DrawCircleTest01**`** (人)**：这是程序的入口，它负责把画框拿出来展示。

## 绘出坦克
![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764645497778-1c372237-9bd7-4c87-965a-8c464845128f.png)

# Java事件处理机制
## 基本说明
Java 采用的是 **“委派事件模型” (Delegation Event Model)**。简单来说，这是一种 **“请求-响应”** 模式：

+ 当“出事了”（发生事件），“当事人”（事件源）会将“现场情况”（事件对象）打包，通过电话通知“相关负责人”（监听器）来处理。

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764653304507-676f4779-a26e-4e4a-a97f-3aaafa86f165.png)

## 三大核心要素讲解
### 事件源 (Event Source)
1. **定义**：产生事件的对象。
2. **例子**：`JButton` (按钮), `JTextField` (文本框), `JFrame` (窗口), `JPanel` (面板)。
3. **职责**：
    1. 接受用户的操作。
    2. **注册监听器**：必须通过 `addXxxListener()` 方法把监听器绑定到自己身上，否则出了事没人管。

### 事件对象
1. **定义**：包装了事件发生时的所有信息。
2. **来源**：当事件发生时，系统自动创建，并作为参数传递给监听器的方法。
3. **常用事件分类**

| 事件类 (Event Class) | 说明 (触发场景) |
| --- | --- |
| **ActionEvent** | 通常在按下按钮、双击一个列表项、或选中某个菜单时发生。 |
| **AdjustmentEvent** | 当操作一个滚动条时发生。 |
| **ComponentEvent** | 当一个组件隐藏、移动、改变大小时发送。 |
| **ContainerEvent** | 当一个组件从容器中加入或者删除时发生。 |
| **FocusEvent** | 当一个组件获得或是失去焦点时发生。 |
| **ItemEvent** | 当一个复选框或是列表项被选中时，或当一个选择框/选择菜单被选中时发生。 |
| **KeyEvent** | 当从键盘的按键被按下、松开时发生。 |
| **MouseEvent** | 当鼠标被拖动、移动、点击、按下、释放时发生。 |
| **TextEvent** | 当文本区和文本域的文本发生改变时发生。 |
| **WindowEvent** | 当一个窗口激活、关闭、失效、恢复、最小化时发生。 |


### 事件监听器
1. **定义**：负责处理事件的**接口 (Interface)**。
2. **实现**：程序员需要编写一个类来实现这些接口，并重写其中的方法（编写具体的业务逻辑，比如“坦克向上移动”）。
3. **常用接口**

| 事件类别 | 监听器接口 | 对应的事件对象 | 触发场景 |
| --- | --- | --- | --- |
| **键盘** | `KeyListener` | `KeyEvent` | 键盘按下、释放、敲击 |
| **鼠标** | `MouseListener` | `MouseEvent` | 鼠标点击、按住、移入、移出 |
| **鼠标移动** | `MouseMotionListener` | `MouseEvent` | 鼠标拖拽、移动 |
| **动作** | `ActionListener` | `ActionEvent` | 按钮点击、菜单项选择 |
| **窗口** | `WindowListener` | `WindowEvent` | 窗口关闭、激活、最小化 |


![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764653280774-780f5b65-445a-4276-9230-b096d0afa575.png)

## 坦克动起来
### 父类坦克
```java
package com.aurora.TankBattle.TankBattleGame;

/**
 * 坦克父类
 * 包含坐标、方向、速度和移动方法
 */
public class Tank {
    private int x;  //坦克的横坐标
    private int y;  //坦克的纵坐标
    private int direct = 0; //坦克的方向 0:上 1:右 2:下 3:左
    private int speed = 2;

    public Tank(int x, int y) {
        this.x = x;
        this.y = y;
    }

    //------移动方法------
    public void moveUp() {
        y -= speed;
    }

    public void moveDown() {
        y += speed;
    }

    public void moveLeft() {
        x -= speed;
    }

    public void moveRight() {
        x += speed;
    }

    //---Getter and Setter

    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    public int getDirect() {
        return direct;
    }

    public void setDirect(int direct) {
        this.direct = direct;
    }

    public int getSpeed() {
        return speed;
    }

    public void setSpeed(int speed) {
        this.speed = speed;
    }
}
```

### 我方坦克
```java
package com.aurora.TankBattle.TankBattleGame;

/**
 * 英雄坦克（玩家控制）
 */
public class Hero extends Tank {
    public Hero(int x, int y) {
        super(x, y);
    }
}
```

### 敌方坦克
```java
package com.aurora.TankBattle.TankBattleGame;

/**
 * 敌方坦克
 */
public class EnemyTank extends Tank {
    public EnemyTank(int x, int y) {
        super(x, y);
    }
}
```

### 绘图画板
```java
package com.aurora.TankBattle.TankBattleGame;

import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.Vector;

/**
 * 坦克大战的绘图区域
 * 1.继承JPanel绘图
 * 2.实现KeyListener监听键盘实践
 */
public class MyPanel extends JPanel implements KeyListener {
    //定义我方坦克
    Hero hero = null;

    //定义敌人坦克，放入Vector（线程安全）
    Vector<EnemyTank> enemyTanks = new Vector<>();
    int enemyTankSize = 3;

    //构造器，在其中完成初始化操作
    public MyPanel() {
        //初始化自己的坦克(位置 100, 100)
        hero = new Hero(100, 100);

        //初始化敌人的坦克
        for (int i = 0; i < enemyTankSize; i++) {
            // 创建一个敌人的坦克，间隔 100 像素
            EnemyTank enemyTank = new EnemyTank(100 * (i + 1), 0);
            // 设置方向 (2 表示向下)
            enemyTank.setDirect(2);
            // 加入集合
            enemyTanks.add(enemyTank);
        }
    }

    @Override
    public void paint(Graphics g) {
        super.paint(g);

        //1.填充背景矩形，默认黑色
        g.fillRect(0, 0, 1000, 750);

        //2.画出自己的坦克
        drawTank(hero.getX(), hero.getY(), g, hero.getDirect(), 1);

        //3.画出敌人的坦克
        for (int i = 0; i < enemyTankSize; i++) {
            EnemyTank enemyTank = enemyTanks.get(i);
            drawTank(enemyTank.getX(), enemyTank.getY(), g, enemyTank.getDirect(), 0);
        }
    }

    /**
     *
     * @param x         坦克的左上角x坐标
     * @param y         坦克的左上角y坐标
     * @param g         画笔
     * @param direct    坦克方向（0:上 1:右 2:下 3:左）
     * @param type      坦克类型（0:敌人 1:自己）
     */
    public void drawTank(int x, int y, Graphics g, int direct, int type) {
        // 根据不同类型的坦克，设置不同的颜色
        switch (type) {
            case 0:
                g.setColor(Color.CYAN); // 敌人的坦克 (青色)
                break;
            case 1:
                g.setColor(Color.YELLOW);   // 我的坦克 (黄色)
        }

        //根据坦克的方向，来绘制对应形状坦克
        switch (direct) {
            case 0:
                g.fill3DRect(x, y, 10, 60, false);  //左轮
                g.fill3DRect(x + 30, y, 10, 60, false); //右轮
                g.fill3DRect(x + 10, y + 10, 20, 40, false);    //舱体
                g.fillOval(x + 10, y + 20, 20, 20); //圆形盖子
                g.drawLine(x + 20, y + 30, x + 20, y);  //炮筒（向上）
                break;
            case 1: // 表示向右
                g.fill3DRect(x, y, 60, 10, false);       // 上轮
                g.fill3DRect(x, y + 30, 60, 10, false);  // 下轮
                g.fill3DRect(x + 10, y + 10, 40, 20, false); // 舱体
                g.fillOval(x + 20, y + 10, 20, 20);      // 圆形盖子
                g.drawLine(x + 30, y + 20, x + 60, y + 20); // 炮筒 (向右)
                break;
            case 2: // 表示向下
                g.fill3DRect(x, y, 10, 60, false);       // 左轮
                g.fill3DRect(x + 30, y, 10, 60, false);  // 右轮
                g.fill3DRect(x + 10, y + 10, 20, 40, false); // 舱体
                g.fillOval(x + 10, y + 20, 20, 20);      // 圆形盖子
                g.drawLine(x + 20, y + 30, x + 20, y + 60); // 炮筒 (向下)
                break;
            case 3: // 表示向左
                g.fill3DRect(x, y, 60, 10, false);       // 上轮
                g.fill3DRect(x, y + 30, 60, 10, false);  // 下轮
                g.fill3DRect(x + 10, y + 10, 40, 20, false); // 舱体
                g.fillOval(x + 20, y + 10, 20, 20);      // 圆形盖子
                g.drawLine(x + 30, y + 20, x, y + 20);   // 炮筒 (向左)
                break;
            default:
                System.out.println("暂时没有处理");
        }
    }

    @Override
    public void keyTyped(KeyEvent e) {
        //不存在字符输入情况，不需要做处理
    }

    //处理WASD键按下的情况
    @Override
    public void keyPressed(KeyEvent e) {

        if (e.getKeyCode() == KeyEvent.VK_W) {
            // W键: 向上
            hero.setDirect(0);  //改变方向
            hero.moveUp();      //改变坐标
        } else if (e.getKeyCode() == KeyEvent.VK_D) {
            // D键: 向右
            hero.setDirect(1);
            hero.moveRight();
        } else if (e.getKeyCode() == KeyEvent.VK_S) {
            hero.setDirect(2);
            hero.moveDown();
        } else if (e.getKeyCode() == KeyEvent.VK_A) {
            hero.setDirect(3);
            hero.moveLeft();
        }

        // 3. 核心：必须重绘！如果不重绘，数据改了但屏幕不会刷新。
        this.repaint();
    }

    @Override
    public void keyReleased(KeyEvent e) {
        //按键松开，没有对应的操作，不需要处理
    }
}
```

### 主程序入口
```java
package com.aurora.TankBattle.TankBattleGame;

import javax.swing.*;

public class TankGame extends JFrame {

    //定义MyPanel
    MyPanel mp = null;

    public static void main(String[] args) {
        TankGame tankGame = new TankGame();
    }

    public TankGame() {
        mp = new MyPanel();
        // 把面板(就是游戏的绘图区域)放入窗口
        this.add(mp);
        this.setSize(1000, 750);

        // 核心步骤：让 JFrame 监听 mp 的键盘事件
        // 因为 mp 实现了 KeyListener 接口，所以可以作为参数传入
        this.addKeyListener(mp);

        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        this.setVisible(true);
    }
}
```

## 以坦克大战的例子看三大核心要素
1. **事件源 (Event Source)** -> `TankGame` (JFrame 窗口)
+ **角色**：这是“案发现场”。玩家是按在键盘上，但键盘输入焦点在**窗口 (JFrame)** 上。
+ **代码位置**：在 `TankGame.java` 的构造器中。
+ **关键动作**：它负责把监听器“招募”进来。

```plain
// 这里的 this 指的是 JFrame 窗口本身
this.addKeyListener(mp);
```

_如果不写这一行，窗口就像一个没插电话线的座机，虽然有按键，但信号传不出去。_

2. **事件监听器 (Event Listener)** -> `MyPanel` (mp 对象)
+ **角色**：这是“接线员”或“处理专员”。它一直在等待电话响。
+ **代码位置**：`MyPanel.java`。
+ **关键特征**：
    1. 它实现了接口：`implements KeyListener` (拿到了上岗证)。
    2. 它实现了方法：`keyPressed(KeyEvent e)` (具体的业务手册)。

```plain
@Override
public void keyPressed(KeyEvent e) {
    // 听到电话响了，开始查手册：如果是 W 键，就往上跑...
    if (e.getKeyCode() == KeyEvent.VK_W) { ... }
}
```

3. `事件对象 (Event Object)` -> `KeyEvent e`
+ **角色**：这是“传递的信息包”。
+ **来源**：当你在键盘上按下 'W' 的瞬间，Java 虚拟机 (JVM) 自动生成了这个对象。
+ **内容**：它里面装着“刚才按的是哪个键”、“按下的时间”、“有没有同时按 Shift”等信息。
+ **代码体现**：就是 `keyPressed` 方法参数里的那个 `e`。

```plain
// e.getKeyCode() 就是从这个信息包里取出“键值”
if (e.getKeyCode() == KeyEvent.VK_W)
```

