# 文件及常用的文件操作
## 文件
<font style="color:rgb(31, 35, 40);">文件，对我们并不陌生,文件是保存数据的地方。文件在程序中是以流的形式来操作的。</font>

![](https://raw.githubusercontent.com/timerring/scratchpad2023/main/2023/image-20230503160956655.png)![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1765866738673-922144cd-c132-4ae6-a131-c8f604b058d3.png)

<font style="color:rgb(31, 35, 40);">流：数据在数据源(文件)和程序(内存)之间经历的路径</font>

<font style="color:rgb(31, 35, 40);">输入流：数据从数据源(文件)到程序(内存)的路径</font>

<font style="color:rgb(31, 35, 40);">输出流：数据从程序(内存)到数据源(文件)的路径</font>

## <font style="color:rgb(31, 35, 40);">常用的文件操作</font>
### File对象的构造器与创建
1. **构造器**

| 构造器 | 描述 |
| --- | --- |
| `new File(String pathname)` | 根据完整的路径字符串构建 `File` 对象。 |
| `new File(File parent, String child)` | 根据父目录的 `File` 对象和子路径字符串构建。 |
| `new File(String parent, String child)` | 根据父目录路径字符串和子路径字符串构建。 |


2. **代码示例**

```java
package com.aurora.IOStream.FileDemo;

import org.junit.jupiter.api.Test;

import java.io.File;
import java.io.IOException;

public class FileCreate {
    public static void main(String[] args) {

    }

    //方式1 new File(String pathname)
    @Test
    public void createFile01(){
        String filePath = "src/file_test/news1.txt";
        File file = new File(filePath);

        try {
            file.createNewFile();
            System.out.println("文件创建成功！");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    //方式2 new File(File parent,String child) //根据父目录文件+子路径构建
    @Test
    public void createFile02(){
        String filePath = "src/file_test";
        String fileName = "news2.txt";
        File file = new File(filePath, fileName);

        try {
            file.createNewFile();
            System.out.println("文件创建成功！");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    //方式3 new File(String parent,String child) //根据父目录+子路径构建
    @Test
    public void createFile03(){
        String parentPath = "src";
        String childPath = "file_test/news3.txt";
        File file = new File(parentPath, childPath);

        try {
            file.createNewFile();
            System.out.println("文件创建成功！");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766383976209-885469b2-b073-4f2b-9204-eee0534d4a73.png)

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766383990065-8ce146e4-775d-47c4-b33d-ef8828b158df.png)

### 获取文件的相关信息
1. 常用方法汇总

| 方法名 | 返回值类型 | 说明 |
| --- | --- | --- |
| `getName()` | `String` | 获取文件或目录的名字。 |
| `getAbsolutePath()` | `String` | 获取文件或目录的**绝对路径**。 |
| `getParent()` | `String` | 获取文件或目录的**父级目录路径**。 |
| `length()` | `long` | 获取文件的**大小（单位：字节/Bytes）**。 |
| `exists()` | `boolean` | 判断文件或目录**是否存在**。 |
| `isFile()` | `boolean` | 判断该对象是否是一个**文件**。 |
| `isDirectory()` | `boolean` | 判断该对象是否是一个**目录（文件夹）**。 |


2. 代码示例

```java
package com.aurora.IOStream.FileDemo;

import org.junit.jupiter.api.Test;

import java.io.File;

public class FileInformation {
    public static void main(String[] args) {

    }

    @Test
    public void getInfo() {
        File file = new File("src/file_test/news1.txt");

        System.out.println("文件绝对路径：" + file.getAbsolutePath());
        System.out.println("文件父级目录：" + file.getParent());
        System.out.println("文件大小（字节）：" + file.length());
        System.out.println("文件是否存在：" + file.exists());
        System.out.println("是不是一个文件："  + file.isFile());
        System.out.println("是不是一个目录：" + file.isDirectory());
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766385442918-8c59eaa5-e243-4e0e-9f96-20b2cfb470a7.png)

### 目录的操作和文件删除
1. 方法汇总

| 方法名 | 返回值 | 功能说明 |
| --- | --- | --- |
| `mkdir()` | `boolean` | **创建一级目录**。如果父级目录不存在，则创建失败并返回 `false`。 |
| `mkdirs()` | `boolean` | **创建多级目录**。会自动创建路径中所有不存在的父级目录。 |
| `delete()` | `boolean` | **删除文件或空目录**。如果目录下还有内容，删除会失败。 |


2. 操作流程建议：在进行删除或创建操作前，通常建议按照以下逻辑编写代码：
    1. **判断是否存在** (`exists()`)。
    2. **执行操作** (`mkdir`/`mkdirs`/`delete`)。
    3. **检查返回值**（通过 `boolean` 结果判断操作是否真正成功）。
3. 应用案例演示
    1. <font style="color:rgb(31, 35, 40);">判断 </font>`<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">src/file_test/news1.txt</font>`<font style="color:rgb(31, 35, 40);">是否存在，如果存在就删除</font>
    2. <font style="color:rgb(31, 35, 40);">判断 </font>`<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">src/file_test/demo</font>`<font style="color:rgb(31, 35, 40);">是否存在，存在就删除,否则提示不存在.</font>
    3. <font style="color:rgb(31, 35, 40);">判断 </font>`<font style="color:rgb(31, 35, 40);background-color:rgba(129, 139, 152, 0.12);">src/file_test/a/b/c</font>`<font style="color:rgb(31, 35, 40);">目录是否存在，如果存在就提示已经存在，否则就创建</font>

```java
package com.aurora.IOStream.FileDemo;

import org.junit.jupiter.api.Test;

import java.io.File;

public class DirectoryDemo {
    public static void main(String[] args) {

    }

    //  判断 src/file_test/news1.txt是否存在，如果存在就删除
    @Test
    public void Directory01() {
        File file = new File("src/file_test/news1.txt");
        if (file.exists()) {
            if (file.delete()) {
                System.out.println("删除成功");
            } else {
                System.out.println("删除失败");
            }
        } else {
            System.out.println("该文件不存在");
        }
    }

    //  判断 src/file_test/demo是否存在，存在就删除,否则提示不存在.
    @Test
    public void Directory02() {
        File file = new File("src/file_test/demo");
        if (file.exists()) {
            if (file.delete()) {
                System.out.println("删除成功");
            } else {
                System.out.println("删除失败");
            }
        } else {
            System.out.println("该目录不存在");
        }
    }

    //  判断 src/file_test/a/b/c目录是否存在，如果存在就提示已经存在，否则就创建
    @Test
    public void Directory03() {
        File file = new File("src/file_test/a/b/c");
        if (file.exists()) {
            System.out.println("目录已经存在");
        } else {
            if (file.mkdirs()) {
                System.out.println("目录创建成功");
            } else {
                System.out.println("目录创建失败");
            }
        }
    }
}
```

# IO流原理及流的分类
## Java IO流原理
1. 概念
+ **I/O** 是 **Input**（输入）和 **Output**（输出）的缩写。
+ **流 (Stream)**：在 Java 中，数据的传输被抽象为“流”。想象成水流，数据像水一样从一端流向另一端。
2. 数据流向：理解流的方向时，必须始终以**内存（程序）**为参照物：
+ **输入 (Input)**：读取外部数据（磁盘、网络等）到程序（内存）中。
    - _形象理解：数据“流入”程序。_
+ **输出 (Output)**：将程序（内存）中的数据输出到外部设备（磁盘、光盘、网络等）中。
    - _形象理解：数据从程序“流出”。_

## 流的种类
1. 按操作数据单位不同
+ **字节流 (8 bit)**：
    - 以字节为单位进行读写（1 byte = 8 bits）。
    - **适用场景**：二进制文件（如：图片、声音、视频、Word 文档、PDF 等）。
+ **字符流 (按字符)**：
    - 以字符为单位进行读写。
    - **适用场景**：纯文本文件（如：`.txt`, `.java`）。字符流会自动处理编码问题，避免乱码。
2. 按数据流向不同
+ **输入流**：只能从中读取数据，不能写入。
+ **输出流**：只能向其写入数据，不能读取。
3. 流的角色不同
+ **节点流**：直接从特定的数据源（如文件、内存）读写数据（例如：`FileInputStream`）。
+ **处理流 / 包装流**：通过对已存在的流进行包装，提供更强大的读写功能（例如：`BufferedInputStream`）。
4. IO流的四大抽象基类

Java IO 的 40 多个类非常规整，它们全部派生自以下四个抽象基类：

| 分类 | 字节流 (Byte Stream) | 字符流 (Character Stream) |
| --- | --- | --- |
| **输入流** | InputStream | Reader |
| **输出流** | OutputStream | Writer |


<font style="color:rgb(31, 35, 40);">由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。</font>

# <font style="color:rgb(31, 35, 40);">IO流体系_常用的类</font>
## IO流体系图
![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766397785857-e2e6f66f-fdb5-41a4-8089-dbb18c26e2d3.png)

## 文件VS流
![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766397845291-bc023a0c-77cc-4c60-9c45-e1562273bdad.png)

## FileInputStream类
1. **构造方法**
+ `**FileInputStream(File file)**`：通过打开一个到实际文件的连接来创建一个 `FileInputStream`，该文件由文件系统中的 `File` 对象 `file` 指定。
+ `**FileInputStream(String name)**`**：**通过打开一个到实际文件的连接来创建一个 `FileInputStream`，该文件由文件系统中的路径名 `name` 指定。
+ `**FileInputStream(FileDescriptor fdObj)**`：通过文件描述符 `fdObj` 创建 `FileInputStream`，该描述符表示到文件系统中某个实际文件的现有连接。
2. **常用方法**

| 返回值类型 | 方法名 | 说明 |
| --- | --- | --- |
| `int` | `read()` | 从此输入流中读取**一个字节**的数据。如果已到达文件末尾，则返回 `-1`。 |
| `int` | `read(byte[] b)` | 从此输入流中将最多 `b.length` 个字节的数据读入一个字节数组中。返回实际读取的字节数，如果到达末尾则返回 `-1`。 |
| `int` | `read(byte[] b, int off, int len)` | 从此输入流中将最多 `len` 个字节的数据读入一个字节数组中（从 `off` 下标开始存放）。 |
| `int` | `available()` | 返回下一次从此输入流可以不受阻塞地读取（或跳过）的估计剩余字节数。 |
| `void` | `close()` | **关闭此文件输入流**并释放与此流相关联的所有系统资源。 |
| `protected void` | `finalize()` | 确保在不再引用此文件输入流时调用其 `close` 方法。 |
| `long` | `skip(long n)` | 从输入流中跳过并丢弃 `n` 个字节的数据。 |
| `FileDescriptor` | `getFD()` | 返回与此流有关的文件描述符。 |
| `FileChannel` | `getChannel()` | **返回与此流有关的唯一 **`**FileChannel**`** 对象**（用于 NIO 操作）。 |


3. **应用实例**

<font style="color:rgb(31, 35, 40);">使用FileInputStream 读取hello.txt 文件，并将文件内容显示到控制台。</font>

<font style="color:rgb(31, 35, 40);">注意一个汉字通常是由3个bytes构成的，而read只会读取一个byte的数据，因此如果用read则会乱码，建议文本文件用字符流处理。</font>

```java
package com.aurora.IOStream.IOStreamDemo;

import org.junit.jupiter.api.Test;

import java.io.FileInputStream;
import java.io.IOException;

public class FileInputStreamDemo01 {
    public static void main(String[] args) {

    }

    /**
     * 读取文件方式一：单个字节读取
     * 缺点：效率低，频繁读取磁盘
     */
    @Test
    public void readFile01() {
        String filePath = "src/file_test/hello.txt";
        int readData = 0;
        FileInputStream fileInputStream = null;
        try {
            // 1. 创建 FileInputStream 对象，用于读取文件
            fileInputStream = new FileInputStream(filePath);

            // 2. 循环读取。read() 从流中读取一个字节的数据。
            // 如果返回 -1，表示读取完毕
            while ((readData = fileInputStream.read()) != -1) {
                // 读取到的是字节，转成 char 显示（注意：如果是中文可能会乱码，因为 UTF-8 中文占 3 字节）
                System.out.println((char)  readData);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 3. 关闭文件流，释放系统资源
            try {
                if (fileInputStream != null) {
                    fileInputStream.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * 读取文件方式二：使用字节数组读取（缓冲区）
     * 优点：提高读取效率
     */
    @Test
    public void readFile02() {
        String filePath = "src/file_test/hello.txt";
        //定义字节数组作为缓冲区
        byte[] buf = new byte[8];   //一次最多读取8个字节
        int readLen = 0;    //记录实际读取到的字节数
        FileInputStream fileInputStream = null;
        try {
            fileInputStream = new FileInputStream(filePath);

            // read(byte[] b) 从该输入流读取最多 b.length 字节的数据到字节数组。
            // 如果读取正常，返回实际读取的字节数；如果返回 -1，表示读取完毕。
            while ((readLen = fileInputStream.read(buf)) != -1) {
                //将字节数组 buf 中，从下标 0 开始，长度为 readLen 的内容转换为字符串。
                System.out.println(new String(buf, 0, readLen));
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (fileInputStream != null) {
                    fileInputStream.close();
                }
            }  catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

4. `**FileInoutStream**`**读取文件标准流程总结**
    1. 确定数据源：`String filePath = "e:\\hello.txt";`
    2. 创建流对象：`fileInputStream = new FileInputStream(filePath);`
    3. 选择读取方式：
        1. 单字节读取：`read()`
        2. 多字节读取：`read(byte[] buf)`，需提前准备一个仓库（字节数组）
    4. 循环处理数据：利用 `while` 循环不断从流中获取数据，直到读完为止。
    5. 关闭资源：必须放在 `finally` 块中，确保无论是否发生异常，流都能被关闭。

## FileOutputStream类
1. **构造方法**

| 构造方法 | 描述 |
| --- | --- |
| `FileOutputStream(String name)` | 创建一个向具有指定名称的文件中写入数据的输出流。 |
| `FileOutputStream(File file)` | 创建一个向指定 `File` 对象表示的文件中写入数据的文件输出流。 |
| `FileOutputStream(String name, boolean append)` | 如果 `append` 为 `true`，则将字节写入文件末尾处（追加模式），而不是写入文件开始处（覆盖模式）。 |
| `FileOutputStream(File file, boolean append)` | 创建一个向指定 `File` 对象中写入数据的文件输出流，支持追加模式。 |


2. **核心成员方法**

| 方法名 | 描述 |
| --- | --- |
| `void write(int b)` | 将指定的字节写入此输出流。注意虽然参数是 `int`，但实际写出的是低 8 位。 |
| `void write(byte[] b)` | 将 `b.length` 个字节从指定的字节数组写入此输出流。 |
| `void write(byte[] b, int off, int len)` | 将指定字节数组中从偏移量 `off` 开始的 `len` 个字节写入此输出流。 |
| `void close()` | 关闭此文件输出流并释放与此流有关的所有系统资源。 |
| `void flush()` | 刷新此输出流并强制写出所有缓冲的输出字节。 |


3. **标准操作步骤**

使用 I/O 流时应遵循“打开 -> 操作 -> 关闭”的原则。

    1. **创建流对象**：指定文件路径。
    2. **写出数据**：调用 `write` 方法。
    3. **释放资源**：调用 `close` 方法（必须执行，否则文件会被占用或数据丢失）。
4. **应用实例1**

<font style="color:rgb(31, 35, 40);">请使用FileOutputStream 在a.txt 文件，中写入“hello，world”. 如果文件不存在，会创建文件(注意：前提是目录已经存在)</font>

```java
package com.aurora.IOStream.IOStreamDemo;

import org.junit.jupiter.api.Test;

import java.io.FileOutputStream;
import java.io.IOException;

public class FileOutputStreamDemo01 {
    public static void main(String[] args) {

    }

    /**
     * 请使用FileOutputStream 在a.txt 文件，中写入“hello，world”. 如果文件不存在，会创建文件(注意：前提是目录已经存在)
     */
    @Test
    public void fileWriter() {
        String filePath = "src/file_test/a.txt";
        FileOutputStream fileOutputStream = null;
        try {
            // 1. 创建对象（追加模式）
            // new FileOutputStream(filePath, true) 创建方式，当写入内容是，是追加到文件后面
            fileOutputStream = new FileOutputStream(filePath, true);

            // 2. 写入数据
            // 方式 A: .写入单个字符
            fileOutputStream.write('#');
            String str = "hello, world";
            // 方式 B: 写入整个字符串转出的字节数组
            fileOutputStream.write(str.getBytes());
            // 方式 C: 写入数组的一部分 (从索引0开始写入3个字节，即 "hel")
            fileOutputStream.write(str.getBytes(), 0, 3);
        } catch (IOException e)  {
            e.printStackTrace();
        } finally {
            // 3. 释放资源：必须放在 finally 中确保执行
            try {
                if (fileOutputStream != null) {
                    fileOutputStream.close();
                }
            }  catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

5. **应用实例2**

变成完成图片/音乐的拷贝

+ 将`src/picture/source/shot.jpg`拷贝到`src/picture/dest/shot.jpg`

```java
package com.aurora.IOStream.IOStreamDemo;

import org.junit.jupiter.api.Test;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class FileOutputStreamDemo02 {
    public static void main(String[] args) {

    }

    /**
     * 将src/img/source/shot.jpg拷贝到src/img/dest/shot.jpg
     */
    @Test
    public void copyFile() {
        String sourcePath = "src/img/source/shot.jpg";
        String destPath = "src/img/dest/shot.jpg";
        int readLen = 0;
        byte[] buf = new byte[1024];

        FileInputStream fileInputStream = null;
        FileOutputStream fileOutputStream = null;

        try {
            //1. 创建文件的输入流和输出流
            fileInputStream = new FileInputStream(sourcePath);
            fileOutputStream = new FileOutputStream(destPath);
            //2. 一边读，一边写
            while ((readLen = fileInputStream.read(buf)) != -1) {
                fileOutputStream.write(buf, 0, readLen);
            }
            System.out.println("拷贝成功！");
        }catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭输入流和输出流
            try {
                if (fileInputStream != null) {
                    fileInputStream.close();
                }
                if (fileOutputStream != null) {
                    fileOutputStream.close();
                }
            }  catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

## FileReader和FileWriter
### 基本介绍
1. 概念：在 Java IO 流中，`FileReader` 和 `FileWriter` 是专门用于处理**字符文件**的节点流（属于字符流 `Reader` 和 `Writer` 的子类）。它们以字符为单位进行操作，非常适合处理文本文件（如 `.txt`）。

### 与FileInputStream/FileOutputStream的区别
1. **处理单位不同**
+ **FileInputStream / FileOutputStream**：是**字节流**。
    - 以 `byte`（8位）为单位进行读写。
    - 它不关心数据的具体编码，只是机械地搬运二进制字节。
+ **FileReader / FileWriter**：是**字符流**。
    - 以 `char`（16位，Unicode 字符）为单位进行读写。
    - 它会将读取到的字节根据特定的字符集（如 UTF-8）解码为字符，或者将字符编码为字节写入。
2. **适用常用不同**
+ **字节流（Stream）**：适用于所有类型的文件。
    - 包括**二进制文件**（如：图片、视频、音频、PDF、可执行文件等）。
    - 如果用字节流读文本文件，在处理中文等多字节字符时，若缓冲区大小设置不当，容易出现“乱码”问题（因为一个汉字可能占 3 个字节，如果读取时被截断就会报错）。
+ **字符流（Reader/Writer）**：仅适用于**纯文本文件**。
    - 如：`.txt`、`.java`、`.html`、`.xml` 等。
    - 它专门为文本处理优化，能自动处理字符编码，直接读写字符串非常方便。
3. **结论**
+ 如果要处理的是图片或视频，请务必使用字节流；
+ 如果处理的是普通的文本内容，使用 `FileReader` 和 `FileWriter` 会更加高效且简单。  

### FileReader知识点
`FileReader` 用于从文件中读取字符数据。

1. **构造方法：**`new FileReader(File/String)`
2. **read()**：每次读取单个字符，返回该字符的 Unicode 编码值。如果到达文件末尾，返回 `-1`。
3. **read(char[] cbuf)**：批量读取多个字符到数组中，返回实际读取到的字符数。如果到达文件末尾，返回 `-1`。
4. **相关辅助API**
+ `new String(char[] value)`：将整个字符数组转换为字符串。
+ `new String(char[] value, int offset, int count)`：将字符数组的指定部分（从 `offset` 开始读取 `count` 个字符）转换为字符串。
    - 使用示例：`<font style="background-color:rgba(255, 255, 255, 0);">new String(buf, 0, readLen)</font>`<font style="background-color:rgba(255, 255, 255, 0);">，</font>`<font style="background-color:rgba(255, 255, 255, 0);">readLen</font>`<font style="background-color:rgba(255, 255, 255, 0);">为</font>`<font style="background-color:rgba(255, 255, 255, 0);">fileInputStream.read(buf)</font>`<font style="background-color:rgba(255, 255, 255, 0);">或</font>`<font style="background-color:rgba(255, 255, 255, 0);">fileReader.read(buf)</font>`<font style="background-color:rgba(255, 255, 255, 0);">的返回值，使用这个</font>`<font style="background-color:rgba(255, 255, 255, 0);">new String</font>`<font style="background-color:rgba(255, 255, 255, 0);">语句可以防止在读取到文件末尾时出现错误</font>

### FileWriter知识点
`FileWriter` 用于向文件中写入字符数据。

1. **构造方法**
+ `new FileWriter(File/String)`：**覆盖模式**。如果文件已存在，会覆盖原有内容。
+ `new FileWriter(File/String, true)`：**追加模式**。在文件末尾添加内容。
2. **write(int c)**：写入单个字符。
3. **write(char[] cbuf)**：写入字符数组。
4. **write(char[] cbuf, int off, int len)**：写入字符数组的指定部分。
5. **write(String str)**：直接写入整个字符串。
6. **write(String str, int off, int len)**：写入字符串的指定部分。
7. **注意事项：****FileWriter 使用后必须进行 **`**close()**`** 或 **`**flush()**`** 操作！**
+ **原因：**FileWriter 内部维护了一个缓冲区。写入数据时，数据首先被保存在内存中，只有显式调用了 `flush()` 或 `close()`，数据才会真正同步到磁盘文件。`close()` 在关闭流之前会自动调用一次 `flush()`。

### FileReader和FileWriter应用案例
1. <font style="color:rgb(31, 35, 40);">使用FileReader 从story.txt 读取内容，并显示</font>

```java
package com.aurora.IOStream.IOStreamDemo;

import org.junit.jupiter.api.Test;

import java.io.FileReader;
import java.io.IOException;

public class FileReaderDemo01 {
    public static void main(String[] args) {

    }

    //使用FileReader 从story.txt 读取内容，并显示
    /**
     * 单个字符读取示例
     */
    @Test
    public void reader_txt() {
        String filePath = "src/file_test/IOStream/story.txt";
        FileReader  fileReader = null;
        int data = 0;
        try {
            fileReader = new FileReader(filePath);
            // 循环读取：返回的是 int 类型的字符编码
            while ((data = fileReader.read()) != -1) {
                System.out.print((char) data);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (fileReader != null) {
                    fileReader.close();
                }
            }  catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    @Test
    public void reader_txt_array() {
        String filePath = "src/file_test/IOStream/story.txt";
        FileReader  fileReader = null;
        int readLen = 0;
        char[]  buf = new char[8];  // 定义 8 个字符大小的缓冲区
        try {
            fileReader = new FileReader(filePath);
            while ((readLen = fileReader.read(buf)) != -1) {
                System.out.print(new String(buf, 0, readLen));
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (fileReader != null) {
                    fileReader.close();
                }
            }  catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766548570728-5e3c9843-b005-4815-b534-07c5b384f6e7.png)

2. FileWriter写入文件内容

```java
package com.aurora.IOStream.IOStreamDemo;

import org.junit.jupiter.api.Test;

import java.io.FileWriter;
import java.io.IOException;

public class FileWriterDemo01 {
    public static void main(String[] args) {

    }

    @Test
    public void writer() {
        String filePath = "src/file_test/IOStream/note.txt";
        FileWriter fileWriter = null;
        char[] chars = {'a', 'b', 'c', 'd', 'e', 'f', '\n'};

        try {
            fileWriter = new FileWriter(filePath, true);    //追加模式

            // 1. 写入单个字符
            fileWriter.write('A');

            // 2. 写入字符数组
            fileWriter.write(chars);

            // 3. 写入字符数组的部分内容
            fileWriter.write(chars, 1, 3);

            // 4. 写入整个字符串
            fileWriter.write("春风若有怜花意，可否使我再少年\n");

            // 5. 写入字符串的部分内容 (offset, len)
            fileWriter.write("北京上海天津", 0, 4);

        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (fileWriter != null) {
                    fileWriter.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

# 节点流和处理流
## 基本介绍
1. **节点流**
+ **定义**：直接从一个特定的数据源（如文件、内存、网络连接）读写数据的流。
+ **特点**：直接与具体的物理媒介相连。
+ **示例**：
    - **文件（前面讲到的）**：`FileInputStream`, `FileOutputStream`, `FileReader`, `FileWriter`
    - **数组**：`ByteArrayInputStream`, `CharArrayReader`
    - **字符串**：`StringReader`, `StringWriter`
+ **局限**：节点流的功能通常比较单一，且读写效率受到物理媒介的限制（例如频繁的磁盘 I/O 操作会导致性能低下）。
2. **处理流**
+ **定义**：不直接连接到数据源，而是“连接”在已存在的流（节点流或处理流）之上。它通过对数据的处理，为程序提供更强大的读写功能。处理流也常被称为**包装流**。
+ **特点**：
    - **功能增强**：提供缓冲、对象序列化、基本数据类型读写等额外功能。
    - **效率提升**：如 `Buffered` 系列流通过缓冲区减少物理 I/O 次数。
    - **消除差异**：包装流屏蔽了底层不同节点流的实现细节，统一了操作接口。
+ **示例**：
    - **缓冲流**：`BufferedInputStream`, `BufferedReader` (提高效率)
    - **转换流**：`InputStreamReader` (字节转字符)
    - **对象流**：`ObjectOutputStream` (序列化对象)
    - **打印流**：`PrintWriter`, `PrintStream`

## 节点流与处理流的区别与联系
1. **连接对象**：节点流直接跟数据源相接；**处理流包装节点流**，不直接与数据源相连。
2. **职责分配**：节点流负责物理传输；处理流负责功能增强（如批量处理、性能优化）。
3. **设计模式**：处理流使用了**装饰器设计模式**（Decorator Pattern）。它内部持有一个被包装流的引用，通过多态机制调用底层流的方法，同时扩展自己的特有方法。
4. **节点流和处理流一览图**

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766557457344-cb531365-77e3-4e72-866c-f721a7346b83.png)

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766557994628-df45f3ce-7ac1-4100-80d5-5d2d40069b2e.png)

## 模拟装饰器模式实现
为了深入理解处理流是如何包装节点流的，我们可以通过以下模拟代码来观察其内部逻辑：

+ **抽象父类**

```java
package com.aurora.IOStream.ProcessingStream;

public abstract class Reader_ {
    public void readFile(){};   // 模拟抽象类
    public void readString(){};

    // 实际开发中通常定义抽象方法供子类实现
    // public abstract void read();
}
```

+ **节点流实现类**

```java
package com.aurora.IOStream.ProcessingStream;

// 模拟读取文件的节点流
public class FileReader_ extends Reader_{
    @Override
    public void readFile() {
        System.out.println("读取文件...");
    }
}
```

```java
package com.aurora.IOStream.ProcessingStream;

// 模拟读取字符串的节点流
public class StringReader_ extends Reader_{
    @Override
    public void readString() {
        System.out.println("读取字符串...");
    }
}
```

+ **处理流/包装流**

```java
package com.aurora.IOStream.ProcessingStream;

// 模拟包装流
public class BufferedReader_ extends Reader_{

    private Reader_ reader_;    // 属性是 Reader_ 类型，体现了包装

    // 接收 Reader_ 的任何子类对象（多态）
    public BufferedReader_(Reader_ reader_) {
        this.reader_ = reader_;
    }

    //基础封装
    public void readFile() {
        reader_.readFile();
    }

    public void readString() {
        reader_.readString();
    }

    //包装，扩展功能：多次读取文件，也可以增加其他功能，例如加缓冲byte[] ....
    public void readFiles(int num) {
        for (int i = 0; i < num; i++) {
            reader_.readFile();
        }
    }
    //包装，扩展功能：批量处理字符串
    public void readStrings(int num) {
        for (int i = 0; i < num; i++) {
            reader_.readString();
        }
    }
}
```

+ 测试调用

```java
package com.aurora.IOStream.ProcessingStream;

public class Test_ {
    public static void main(String[] args) {
        // 包装文件节点流
        BufferedReader_ bufferedReader_1 = new BufferedReader_(new FileReader_());
        bufferedReader_1.readFiles(5);

        BufferedReader_ bufferedReader_2 = new BufferedReader_(new StringReader_());
        bufferedReader_2.readStrings(5);
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766556859559-f91ccc62-2599-4bac-8efb-5f341b300849.png)

## 处理流BufferedReader和BuffuredWriter
### 基本介绍
![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766558113792-81a7c462-14ab-4922-a6ca-09ead79e243d.png)

1. **介绍**：`BufferedReader` 和 `BufferedWriter` 属于字符流中的**处理流（包装流）**。它们通过内置缓冲区来提高读写效率，并提供了按行读取、跨平台换行等高级功能。
2. **和新特性**
+ **按字符处理**：继承自 `Reader` 和 `Writer`，以字符为单位进行操作。
+ **包装模式**：属于处理流，构造时需要传入一个节点流（如 `FileReader` 或 `FileWriter`）。
+ **自动关闭**：关闭外层处理流时，底层包装的节点流会自动关闭。在 `BufferedReader` 的 `close()` 方法中，它会同步锁住对象并调用内部节点流的 `close()`：

```java
public void close() throws IOException {
    synchronized (lock) {
        if (in == null) return;
        try {
            in.close(); // 这里的 in 就是构造时传入的 FileReader
        } finally {
            in = null;
            cb = null;
        }
    }
}
```

3. **BufferedReader常用方法**
+ **readLine()**：读取一行文本。
    - 读取到换行符或回车符时结束。
    - **返回结果**：返回该行内容的字符串（不包含换行符）。如果到达文件末尾，返回 `null`。
4. **BufferedWriter常用方法**
+ **write(String str)**：写入字符串。
+ **newLine()**：写入一个与当前操作系统相关的换行符（Windows 是 `\r\n`，Linux 是 `\n`）。这比手动写 `\n` 具有更好的跨平台兼容性。

### 应用案例
1. <font style="color:rgb(31, 35, 40);">使用BufferedReader读取文本文件，并显示在控制台</font>

```java
package com.aurora.IOStream.ProcessingStream;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class BufferedReaderDemo01 {
    public static void main(String[] args) throws IOException {
        String filePath = "module3/src/file_test/IOStream/test.java";
        
        // 1. 创建 BufferedReader 包装 FileReader
        BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath));
        
        // 2. 按行读取
        String line;
        while ((line = bufferedReader.readLine()) != null) {
            System.out.println(line);
        }

        // 3. 只需关闭外层流
        bufferedReader.close();

    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766577050862-6b28d212-3d03-4335-af39-760b64914640.png)

2. 使用BufferedWriter将`"hello, 教育"`写入到文件中

```java
package com.aurora.IOStream.ProcessingStream;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class BufferedWriterDemo01 {
    public static void main(String[] args) throws IOException {
        String filePath = "module3/src/file_test/IOStream/test1.txt";

        // 参数 true 表示以追加方式写入，否则为覆盖写入
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(filePath, true));
        bufferedWriter.write("hello, 教育");
        bufferedWriter.newLine();   // 插入系统相关的换行符
        bufferedWriter.write("hello, world");
        bufferedWriter.newLine();

        // 关闭外层流即可
        bufferedWriter.close();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766577513028-2ef4078b-1964-4717-84aa-2f1740bcc540.png)

3. 综合使用BufferedReader和BufferedWriter完成文本文件拷贝，注意文件编码

```java
package com.aurora.IOStream.ProcessingStream;

import java.io.*;

public class BufferedCopy {
    public static void main(String[] args) {
        String sourcePath = "module3/src/file_test/IOStream/source01.txt";
        String destPath = "module3/src/file_test/IOStream/dest01.txt";
        BufferedReader bufferedReader = null;
        BufferedWriter bufferedWriter = null;

        try {
            bufferedReader = new BufferedReader(new FileReader(sourcePath));
            bufferedWriter = new BufferedWriter(new FileWriter(destPath));
            String line;
            // readLine() 读取内容不包含换行符
            while ((line = bufferedReader.readLine()) != null) {
                bufferedWriter.write(line); // 写入读取的内容
                bufferedWriter.newLine();   // 补上换行符
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (bufferedReader != null) {
                    bufferedReader.close();
                }
                if (bufferedWriter != null) {
                    bufferedWriter.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }

        }
    }
}
```

### 注意
1. **文件类型限制**：`BufferedReader` 和 `BufferedWriter` 是**字符流**。请勿使用它们处理二进制文件（如视频、音频、图片、PDF 等），否则可能导致文件损坏。
2. **二进制文件处理**：如果需要处理二进制文件并提升效率，应使用字节缓冲流：`BufferedInputStream` 和 `BufferedOutputStream`。
3. **newLine() 优势**：在不同操作系统下，换行符表示不同。`newLine()` 能根据当前运行环境自动切换，增强了代码的可移植性。

## 处理流BufferedInputStream和BufferedOutputStream
### 基本介绍
1. **概念**：`BufferedInputStream` 和 `BufferedOutputStream` 属于**字节流**中的**处理流（包装流）**。它们通过在内存中创建缓冲区数组，减少了对底层系统的直接调用次数，从而显著提高了二进制文件（如图片、音频、视频）的读写效率。
2. **核心特性**
+ **字节级操作**：继承自 `FilterInputStream` 和 `FilterOutputStream`，以字节（byte）为单位读写。
+ **内置缓冲区**：
    - `BufferedInputStream`：读取时，会先尝试从内部缓冲区获取数据，如果缓冲区为空，则从底层流中批量填充。
    - `BufferedOutputStream`：写入时，数据先存入缓冲区，直到缓冲区满或调用 `flush()/close()` 时才真正写入底层输出流。
+ **包装模式**：构造时需要传入节点流（如 `FileInputStream` 或 `FileOutputStream`）。
+ **自动关闭**：只需关闭最外层的处理流，内部的节点流会自动随之关闭。
3. **优势**
+ **通用性强**：字节流是万能的。它既可以操作**二进制文件**（图片、视频、doc、pdf等），也可以操作**文本文件**。
+ **性能优越**：对于大文件，使用缓冲流比直接使用 `FileInputStream` 快得多。
+ **注意**：虽然字节流能读文本，但如果直接将读取的字节转为字符显示，可能会因字符编码（如 UTF-8 汉字占 3 字节）被截断而产生乱码。

### 应用案例
变成完成图片/音乐的拷贝，要求使用`Buffered...`流

```java
package com.aurora.IOStream.ProcessingStream;

import java.io.*;

public class BufferedCopy02 {
    public static void main(String[] args) {
        String sourcePath = "module3/src/img/source01/picture.jpg";
        String destPath = "module3/src/img/dest01/picture.jpg";

        BufferedInputStream bis = null;
        BufferedOutputStream bos = null;

        try {
            // 1. 创建节点流并包装进处理流
            bis = new BufferedInputStream(new FileInputStream(sourcePath));
            bos = new BufferedOutputStream(new FileOutputStream(destPath));

            byte[] buf =  new byte[1024];   // 1KB 的自定义中转缓冲区
            int readLen = 0;

            // 2. 循环读取并写入
            // read(buff) 返回实际读取的字节数，到达末尾返回 -1
            while ((readLen = bis.read(buf)) != -1) {
                // 将读取到的有效字节写入输出流
                bos.write(buf, 0, readLen);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 3. 释放资源
            // 只需要关闭外层的处理流即可，底层会通过源码中的 close 方法自动关闭节点流
            try {
                if (bis != null) {
                    bis.close();
                }
                if (bos != null) {
                    bos.close();
                }
            }  catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

**注意**：代码里自定义的缓冲区`buf`和处理流的缓冲区不是一个东西

1. **它们分别是什么？**
+ **处理流内部缓冲区 (Internal Buffer)**：这是由 `BufferedInputStream/OutputStream` 类内部维护的一个 `byte[]` 数组（默认大小通常为 8192 字节，即 8KB）。
    - **职责**：减少 Java 程序与操作系统/磁盘之间的物理交互次数。
+ **自定义字节数组 (Application Buffer)**：就是代码里写的 `byte[] buff = new byte[1024]`。
    - **职责**：作为你程序逻辑中的“搬运工具”，用于在 `while` 循环中暂存从输入流读到的数据，然后再交给输出流。
2. **数据的流转过程**

当你执行这段拷贝代码时，数据的实际流动路径是这样的：

+ **磁盘文件**![image](https://cdn.nlark.com/yuque/__latex/33b44e34aa35b8c4ecd0606453ee68e9.svg)(读取 8KB) ![image](https://cdn.nlark.com/yuque/__latex/33b44e34aa35b8c4ecd0606453ee68e9.svg)**处理流内部缓冲区**
+ **处理流内部缓冲区**![image](https://cdn.nlark.com/yuque/__latex/33b44e34aa35b8c4ecd0606453ee68e9.svg)(读取 1KB) ![image](https://cdn.nlark.com/yuque/__latex/33b44e34aa35b8c4ecd0606453ee68e9.svg)**你的自定义 **`**buff**`** 数组**
+ **你的自定义 **`**buff**`** 数组**![image](https://cdn.nlark.com/yuque/__latex/33b44e34aa35b8c4ecd0606453ee68e9.svg) (写入 1KB) ![image](https://cdn.nlark.com/yuque/__latex/33b44e34aa35b8c4ecd0606453ee68e9.svg)**处理流输出缓冲区**
+ **处理流输出缓冲区**![image](https://cdn.nlark.com/yuque/__latex/33b44e34aa35b8c4ecd0606453ee68e9.svg) (累计到 8KB 后一次性写入) ![image](https://cdn.nlark.com/yuque/__latex/33b44e34aa35b8c4ecd0606453ee68e9.svg)**磁盘文件**
3. **既然有了内部缓冲区，为什么还要写自定义 **`**buff**`**？**
+ **代码习惯**：`read(byte[] b)` 是最常用的读取方式，它比单个字节读取 `read()` 效率更高，因为它减少了进入 `while` 循环判断的次数。
+ **解耦**：处理流的缓冲区是为了**性能优化**（底层），而你的自定义数组是为了**逻辑操作**（业务层）。即使你把自定义数组设为 1 字节（`new byte[1]`），由于处理流内部 8KB 缓冲区的存在，整体速度依然会比没有处理流时快得多。

## 对象流ObjectInputStream和ObjectOutputStream
### 需求
1. **需求：为什么需要对象流？**

在普通的字节流或字符流中，我们只能保存数据的值（例如：将 100 写入文件，读取时只能得到字符串 "100" 或字节）。 **对象流的需求**：不仅需要保存**值**，还需要保存数据的**类型**。

+ 例如：将 `int num = 100` 保存，恢复时它依然是 `int` 类型的 `100`。
+ 例如：将一个 `Dog` 对象保存，恢复时它依然是一个完整的 `Dog` 对象。

### 序列化
1. **序列化和反序列化**
+ **序列化 (Serialization)**：在保存数据时，保存数据的值和数据类型。使用 `ObjectOutputStream` 实现。
+ **反序列化 (Deserialization)**：在恢复数据时，恢复数据的值和数据类型。使用 `ObjectInputStream` 实现。

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766628825163-e2034bae-4514-4ba3-b9c2-5bb7a29e7f47.png)

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766628851763-7e0841e2-1b7b-46dd-85a0-7a1299158d61.png)

2. **序列化机制要求**

要使一个类支持序列化，该类必须实现以下两个接口**之一**：

+ `**Serializable**`：这是一个**标记接口**，内部没有任何方法。这是最常用的方式。
+ `**Externalizable**`：该接口有方法需要实现（`writeExternal` 和 `readExternal`），通常用于更复杂的自定义序列化逻辑。

### 应用案例
1. <font style="color:rgb(31, 35, 40);">使用ObjectOutputStream序列化基本数据类型和一个Dog对象(name, age),并保存到data.dat文件中。</font>

```java
package com.aurora.IOStream.ProcessingStream.ObjectStream;

import java.io.Serializable;

public class Dog implements Serializable {
    private String name;
    private int age;

    // 引用类型属性也需要实现序列化
    private Master master = new Master();

    // static 和 transient 不会被序列化
    private static String nation;   // 静态变量属于类,不属于对象
    private transient String color; // 瞬态变量不会被保存到文件

    // 建议手动添加版本号，提高兼容性
    private static final long serialVersionUID = 1L;

    public Dog(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Dog(String name, int age, String nation, String color) {
        this.name = name;
        this.age = age;
        Dog.nation = nation;
        this.color = color;
    }

    @Override
    public String toString() {
        return "Dog{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", master=" + master +
                ", color='" + color + '\'' +
                '}';
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Master getMaster() {
        return master;
    }

    public void setMaster(Master master) {
        this.master = master;
    }

    public static String getNation() {
        return nation;
    }

    public static void setNation(String nation) {
        Dog.nation = nation;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }
}
```

```java
package com.aurora.IOStream.ProcessingStream.ObjectStream;

import java.io.Serializable;

// 引用类型属性也需要实现序列化
public class Master implements Serializable {
    private static final long serialVersionUID = 1L;

    @Override
    public String toString() {
        return "Master{}";
    }
}
```

```java
package com.aurora.IOStream.ProcessingStream.ObjectStream;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;

public class ObjectOutputStreamDemo01 {
    public static void main(String[] args) throws IOException {
        String filePath = "module3/src/file_test/IOStream/data.dat";
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath));

        // 1. 序列化基本数据类型
        oos.writeInt(100);          // int -> Integer
        oos.writeBoolean(true);     // boolean -> Boolean
        oos.writeChar('a');         // char -> Character
        oos.writeDouble(9.5);       // double -> Double
        oos.writeUTF("hello");      // String

        // 2. 序列化对象
        oos.writeObject(new Dog("tom", 10, "China", "black"));

        oos.close();
        System.out.println("数据序列化并保存完毕！");
    }
}
```

2. <font style="color:rgb(31, 35, 40);">使用ObjectlnputStream 读取data.dat 并反序列化恢复数据</font>

```java
package com.aurora.IOStream.ProcessingStream.ObjectStream;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;

public class ObjectInputStreamDemo01 {
    public static void main(String[] args) throws IOException, ClassNotFoundException{
        String filePath = "module3/src/file_test/IOStream/data.dat";
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath));

        // 读取顺序必须与写入顺序一致！
        int a =  ois.readInt();     //可以定义一个同类变量接收
        System.out.println(a);
        System.out.println(ois.readBoolean());
        System.out.println(ois.readChar());
        System.out.println(ois.readDouble());
        System.out.println(ois.readUTF());

        Object object = ois.readObject();   //readObject的返回值类型为Object
        System.out.println("运行类型" + object.getClass()); //实际运行类型还是Dog
        System.out.println(object);

        // 如果要调用子类特有方法，需要向下转型
        Dog dog = (Dog) object;
        System.out.println(dog.getName());

        ois.close();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766631556015-3e24d6ca-03dc-4319-9288-ca537e5a4031.png)

### 注意事项及细节总结
1. **读写顺序一致性**：读取数据的顺序必须严格按照写入数据的顺序进行（例如先写 `int` 后写 `Dog`，则必须先读 `int` 后读 `Dog`）。
2. **实现 Serializable**：序列化或反序列化的类及其内部非基本类型的属性，都必须实现 `Serializable`。
3. **serialVersionUID**：
    - 建议手动定义：`private static final long serialVersionUID = 1L;`
    - **作用**：当类修改（如增加新属性）后，反序列化时仍能识别为原来的类，提高兼容性。
4. **属性过滤**：
    - `static` (静态)：属于类级别，不参与对象序列化。
    - `transient` (瞬态)：标记该属性不参与序列化过程。
5. **继承性**：如果一个类实现了序列化，那么它的所有子类默认也具备序列化能力。
6. **流关闭**：关闭外层流（ObjectStream）即可，底层的文件流会自动关闭。

## 标准输入输出流
1. 概念：在 Java 中，`System` 类提供了两个静态成员变量 `in` 和 `out`，分别代表标准输入流和标准输出流。
2. `**System.in**`**（标准输入）**
+ **编译类型**：`InputStream`
+ **运行类型**：`BufferedInputStream`
+ **默认设备**：键盘
+ **特点**：用于从外部环境（通常是用户输入）接收字节数据。
3. `**System.out**`**（标准输出）**
+ **编译类型**：`PrintStream`
+ **运行类型**：`PrintStream`
+ **默认设备**：显示器 (控制台)
+ **特点**：用于将数据输出到控制台。
4. **案例演示**

以下代码演示了如何检查这些流的运行类型，以及如何配合 `Scanner` 获取用户输入。

```java
package com.aurora.IOStream.ProcessingStream;

import java.util.Scanner;

public class StandardIO {
    public static void main(String[] args) {

        /**
         * 1. System.in 分析
         * 编译类型: InputStream
         * 运行类型: BufferedInputStream (因为底层被包装过，提高效率)
         */
        System.out.println("System.in的运行类型：" + System.in.getClass());

        /**
         * 2. System.out 分析
         * 编译类型: PrintStream
         * 运行类型: PrintStream
         */
        System.out.println("System.out的运行类型：" + System.out.getClass());

        /**
         * 3. 传统输出：使用 System.out 将数据输出到显示器
         */
        System.out.println("--- 正在使用标准输出 ---");
        System.out.println("Hello, Java 标准输出流");

        /**
         * 4. 传统输入：配合 Scanner 从键盘接收数据
         * Scanner 构造函数接收一个 InputStream 类型的参数，即 System.in
         */
        Scanner scanner = new Scanner(System.in);
        System.out.println("\n请输入一段内容并按回车：");
        String str = scanner.next();
        System.out.println("str = " + str);

        // 注意：Scanner 最好不要随意关闭，因为它关联的是 System.in，
        // 一旦关闭，整个程序运行期间都无法再开启 System.in。
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766632794317-01e04dd5-ab5f-40f7-9575-4050eafd4fe5.png)

## 转换流InputStreamReader和OutputStreamWriter
转换流是连接字节流和字符流的桥梁。它们可以将底层的字节流（InputStream/OutputStream）转换成高级的字符流（Reader/Writer），从而方便处理文本数据。

### 需求_为什么需要转换流
1. **解决乱码问题**：不同的文件可能采用不同的编码格式（如 UTF-8, GBK, ISO8859-1）。如果直接使用普通的字符流读取，而编码不匹配，就会出现中文乱码。
2. **提高效率**：字符流在处理文本时比字节流效率更高。
3. **指定编码**：转换流允许我们在转换过程中手动指定字符集（Charset）。
4. **核心理解**：
+ **InputStreamReader**: 相当于把 `InputStream`（字节流）转为 `Reader`（字符流）。
+ **OutputStreamWriter**: 相当于把 `OutputStream`（字节流）转为 `Writer`（字符流）。

### 基本介绍
1. **InputStreamReader**
+ **父类**：`Reader`
+ **功能**：将一个字节输入流转换为字符输入流。
+ **常用构造器**：`new InputStreamReader(InputStream in, String charsetName)`
2. **OutputStreamWriter**
+ **父类**：`Writer`
+ **功能**：将一个字节输出流转换为字符输出流。
+ **常用构造器**：`new OutputStreamWriter(OutputStream out, String charsetName)`

### 应用案例
1. **使用InputStreamReader读取文本（解决GBK乱码）**

需求：将字节流 `FileInputStream` 转换为字符流 `InputStreamReader`，并指定编码为 `gbk`，最后包装成 `BufferedReader` 提高读取效率。

```java
package com.aurora.IOStream.ProcessingStream;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;

public class InputStreamReaderDemo01 {
    public static void main(String[] args) throws IOException {
        /**
         * 将字节流 FileInputStream 转换为字符流 InputStreamReader，并指定编码为 gbk，最后包装成 BufferedReader 提高读取效率。
         */
        String filePath = "module3/src/file_test/IOStream/song.txt";

        // 1. 创建字节输入流
        FileInputStream fileInputStream = new FileInputStream(filePath);

        // 2. 将字节流转换为字符流，并指定编码格式为 gbk
        InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream, "GBK");

        // 3. 进一步包装成 BufferedReader 以便按行读取
        BufferedReader bufferedReader = new BufferedReader(inputStreamReader);

        // 4. 读取数据
        String line;
        while ((line = bufferedReader.readLine()) != null) {
            System.out.println(line);
        }

        // 5. 关闭流（只需关闭最外层流即可）
        bufferedReader.close();
    }
}
```

2. **使用OutputStreamWriter写入文本，制定编码保存**

将字节流 `FileOutputStream` 转换为字符流 `OutputStreamWriter`，并将字符串按指定编码（如 `utf-8`）保存到文件。

```java
package com.aurora.IOStream.ProcessingStream;

import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;

public class OutputStreamWriterDemo01 {
    public static void main(String[] args) throws IOException {
        /**
         * 将字节流 FileOutputStream 转换为字符流 OutputStreamWriter，并将字符串按指定编码（如 utf-8）保存到文件。
         */

        String filePath = "module3/src/file_test/IOStream/test2.txt";
        // 1. 创建字节输出流
        FileOutputStream fileOutputStream = new FileOutputStream(filePath);

        // 2. 将字节流转换为字符流，并指定编码格式为 utf-8
        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileOutputStream, "utf-8");

        // 3. 进一步包装成 BufferedReader 提升效率
        BufferedWriter bufferedWriter = new BufferedWriter(outputStreamWriter);

        // 4. 写入内容
        bufferedWriter.write("hello world");

        // 5. 关闭流
        bufferedWriter.close();

        System.out.println("文件已写入成功");
    }
}
```

**总结：**

+ **配套使用**：转换流通常会与包装流（如 `BufferedReader` / `BufferedWriter`）配合使用，以获得更好的性能。
+ **编码一致性**：读取文件时指定的编码必须与文件本身的存储编码一致，否则依然会出现乱码。
+ **关闭资源**：关闭包装流（外层流）会自动关闭其包装的底层流。

## 打印流PrintStream和PrintWriter
### 基本介绍
1. **概述**：打印流是 Java IO 家族中非常实用的工具类。它们的主要特点是**只有输出流，没有输入流**，并且提供了多种方便的打印方法（如 `print`, `println`, `printf`）。
2. **特点**
+ **功能丰富**：不仅可以输出字节/字符，还可以自动格式化各种数据类型（int, double, String 等）。
+ **不抛异常**：打印流的方法通常不会抛出 `IOException`（尽管构造器可能会）。
+ **只有输出**：专注于数据的展示和持久化。
3. **应用场景**
+ **PrintStream**：
    - **控制台交互**：`System.out`。
    - **简易日志**：通过 `System.setOut` 快速把程序运行情况记录到文件。
+ **PrintWriter**：
    - **Web 响应**：在 Java Web 开发中，服务器给浏览器回传 HTML 或 JSON 数据，几乎全是靠 `response.getWriter()` 拿到的 `PrintWriter`。
    - **报表生成**：利用 `printf` 生成对齐整齐的文本账单或报表。
+ **总结**：当只要你需要**“把数据变成好读的文本写出去”**时，首选打印流。

### 字节打印流PrintStream
`PrintStream` 是 `OutputStream` 的子类。我们最熟悉的 `System.out` 其实就是一个 `PrintStream` 实例。

1. **默认输出位置**：在默认情况下，`PrintStream` 的输出目的地是**标准输出（显示器）**。
2. 代码示例

```java
package com.aurora.IOStream.ProcessingStream;

import java.io.IOException;
import java.io.PrintStream;

public class PrintStreamDemo01 {
    public static void main(String[] args) throws IOException {
        PrintStream out = System.out;

        // 1. print 底层使用的是 write 方法
        // 源码逻辑: public void print(String s) { if (s == null) s = "null"; write(s); }
        out.print("hello, world\n");

        // 2. 也可以直接调用 write 进行字节输出
        out.write("你好".getBytes());

        // 3. 修改打印流的输出目的地
        // 可以将输出从显示器重定向到文件
        System.setOut(new PrintStream("module3/src/file_test/IOStream/test3.txt"));
        // 此时，这条信息将不再出现在控制台，而是保存在 test3.txt 中
        System.out.println("hello, Java");

        out.close();
    }
}
```

### 字符打印流PrintWriter
`PrintWriter` 是 `Writer` 的子类，常用于处理文本数据。

1. 它既可以包装字节流（如 `System.out`），也可以包装字符流（如 `FileWriter`）。
2. 代码示例

```java
package com.aurora.IOStream.ProcessingStream;

import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

public class PrintWriterDemo01 {
    public static void main(String[] args) throws IOException {

        // 方式 A: 输出到控制台
        PrintWriter pw1 = new PrintWriter(System.out);
        pw1.print("hello, world");

        // 方式 B: 输出到文件
        PrintWriter pw2 = new PrintWriter(new FileWriter("module3/src/file_test/IOStream/test4.txt"));
        pw2.print("hello, Java");

        // 注意：必须关闭流或显式调用 flush()
        // close() 内部会先调用 flush()，数据才会真正写入文件
        pw1.close();
        pw2.close();
    }
}
```

# Properties类
在开发过程中，我们经常需要处理配置文件（如数据库连接信息 `mysql.properties`）。`Properties` 类是 Java 中专门为此设计的集合类，它继承自 `Hashtable`，专门用于读写键值对形式的配置信息。

## 为什么需要Properties类
1. **传统方法的局限性**

如果使用传统的 `BufferedReader` 读取配置文件，我们需要手动循环读取每一行，并使用字符串分割（如 `split("=")`）来解析键值对。

2. **传统方法代码示例**
+ `mysql.properties`文件的全部内容如下所示

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766666199744-914c15df-0b07-4461-b32f-fe78b960c504.png)

现在需要获取`ip`的值并赋值给变量`ip`

```java
package com.aurora.IOStream.PropertiesDemo;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class PropertiesDemo01 {
    public static void main(String[] args) throws IOException {
        /**
         * 演示传统方法读取配置文件的局限性
         */
        String filePath = "module3/src/file_test/properties/mysql.properties";
        FileReader fileReader = new FileReader(filePath);
        BufferedReader bufferedReader = new BufferedReader(fileReader);
        String line;
        while ((line = bufferedReader.readLine()) != null) {
            //获得ip的值
            String[] split = line.split("=");
            //System.out.println(line);
            if ("ip".equals(split[0])) {
                String ip = split[1];
                System.out.println("ip地址为：" + ip);
            }
        }


        bufferedReader.close();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766666270361-c5d2ff23-c20c-4519-96ce-7a479daf7bbf.png)

**缺点**：逻辑繁琐，如果要修改某个值并保存，代码会变得极其复杂。

3. **Properties类的优势**

`Properties` 类内部已经封装好了所有的解析逻辑，开发者只需关心“键”和“值”本身。

## 基本介绍
+ **定位**：专门用于读写配置文件的集合类。
+ **格式**：配置文件遵循 `键=值` 的格式（如 `user=root`）。
+ **注意点**：
    - 键值对两边建议不要有空格。
    - 值默认不需要加引号。
    - 所有键和值默认都是 `String` 类型。
    - 底层继承自 `Hashtable`，因此它是线程安全的。

## 常用方法
| 方法 | 描述 |
| --- | --- |
| `**load(Reader/InputStream)**` | 加载配置文件的键值对到 Properties 对象中。 |
| `**list(PrintStream/PrintWriter)**` | 将当前加载的所有数据显示到指定设备（常用于调试，如 `list(System.out)`）。 |
| `**getProperty(key)**` | 根据键名获取对应的字符串值。 |
| `**setProperty(key, value)**` | 设置或修改键值对（在内存中生效）。 |
| `**store(Writer/OutputStream, comments)**` | 将 Properties 对象中的键值对持久化到配置文件中。 |


## 应用案例
1. **读取配置文件**

```java
package com.aurora.IOStream.PropertiesDemo;

import java.io.FileReader;
import java.io.IOException;
import java.util.Properties;

public class PropertiesReadDemo01 {
    public static void main(String[] args) throws IOException {
        // 1. 创建 Properties 对象
        Properties properties = new Properties();

        // 2. 加载指定文件
        properties.load(new FileReader("module3/src/file_test/properties/mysql.properties"));

        // 3. 把所有键值对显示到控制台
        properties.list(System.out);

        // 4. 根据指定的 key 获取值
        String user = properties.getProperty("user");
        System.out.println("用户名:" + user);
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766667136391-2bad614f-ee90-4cb4-99c6-77c51bfc2244.png)

2. **创建或修改配置文件**

通过 `setProperty` 方法，如果键不存在则创建，如果键已存在则修改其对应的值。

```java
package com.aurora.IOStream.PropertiesDemo;

import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Properties;

public class PropertiesWriteDemo01 {
    public static void main(String[] args) throws IOException {
        Properties properties = new Properties();

        // 1. 在内存中设置键值对
        properties.setProperty("ip", "192.168.1.1");
        properties.setProperty("user", "root");
        properties.setProperty("password", "123456");

        // 2. 将数据存储到指定文件
        // 第二个参数是 comments (注释)，如果不写可以传 null
        properties.store(new FileWriter("module3/src/file_test/properties/mysql.properties"), "This is a test config");

        System.out.println("保存配置文件成功");
    }
}
```

## 特别说明：Unicode编码
在使用 `store` 方法保存信息时，如果内容包含中文，IDEA 会将其转换为 Unicode 码存储。这并不是乱码，而是为了保证在不同编码环境下的兼容性。读取时，`Properties` 类会自动将其转回中文。

**提示**：如果需要查看 Unicode 对应的原文，可以使用在线转换工具进行查询。

<font style="color:rgb(31, 35, 40);">unicode码查询工具：</font>[<font style="color:rgb(9, 105, 218);">http://tool.chinaz.com/tools/unicode.aspx</font>](http://tool.chinaz.com/tools/unicode.aspx)

# 本章作业
## 作业1
需求：

1. <font style="color:rgb(31, 35, 40);">在判断e盘下是否有文件夹mytemp ,如果没有就创建mytemp</font>
2. <font style="color:rgb(31, 35, 40);">在e:llmytemp目录下，创建文件hello.txt</font>
3. <font style="color:rgb(31, 35, 40);">如果hello.txt已经存在，提示该文件已经存在,就不要再重复创建了</font>
4. <font style="color:rgb(31, 35, 40);">并且在hello.txt文件中，写入hello,world~</font>

```java
package com.aurora.IOStream.Practice;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

public class Practice01 {
    public static void main(String[] args) throws IOException {
        /**
         * 1. 在判断module3/src/file_test下是否有文件夹mytemp ,如果没有就创建mytemp
         * 2. 在module3/src/file_test/mytemp目录下，创建文件hello.txt
         * 3. 如果hello.txt已经存在，提示该文件已经存在,就不要再重复创建了
         * 4. 并且在hello.txt文件中，写入hello,world~
         */

        //1. 在判断e盘下是否有文件夹mytemp ,如果没有就创建mytemp
        File file = new File("module3/src/file_test/mytemp");
        if (!file.exists()) {
            if (file.mkdir()) {
                System.out.println("创建文件夹成功");
            } else {
                System.out.println("创建文件夹失败");
            }
        }

        //2. 在e:llmytemp目录下，创建文件hello.txt
        file = new File("module3/src/file_test/mytemp/hello.txt");

        //3. 如果hello.txt已经存在，提示该文件已经存在,就不要再重复创建了
        if (!file.exists()) {
            if (file.createNewFile()) {
                System.out.println("文件创建成功");
                //4. 并且在hello.txt文件中，写入hello,world~
                FileWriter fw = new FileWriter(file);
                BufferedWriter bw = new BufferedWriter(fw);
                bw.write("hello, world");
                bw.close();
            } else {
                System.out.println("文件创建失败");
            }
        } else {
            System.out.println("文件已经存在");
        }
    }
}
```

## 作业2
1. <font style="color:rgb(31, 35, 40);">要求:使用BufferedReader读取一个文本文件，为每行加上行号，再连同内容一并输出到屏幕上。</font>

```java
package com.aurora.IOStream.Practice;

import java.io.*;

public class Practice02 {
    public static void main(String[] args) {
        /**
         * 要求:使用BufferedReader读取一个文本文件，为每行加上行号，再连同内容一并输出到屏幕上。
         */

        String filePath = "module3/src/file_test/IOStream/practice02.txt";
        BufferedReader bufferedReader = null;
        try {
            FileReader fileReader = new FileReader(filePath);
            bufferedReader = new BufferedReader(fileReader);
            String line;
            int lineNum = 0;
            while ((line = bufferedReader.readLine()) != null) {
                lineNum++;
                System.out.println(line = lineNum + "." + line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            try {
                if (bufferedReader != null) {
                    bufferedReader.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766720083112-5348fd72-f1e5-430b-931d-5cdb801dee28.png)

2. 改进：将添加行号后的内容写入新的文件

```java
package com.aurora.IOStream.Practice;

import java.io.*;

public class practice02_advanced {
    public static void main(String[] args) {
        /**
         * 要求:使用BufferedReader读取一个文本文件，为每行加上行号，再连同内容一并写入另一文件内。
         */
        String filePath = "module3/src/file_test/IOStream/practice02.txt";
        String destPath = "module3/src/file_test/IOStream/practice02_lineNum.txt";

        BufferedReader bufferedReader = null;
        BufferedWriter bufferedWriter = null;

        try {
            FileReader fileReader = new FileReader(filePath);
            bufferedReader = new BufferedReader(fileReader);
            FileWriter fileWriter = new FileWriter(destPath);
            bufferedWriter = new BufferedWriter(fileWriter);
            String line;
            int lineNum = 0;
            while ((line = bufferedReader.readLine()) != null) {
                lineNum++;
                bufferedWriter.write(lineNum + "." + line);
                bufferedWriter.newLine();
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (bufferedReader != null) {
                    bufferedReader.close();
                }
                if (bufferedWriter != null) {
                    bufferedWriter.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766719583269-c26eb636-c6c8-4532-9fc0-2bc8bacdeba6.png)

3. 改进：可以指定编码,防止乱码
+ <font style="color:rgb(31, 35, 40);">使用转换流，将FilelnputStream -> InputStreamReader[可以指定编码]- >BufferedReader ...</font>

```java
package com.aurora.IOStream.Practice;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;

public class Practice02_charset {
    public static void main(String[] args) {
        /**
         * 要求:使用BufferedReader读取一个文本文件，为每行加上行号，再连同内容一并输出到屏幕。
         * 在读取文件时指定编码
         */
        String filePath = "module3/src/file_test/IOStream/practice02.txt";

        BufferedReader bufferedReader = null;
        try {
            FileInputStream fileInputStream = new FileInputStream(filePath);
            InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream, "utf-8");
            bufferedReader = new BufferedReader(inputStreamReader);
            String line;
            int lineNum = 0;
            while ((line = bufferedReader.readLine()) !=  null) {
                lineNum++;
                System.out.println(lineNum + "." + line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (bufferedReader != null) {
                    bufferedReader.close();
                }
            }  catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766720024763-9b709b8e-2be5-4709-8e16-e2e599618e97.png)

## 作业3
1. 需求：
    1. <font style="color:rgb(31, 35, 40);">要编写一个dog.properties</font>
        1. <font style="color:rgb(31, 35, 40);">name=tom</font>
        2. <font style="color:rgb(31, 35, 40);">age=5</font>
        3. <font style="color:rgb(31, 35, 40);">color=red</font>
    2. <font style="color:rgb(31, 35, 40);">编写Dog 类(name,age,color)创建一个dog对象，读取dog.properties用相应的内容完成属性初始化,并输出</font>
    3. <font style="color:rgb(31, 35, 40);">将创建的Dog对象,序列化到文件dog.dat 文件</font>
2. 代码实现
+ Dog类

```java
package com.aurora.IOStream.Practice;

import java.io.Serializable;

/**
 * 创建Dog类，包含属性name, age, color
 * 实现Serializable接口以可序列化
 */
public class Dog implements Serializable {
    private String name;
    private int age;
    private String color;

    private static final long SerialVersionUID = 0L;

    public Dog(String name, int age, String color) {
        this.name = name;
        this.age = age;
        this.color = color;
    }


    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String toString() {
        return "Dog{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", color='" + color + '\'' +
                '}';
    }
}
```

+ 写入一个dog.properties

```java
package com.aurora.IOStream.Practice;

import java.io.FileWriter;
import java.io.IOException;
import java.util.Properties;

/**
 * 写入一个dog.properties
 * name=tom
 * age=5
 * color=red
 */
public class DogPropertiesWriter {
    public static void main(String[] args) throws IOException {
        Properties properties = new Properties();

        properties.setProperty("name", "tom");
        properties.setProperty("age", "5");
        properties.setProperty("color", "red");

        properties.store(new FileWriter("module3/src/file_test/IOStream/dog.properties"), "Dog Properties");

    }
}
```

+ 读取dog.properties并序列化

```java
package com.aurora.IOStream.Practice;

import java.io.*;
import java.util.Properties;

/**
 * 创建一个dog对象，读取dog.properties用相应的内容完成属性初始化,并输出
 * 将创建的Dog对象,序列化到文件dog.dat 文件
 */
public class Practice03 {
    public static void main(String[] args) throws IOException, ClassNotFoundException{


        //读取dog.properties用相应的内容
        Properties properties = new Properties();
        FileReader fileReader = new FileReader("module3/src/file_test/IOStream/dog.properties");
        properties.load(fileReader);
        String name = properties.getProperty("name") + "";
        int age = Integer.parseInt(properties.getProperty("age"));
        String color = properties.getProperty("color") + "";

        //完成属性初始化
        Dog dog = new Dog(name, age, color);

        System.out.println("dog = " + dog);

        //序列化
        FileOutputStream fileOutputStream = new FileOutputStream("module3/src/file_test/IOStream/dog.dat");
        ObjectOutputStream oos = new ObjectOutputStream(fileOutputStream);
        oos.writeObject(dog);

        oos.close();

        //再反序列化读出测试是否序列化成功
        FileInputStream fileInputStream = new FileInputStream("module3/src/file_test/IOStream/dog.dat");
        ObjectInputStream ois = new ObjectInputStream(fileInputStream);
        System.out.println("==============反序列化=============");
        Object object = ois.readObject();
        Dog dog2 = (Dog) object;
        System.out.println("name = " + dog2.getName());
        System.out.println("age = " + dog2.getAge());
        System.out.println("color = " + dog2.getColor());
        ois.close();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1766725530038-ab48edbe-8d73-4442-afed-9b3b4ae3c1c9.png)

