# 线程相关概念
## 程序
1. 定义：程序是<font style="color:rgb(31, 35, 40);">为完成特定任务、用某种语言编写的一组指令的集合。简单的说:就是我们写的代码。</font>

## 进程
1. <font style="color:rgb(31, 35, 40);">进程是指运行中的程序，比如我们使用QQ，就启动了一个进程，操作系统就会为该进程分配内存空间。当我们使用迅雷，又启动了一个进程，操作系统将为迅雷分配新的内存空间。</font>
2. <font style="color:rgb(31, 35, 40);">进程是程序的一次执行过程，或是正在运行的一个程序。是动态过程:有它自身的产生、存在和消亡的过程</font>

## 线程
1. <font style="color:rgb(31, 35, 40);">线程由进程创建的，是进程的执行单元。</font>
2. <font style="color:rgb(31, 35, 40);">一个进程可以拥有多个线程（例如：一个迅雷进程中可以同时开启多个下载任务，每个任务就是一个线程）。</font>

## 运行模式
1. **单线程**
+ **定义**: 同一个时刻，只允许执行一个线程。
+ **特点**: 任务按顺序依次执行。
2. **多线程**
+ **定义**: 同一个时刻，可以执行多个线程。
+ **生活案例**:
    - 一个 QQ 进程可以同时打开多个聊天窗口。
    - 一个迅雷进程可以同时下载多个文件。

## 并发与并行机制
| 概念 | 英文 | 核心解释 | 硬件环境 |
| --- | --- | --- | --- |
| **并发** | Concurrency | 同一个时刻，多个任务**交替执行**。造成一种“貌似同时”的错觉。 | 单核 CPU (或多核CPU处理超量任务时) |
| **并行** | Parallelism | 同一个时刻，多个任务**同时执行**。 | 多核 CPU |


+ 获取CPU的数量/核心数

```java
package com.aurora.MultiThread;

public class CPUNum {
    public static void main(String[] args) {
        //获取当前的Runtime实例
        Runtime rt = Runtime.getRuntime();

        //获取当前电脑的CPU核心数
        int CPUNums = rt.availableProcessors();
        System.out.println("CPUNums: " + CPUNums);
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764666018694-1ce3a404-5583-4d89-a875-53cdcdd33bf6.png)

# 线程的基本使用
## 创建线程的方式
在 Java 中，创建线程主要有以下两种方法：

1. **继承 **`**Thread**`** 类**，重写 `run` 方法。
2. **实现 **`**Runnable**`** 接口**，重写 `run` 方法。

### 继承Thread类
1. **基本步骤**
    1. 定义一个类继承 `Thread`。
    2. 重写 `run()` 方法（编写业务逻辑）。
    3. 创建该类对象。
    4. 调用 `start()` 方法启动线程。
2. 案例
+ <font style="color:rgb(31, 35, 40);">请编写程序,开启一个线程，该线程每隔1秒。在控制台输出</font>`<font style="color:rgb(31, 35, 40);">“喵喵，我是小猫咪”</font>`
+ <font style="color:rgb(31, 35, 40);">对上题改进:当输出80次</font>`<font style="color:rgb(31, 35, 40);">“喵喵，我是小猫咪”</font>`<font style="color:rgb(31, 35, 40);">,结束该线程</font>
+ <font style="color:rgb(31, 35, 40);">使用JConsole 监控线程执行情况,并画出程序示意图!</font>

```java
package com.aurora.MultiThread.ThreadBaseUse;

public class Cat extends Thread{
    int times = 0;
    @Override
    public void run() {
        while (true) {
            System.out.println("喵喵，我是小猫咪" + (++times) + "线程名=" + Thread.currentThread().getName());
            //让线程休眠1秒
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (times == 80) {
                break;
            }
        }

    }
}
```

```java
package com.aurora.MultiThread.ThreadBaseUse;

public class ThreadDemo01 {
    public static void main(String[] args) throws InterruptedException{
        Cat cat = new Cat();

        cat.start();

        System.out.println("主线程继续执行" + Thread.currentThread().getName());

        //可以观察到主线程和cat线程交替执行
        for (int i = 0; i < 60; i++) {
            System.out.println("主线程i = " + i);
            Thread.sleep(1000);
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1765283848038-ce4d1d1a-939d-4bf7-8279-5f38ae1b55e4.png)

3. 关键机制解析
+ **start() vs run()**:
    - `run()`: 只是一个普通的方法调用。如果在 `main` 中直接调用 `cat.run()`，会在 `main` 线程中执行，会导致主线程阻塞，直到 `run` 执行完毕。
    - `start()`: 真正启动线程的方法。它会调用 JVM 的本地方法 `start0()`。
+ **start0()**:
+ `public synchronized void start()` 内部调用了 `private native void start0();`
    - `start0()` 是本地方法（Native Method），由 C/C++ 实现，用于请求操作系统创建新的系统线程，并最终调用 `run()` 方法。
    - **注意**: 调用 `start()` 后，线程并不一定会立马执行，只是变成了**可运行状态 (Runnable)**，具体什么时候执行由 CPU 调度器决定。
+ ![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1765284024241-1ef8f1b3-54dc-4efa-a86a-fcb82dccf28c.png)

### 实现Runnable接口
1. **为什么需要这种方式**
+ Java 是**单继承**的。如果一个类已经继承了其他父类（例如 `class Dog extends Animal`），就无法再继承 `Thread` 类。此时必须使用 `Runnable` 接口。
2. **基本步骤**
    1. 定义一个类实现 `Runnable` 接口。
    2. 重写 `run()` 方法。
    3. 创建该类对象。
    4. **创建 **`**Thread**`** 对象**，将实现类对象作为构造参数传递进去（代理模式）。
    5. 调用 `Thread` 对象的 `start()` 方法。
3. 应用案例
+ <font style="color:rgb(31, 35, 40);">请编写程序,该程序可以每隔1秒。在控制台输出“hi!”,当输出10次后，自动退出。请使用实现Runnable接口的方式实现。</font>

```java
package com.aurora.MultiThread.ThreadBaseUse;

public class Animal {
}
```

```java
package com.aurora.MultiThread.ThreadBaseUse;

public class Dog extends Animal implements Runnable{
    int times = 0;
    @Override
    public void run() {
        while (true) {
            System.out.println("hi!");
            times++;
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            if (times == 10) {
                break;
            }
        }
    }
}
```

```java
package com.aurora.MultiThread.ThreadBaseUse;

public class ThreadDemo02 {
    public static void main(String[] args) {
        Dog dog = new Dog();
        // dog.start(); // ❌错误，Runnable 接口没有 start 方法

        // 创建 Thread 对象，把 dog 对象(实现 Runnable)放入 Thread
        // 这里使用了设计模式 [代理模式]
        Thread thread = new Thread(dog);
        thread.start();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1765284526065-99d13efb-7c05-4b2d-8d68-0c68031d001c.png)

4. 原理
+ `Thread` 类本身也实现了 `Runnable` 接口。当我们 `new Thread(dog)` 时，是将 `dog` 对象赋给了 `Thread` 内部的 `target` 属性。
+ **极简模拟代码 (理解用):**

```java
class ThreadProxy implements Runnable { 
    private Runnable target = null; // 属性，类型是 Runnable

    public ThreadProxy(Runnable target) {
        this.target = target;
    }

    @Override
    public void run() {
        if (target != null) {
            target.run(); // 动态绑定，执行传入对象的 run 方法
        }
    }

    public void start() {
        start0(); // 真正开启线程的方法
    }
    
    public void start0() {
        run(); // 最终调用 run
    }
}
```

### 线程使用应用案例_多线程执行
<font style="color:rgb(31, 35, 40);">请编写一个程序,创建两个线程,一个线程每隔1秒输出“hello,world”,输出10次，退出, 一个线程每隔1秒输出“hi”，输出5次退出。</font>

```java
package com.aurora.MultiThread.ThreadBaseUse;

public class PrintHello implements Runnable {
    int times = 0;
    @Override
    public void run() {
        while (times < 10) {
            System.out.println("Hello World");
            times++;
            try {
                Thread.sleep(1000);
            }  catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```java
package com.aurora.MultiThread.ThreadBaseUse;

public class PrintHi implements Runnable {
    int times = 0;
    @Override
    public void run() {
        while (times < 5) {
            System.out.println("hi");
            times++;
            try {
                Thread.sleep(1000);
            }  catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```java
package com.aurora.MultiThread.ThreadBaseUse;

public class ThreadDemo03 {
    public static void main(String[] args) {
        PrintHello hello = new PrintHello();
        PrintHi hi = new PrintHi();

        Thread t1 = new Thread(hello);
        Thread t2 = new Thread(hi);
        t1.start();
        t2.start();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1765284986503-807d1879-9e00-45ed-a89d-2b3ae5fd32e5.png)

### 线程如何理解
![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1765285615017-4404858e-bf3e-46c1-abf7-31eb13673949.png)

### 继承Thread和实现Runnable的区别
从 Java 的设计来看，通过继承 `Thread` 或者实现 `Runnable` 接口来创建线程本质上没有区别，从 JDK 帮助文档我们可以看到 `Thread` 类本身就实现了 `Runnable` 接口。

1. **主要区别与建议：**
+ **单继承限制**：
    - 继承 `Thread`：Java 是单继承的，如果类已经继承了其他父类，就不能再继承 `Thread`。
    - 实现 `Runnable`：接口可以多实现，**避免了单继承的限制**。
+ **资源共享**：
    - 实现 `Runnable` 接口方式更加适合**多个线程共享一个资源**的情况（只需创建一个实现类实例，放入多个 `Thread` 中）。
+ **结论**：建议优先使用 **实现 Runnable 接口** 的方式。
2. <font style="color:rgb(31, 35, 40);">[售票系统]，编程模拟三个售票窗口售票100,分别使用继承 Thread和实现 Runnable方式,并分析有什么问题? 均会出现超卖的问题。</font>
+ 继承Thread方式

```java
package com.aurora.MultiThread.ThreadBaseUse;

public class SellTicket01 extends Thread {
    // 使用 Thread 方式，票数必须是 static 才能共享
    private static int ticketNum = 100;

    @Override
    public void run() {
        while (true) {
            if (ticketNum <= 0) {
                System.out.println("售票结束...");
                break;
            }

            //休眠50毫秒，模拟延迟
            try {
                Thread.sleep(50);
            }  catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println("窗口" + Thread.currentThread().getName() + "售出一张票, 剩余票数" + (--ticketNum));
        }
    }
}
```

+ 实现Runnable接口方式

```java
package com.aurora.MultiThread.ThreadBaseUse;

public class SellTicket02 implements Runnable {
    // 这里不需要 static，因为我们只 new 了一个 SellTicket02 对象
    private int ticketNum = 100;

    @Override
    public void run() {
        while (true) {
            if (ticketNum <= 0) {
                System.out.println("售票结束...");
                break;
            }

            try {
                Thread.sleep(50);
            }  catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println("窗口" + Thread.currentThread().getName() + "售出一张票, 剩余票数" + (--ticketNum));
        }
    }
}
```

```java
package com.aurora.MultiThread.ThreadBaseUse;

public class SellTicketTest {
    public static void main(String[] args) {
//        System.out.println("=========继承Thread方式========");
//        SellTicket01 sellTicket01_1 = new SellTicket01();
//        SellTicket01 sellTicket01_2 = new SellTicket01();
//        SellTicket01 sellTicket01_3 = new SellTicket01();
//
//        sellTicket01_1.start();
//        sellTicket01_2.start();
//        sellTicket01_3.start();

        // 启动三个线程，代理同一个 Runnable 对象
        System.out.println("========实现Runnable接口方式========");
        SellTicket02 sellTicket02 = new SellTicket02();
        new Thread(sellTicket02).start();
        new Thread(sellTicket02).start();
        new Thread(sellTicket02).start();
    }
}
```

+ 继承Thread方式的结果

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1765286947823-1864ec07-cd02-4a06-9d6d-f69314a8487a.png)

+ 实现Runnable接口方式的结果

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1765286872330-74119964-ea3e-447a-9912-eb99ee9de6d3.png)

3. **问题分析****（超卖问题）**： 运行上述代码（无论是方式一还是方式二），你很可能会发现输出中出现 `剩余票数=-1` 或 `剩余票数=-2` 的情况。
+ **原因**：多线程并发访问临界资源（`ticketNum`）且没有加锁。当票数只剩 1 张时，线程 A 进入 `if(ticketNum <= 0)` 判断为 false，准备售票但还没减；此时线程 B 也进入判断，同样通过。结果两个线程都执行了 `--ticketNum`，导致票数变为负数。
+ **解决**：这涉及到**线程同步 (Synchronization)**，后续会详细讲解。

## 线程终止
### 基本说明
线程的停止通常有两种情况：

1. **自动退出**：当线程的 `run` 方法中的代码执行完毕（任务完成），线程会自动结束。
2. **手动控制（通知方式）**：通过使用变量（标志位）来控制 `run` 方法的循环条件，从而让线程在指定时刻退出。

### 使用通知方式停止线程
这是 Java 中推荐的安全停止线程的方式。

+ **原理**：在线程类中定义一个 `boolean` 类型的控制变量（例如 `loop`）。
+ **机制**：
    - 线程的 `run` 方法通过 `while(loop)` 循环执行任务。
    - 外部线程（如 `main` 线程）通过调用 `setLoop(false)` 修改该变量。
    - 子线程检测到 `loop` 变为 `false`，跳出循环，结束 `run` 方法，从而终止线程。

### 应用案例
```java
package com.aurora.MultiThread.ThreadBaseUse;

public class T extends Thread{
    private int count = 0;
    //设置一个控制变量
    private boolean loop = true;

    @Override
    public void run() {
        while (loop) {
            try {
                Thread.sleep(50);
            }  catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println("T运行中..." + (++count));
        }

        System.out.println("T线程运行结束");
    }

    //提供公共方法修改控制变量
    public void setLoop(boolean loop) {
        this.loop = loop;
    }
}
```

```java
package com.aurora.MultiThread.ThreadBaseUse;

public class ThreadExitDemo {
    public static void main(String[] args) throws InterruptedException {
        // 1. 创建并启动子线程
        T t1 = new T();
        t1.start();

        Thread.sleep(10 * 1000);

        // 2. 主线程处理业务（模拟休眠）
        System.out.println("main线程休眠10s...");
        t1.setLoop(false);
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1765519293062-a5dfbed3-e938-4066-9176-0ad122ac1ef5.png)

**执行流程解析:**

1. `t1.start()` 启动子线程，进入 `while(loop)` 循环，不断打印 "T 运行中..."。
2. `main` 线程休眠 10 秒，此时 `t1` 与 `main` 并行运行。
3. 10 秒后，`main` 线程醒来，执行 `t1.setLoop(false)`。
4. `t1` 线程在下一次判断 `while(loop)` 时，发现条件为假。
5. `t1` 退出 `while` 循环，执行后续代码（如果有），最终退出 `run` 方法，线程生命周期结束。

## 线程常用方法
### 基础常用方法
1. **方法列表**

| 方法名 | 功能说明 |
| --- | --- |
| `**setName(String name)**` | 设置线程名称，使之与参数 name 相同。 |
| `**getName()**` | 返回该线程的名称。 |
| `**start()**` | 使该线程开始执行；Java 虚拟机底层调用该线程的 `start0` 方法。 |
| `**run()**` | 调用线程对象 `run` 方法。 |
| `**setPriority(int newPriority)**` | 更改线程的优先级。Java中线程优先级分为 1-10 级。 |
| `**getPriority()**` | 获取线程的优先级。 |
| `**sleep(long millis)**` | (静态方法) 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）。 |
| `**interrupt()**` | 中断线程。但并没有真正的结束线程，一般用于中断正在休眠的线程。 |


2. **注意事项和细节**
+ `**start()**`** vs **`**run()**`：
    - `start()` 底层会创建新的系统线程，并调用 `run()`。
    - 直接调用 `run()` 只是一个普通的方法调用，**不会**启动新线程。
+ **线程优先级**：
    - `Thread.MIN_PRIORITY` (1)
    - `Thread.NORM_PRIORITY` (5) - 默认
    - `Thread.MAX_PRIORITY` (10)
+ `**interrupt()**`** 机制**：
    - 它不是强制终止线程（区别于 `stop`）。
    - 如果线程正在 `sleep`，调用 `interrupt` 会导致线程抛出 `InterruptedException`，从而提前结束休眠，进入 `catch` 块。
3. 代码示例

```java
package com.aurora.MultiThread.ThreadMethod;

public class T extends Thread {

    @Override
    public void run() {
        while (true) {
            for (int i = 0; i < 100; i++) {
                System.out.println(Thread.currentThread().getName() + ":" + i);
            }

            try {
                System.out.println(Thread.currentThread().getName() + "休眠中...");
                // 模拟长时间休眠 20秒
                Thread.sleep(20000);
            }  catch (InterruptedException e) {
                // 当该线程执行到一个 interrupt 方法时，就会 catch 一个异常
                // 这相当于捕获了一个中断信号，可以在这里处理中断后的业务逻辑
                System.out.println(Thread.currentThread().getName() + "被interrupt了");
            }
        }
    }
}
```

```java
package com.aurora.MultiThread.ThreadMethod;

public class ThreadMethod01 {
    public static void main(String[] args) throws InterruptedException {
        //创建子线程
        T t = new T();

        //测试方法
        t.setName("aurora");    //设置名称
        t.setPriority(Thread.MIN_PRIORITY);     //设置优先级
        t.start();      //启动子线程

        // 主线程逻辑
        for(int i = 0; i < 5; i++) {
            Thread.sleep(1000);
            System.out.println("hi " + i);
        }

        System.out.println(t.getName() + "线程的优先级 = " + t.getPriority());

        // 关键点：中断 t 线程的休眠
        // 执行此句后，t 线程的 sleep 会抛出 InterruptedException
        t.interrupt();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1765529635105-bee583a7-ed6a-4da1-8704-d9d1a19b990d.png)

代码执行步骤：

+ **在主线程执行完打印5次**`**hi**`**之后，**`**aurora被interrupt了**`** (关键点)**
    - **对应代码**：
        * 主线程调用 `t.interrupt();`
        * 子线程 `catch (InterruptedException e)` 块中的输出语句。
    - **解释**：
        * 子线程原本计划睡 20 秒，但主线程在第 5 秒时调用了 `interrupt()`。
        * 这个操作像一盆冷水，**强制唤醒**了正在休眠的子线程。
        * 子线程抛出 `InterruptedException` 异常，睡眠被终止，代码直接跳转到 `catch` 块，打印了这句话。
+ `**aurora:0**`** ~ **`**aurora:2**`**...**
    - **对应代码**：`catch` 块结束后，`while(true)` 循环开始下一次迭代。
    - **解释**：异常被捕获处理后，线程并没有结束。因为它在一个死循环 `while(true)` 里，所以它擦干脸，又开始了新一轮的工作，再次从 0 开始打印数字。

### 线程控制方法
1. **方法说明**
+ `**yield()**`** (线程礼让)**：
    - **作用**：让出 CPU，让其他线程执行。
    - **特点**：礼让的时间不确定，取决于 CPU 调度。如果 CPU 资源充足，可能礼让失败，自己继续执行。
+ `**join()**`** (线程插队)**：
    - **作用**：插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务。
    - **场景**：主线程需要等待子线程执行完毕后才能继续执行（例如数据汇总）。
2. **应用案例**

<font style="color:rgb(31, 35, 40);">案例:main线程创建一个子线程，每隔1s输出hello,输出20次,主线程每隔1秒, 输出hi，输出20次。要求:两个线程同时执行，当主线程输出5次后，就让子线程运行完毕，主线程再继续。</font>

```java
package com.aurora.MultiThread.ThreadMethod;

public class T2 extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            try {
                Thread.sleep(1000);
            }  catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("子线程：hello..." + i);
        }
    }
}
```

```java
package com.aurora.MultiThread.ThreadMethod;

public class ThreadMethod02 {
    public static void main(String[] args) throws InterruptedException {
        T2 t = new T2();
        t.start();

        for (int i = 0; i < 20; i++) {
            System.out.println("主线程:hi..." + i);
            Thread.sleep(1000);

            if (i == 5) {
                // --- 关键代码 ---

                // 方式 1: join (插队/等待)
                 t.join();
                // 效果：main 线程阻塞，直到 t2 执行完毕，main 才会继续执行第 6 次。
                // 符合题目"让子线程运行完毕"的要求。

                // 方式 2: yield (礼让)
//                Thread.yield();
                // 效果：main 线程暂停一下，让出 CPU。
                // 但如果 CPU 资源不紧张，main 可能立刻又抢到了资源，礼让不一定成功。
            }
        }
    }
}
```

+ 使用`t.join()`时的结果

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1765531201739-83518f69-1772-4d23-a764-0c51f3736241.png)

+ 使用`Thread.yield()`时的结果

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1765531960500-38ff71d2-1ed1-4ee1-a2ef-5efe48514f9e.png)

3. **区别总结**

| 特性 | `yield()` (礼让) | `join()` (插队) |
| --- | --- | --- |
| **行为** | 暂停当前线程，让出 CPU 时间片，重新竞争。 | 暂停当前线程，**直到**目标线程执行完毕。 |
| **结果** | **不一定成功**。取决于 CPU 调度和资源情况。例如**CPU 资源充足时**：在多核 CPU 上，主线程和子线程可能本来就在不同的核心上并行跑，礼让的意义可能不明显。   | **一定成功**。当前线程会被阻塞 (Blocked/Waiting)。 |
| **底层状态** | Running -> Runnable (就绪) | Running -> Blocked/Waiting (阻塞) |


### 练习
1. <font style="color:rgb(31, 35, 40);">主线程每隔1s，输出hi,一共10次</font>
2. <font style="color:rgb(31, 35, 40);">当输出到hi5时，启动一个子线程(要求实现Runnable)，每隔1s输出hello,等该线程输出10次 hello后，退出</font>
3. <font style="color:rgb(31, 35, 40);">主线程继续输出hi，直到主线程退出.</font>
4. <font style="color:rgb(31, 35, 40);">如图,完成代码其实线程插队</font>

```java
package com.aurora.MultiThread.ThreadMethod;

public class T3 implements Runnable{
    private int count = 0;
    @Override
    public void run() {
        while (true) {
            try {
                Thread.sleep(1000);
            }  catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("子线程hello..." + (++count));

            if (count == 10) {
                break;
            }
        }
    }
}
```

```java
package com.aurora.MultiThread.ThreadMethod;

public class ThreadMethodPractice {
    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(new T3());

        for (int i = 1; i <= 10; i++) {
            System.out.println("主线程hi..." + i);
            Thread.sleep(1000);

            if (i == 5) {
                t.start();
                t.join();
            }
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1765532678452-57435195-b535-4cda-8124-2dc81f1b7c37.png)

## 用户线程和守护线程
1. **基本概念**
+ **用户线程 (User Thread)**：也叫工作线程。当线程的任务执行完或以通知方式结束时，线程生命周期结束。我们平时创建的普通线程默认都是用户线程。
+ **守护线程 (Daemon Thread)**：一般是为工作线程服务的。**当所有的用户线程结束，守护线程会自动结束**，即使它还在执行任务。
+ **常见例子**：Java 的垃圾回收机制 (Garbage Collection) 就是典型的守护线程。
2. **应用案例：设置守护线程**

**需求**：

+ Main 线程（用户线程）循环 10 次后结束。
+ 子线程（无限循环）默认是用户线程，如果不处理，Main 结束了它还会一直跑。
+ **目标**：希望当 Main 线程结束后，子线程也能自动结束。

**实现方法**：在调用 `start()` 方法之前，调用 `setDaemon(true)`，将子线程设置成守护线程。

```java
package com.aurora.MultiThread.DaemonThread;

public class MyDaemonThread extends Thread{
    @Override
    public void run() {
        while (true){	// 无限循环
            try {
                Thread.sleep(1000);
            }  catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println("守护线程");
        }
    }
}
```

```java
package com.aurora.MultiThread.DaemonThread;

public class DaemonThreadDemo {
    public static void main(String[] args) throws InterruptedException {
        MyDaemonThread myDaemonThread = new MyDaemonThread();
        // 关键点：如果我们希望当 main 线程结束后，子线程自动结束
        // 只需将子线程设为守护线程即可
        // 注意：必须在 start() 之前设置，否则会抛出异常
        myDaemonThread.setDaemon(true);
        myDaemonThread.start();

        for (int i = 0; i < 10; i++) {
            System.out.println("主线程");
            Thread.sleep(1000);
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1765534328939-4c17cc98-1d23-4400-a036-867da1fa6891.png)

# 线程的生命周期
## 线程的六种状态
| 状态名称 | 说明 |
| --- | --- |
| **NEW** | **初始状态**。线程被构建，但还没有调用 `start()` 方法。 |
| **RUNNABLE** | **运行状态**。Java 线程将操作系统中的 **就绪 (Ready)** 和 **运行 (Running)** 两种状态笼统地称为 "RUNNABLE"。处于此状态的线程可能正在 CPU 上运行，也可能正在等待 CPU 调度。 |
| **BLOCKED** | **阻塞状态**。线程正在等待获取监视器锁 (Monitor Lock)。通常发生在进入 `synchronized` 代码块/方法时被阻塞。 |
| **WAITING** | **等待状态**。线程正在等待另一个线程执行特定动作。需要被显式唤醒 (notify/notifyAll)。<br/>触发方式：`Object.wait()`, `Thread.join()`, `LockSupport.park()`。 |
| **TIMED_WAITING** | **超时等待状态**。正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。和 WAITING 类似，但可以在指定的时间后自动自行返回。<br/>触发方式：`Thread.sleep(long)`, `Object.wait(long)`, `Thread.join(long)`, `LockSupport.parkNanos()`, `LockSupport.parkUntil()`。 |
| **TERMINATED** | **终止状态**。线程执行完毕或因异常退出。 |


## 线程状态转换图
![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1765536271893-701b31c1-e10b-40fc-b5cc-d526ebaa86b6.png)

# Synchronized
## 线程同步机制
1. <font style="color:rgb(31, 35, 40);">在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何同一时刻，最多有一个线程访问，以保证数据的完整性。</font>
2. <font style="color:rgb(31, 35, 40);">也可以这里理解：</font>**<font style="color:rgb(31, 35, 40);">线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作。</font>**

## 互斥锁
Java 语言引入了**对象互斥锁**的概念，来保证共享数据操作的完整性。

+ **互斥锁 (Mutex Lock)**：每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，**只能有一个线程访问该对象**。
+ **关键字联系**：`synchronized` 关键字与对象的互斥锁联系。当某个对象用 `synchronized` 修饰时，表明该对象在任一时刻只能由一个线程访问。
+ **局限性**：同步会导致程序的执行效率降低（因为需要等待锁的释放）。

## Synchronized的具体用法
`synchronized` 是 Java 语言内置的关键字，用于实现同步。

### 同步代码块
1. 这是粒度更细的控制方式，只锁定需要同步的那部分代码，效率通常较高。
2. **语法：**

```java
synchronized (锁对象) {	// 得到对象的锁，才能操作同步代码
    // 需要被同步的代码 (临界区)
}
```

+ **锁对象**：可以是任意对象（Object），但必须保证多个线程看到的是**同一个**对象。
    - `this`：代表当前实例对象。
        * 同步方法如果没有使用 `static` 修饰：默认锁对象为 `**this**`。
    - `Object lock = new Object()`：专门创建的一个用于锁定的对象。
    - `类名.class`：代表该类的字节码对象（全局锁）。例如在对静态方法中的代码块加锁时，需要锁住类对象，即`synchronized (类名.class)`。
        * 如果方法使用 `static` 修饰：默认锁对象为 **当前类.class**。
3. **示例：模拟卖票**

```java
package com.aurora.MultiThread.SynchronizedDemo;

public class TicketWindowBlock implements Runnable{
    private int tickets = 100;  //共享资源
    private final Object lock = new Object();   //显示锁对象

    @Override
    public void run() {
        while (true) {
            // --- 同步代码块 ---
            // 只有拿到 lock 锁的线程才能进入
            synchronized (lock) {
                if (tickets > 0) {
                    //模拟延迟
                    try {
                        Thread.sleep(10);
                    }  catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                    System.out.println(Thread.currentThread().getName() + "卖出了一张票，剩余" + (--tickets));
                } else {
                    System.out.println("票卖完了");
                    break;
                }
            }
            // --- 同步结束，锁释放 ---

            //休眠几毫秒。防止释放锁的同时又得到锁，即让出CPU给其他线程
            try {
                Thread.sleep(5);
            }  catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```java
package com.aurora.MultiThread.SynchronizedDemo;

public class TicketWindowBlockTest {
    public static void main(String[] args) {
        TicketWindowBlock ticketWindowBlock = new TicketWindowBlock();
        Thread t1 = new Thread(ticketWindowBlock);
        Thread t2 = new Thread(ticketWindowBlock);
        Thread t3 = new Thread(ticketWindowBlock);

        t1.start();
        t2.start();
        t3.start();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1765685569175-455cfd50-0a44-4d52-a4c2-7a496b5a717b.png)

+ **不会出现余票为负数的情况**

### 同步方法
1. 将关键字直接加在方法声明上，表示整个方法体都是互斥的。
2. 语法

```java
public synchronized void method() {
    // 整个方法的代码都被同步
}
```

3. 示例

```java
package com.aurora.MultiThread.SynchronizedDemo;

public class TicketWindowMethod implements Runnable {

    private int tickets = 100;

    @Override
    public void run() {
        while (true) {
            if (!sellOneTicket()) {     //sellOneTicket函数返回值为false，即余票为0，不再售票
                System.out.println("票已售完！");
                break;
            }

            try {
                Thread.sleep(5);
            }  catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    // --- 同步方法 ---
    // 锁对象默认为 this (即当前的 TicketWindowMethod 实例对象)
    private synchronized boolean sellOneTicket() {
        if (tickets > 0) {
            try {
                Thread.sleep(10);
            }  catch (InterruptedException e) {
                e.printStackTrace();
            }

            System.out.println(Thread.currentThread().getName() + "卖出了一张票，剩余票数：" + (--tickets));
            return true;
        }

        return false;   //无票可卖
    }
}
```

```java
package com.aurora.MultiThread.SynchronizedDemo;

public class TicketWindowMethodTest {
    public static void main(String[] args) {
        TicketWindowMethod ticketWindowMethod = new TicketWindowMethod();

        // 关键点：三个线程必须共用同一个 task 对象
        // 这样 synchronized 方法锁住的 this 才是同一个对象
        Thread t1 = new Thread(ticketWindowMethod);
        Thread t2 = new Thread(ticketWindowMethod);
        Thread t3 = new Thread(ticketWindowMethod);

        t1.start();
        t2.start();
        t3.start();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1765686384693-2cc4e4c0-e3a0-4d58-a76d-e2cdc0033a6a.png)

+ **同样不会出现余票为负数的情况**

## 注意事项
1. `**implements Runnable**`**还是**`**extends**`
+  **如果实现 **`**Runnable**`** (推荐 ）**：
    - **场景**：通常只创建一个 `Runnable` 实例（`Task`），然后把它传给多个 `Thread` 对象。
    - **锁状态**：多个线程共享同一个 `Runnable` 对象。
    - **结果**：使用 `synchronized(this)` 或者普通同步方法时，锁住的是同一个 `Task` 对象，**能成功同步**。
+  **如果继承 **`**Thread**`**：**
    - **场景**：需要创建多个线程类的实例来启动（例如 `new MyThread().start();``new MyThread().start();`）。
    - **锁状态：**每个线程本身就是一个独立的对象实例。
    - **陷阱：**如果在 `run()` 方法中写了 `synchronized(this)`，每个线程锁住的是自己（Thread A 锁 A，Thread B 锁 B）。大家各锁各的，互不干扰，无法实现同步。
    - **解决方法：使用静态同步方法** 使用 `static synchronized` 修饰方法。这样锁对象就变成了**类对象**（`ClassName.class`），而类对象在内存中是唯一的。
2. **锁对象选择**：
    - 同步方法如果没有使用 `static` 修饰：默认锁对象为 `**this**`。
    - 如果方法使用 `static` 修饰：默认锁对象为 **当前类.class**。
3. **落地步骤**：
    - 先分析需要上锁的代码（临界区）。
    - 选择同步代码块或同步方法（**原则：同步的范围越小，效率越高**）。
    - **核心要求**：多个线程的锁对象必须是**同一个**！
4. **效率权衡**：
    - 虽然同步保证了安全，但降低了并发效率，因此只在操作共享数据的关键代码段使用同步。

# 线程的死锁
1. **基本介绍**：多个线程都占用了对方的锁资源，但不肯相让，导致了死锁。在编程是一定要避免死锁的发生。
2. 示例

```java
package com.aurora.MultiThread.SynchronizedDemo;

public class DeadLock extends Thread{

    // 关键点：使用 static 保证 o1, o2 是所有实例共享的，只有这样才会发生竞争
    static final Object lock1 = new Object();
    static final Object lock2 = new Object();
    boolean flag;

    public DeadLock(boolean flag) {
        this.flag = flag;
    }

    @Override
    public void run() {
        // 业务逻辑分析：
        // 1. 如果 flag 为 T (线程A)：先持有 o1 锁 -> 尝试获取 o2 锁
        // 2. 如果 flag 为 F (线程B)：先持有 o2 锁 -> 尝试获取 o1 锁
        if (flag) {
            synchronized (lock1) {  // 1. A 拿到 o1
                System.out.println(Thread.currentThread().getName() + "进入1");

                // 此时如果 B 已经拿到了 o2，A 就会在这里卡住等待 o2
                synchronized (lock2) {
                    System.out.println(Thread.currentThread().getName() + "进入2");
                }
            }

        } else {
            synchronized (lock2) {  // 1. B 拿到 o2
                System.out.println(Thread.currentThread().getName() + "进入3");

                // 此时如果 A 已经拿到了 o1，B 就会在这里卡住等待 o1
                synchronized (lock1) {
                    System.out.println(Thread.currentThread().getName() + "进入4");
                }
            }
        }
    }
}
```

```java
package com.aurora.MultiThread.SynchronizedDemo;

public class DeadLockTest {
    public static void main(String[] args) {
        DeadLock A = new DeadLock(true);
        A.setName("线程A");
        DeadLock B = new DeadLock(false);
        B.setName("线程B");

        A.start();
        B.start();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1765696094155-aae9451e-e562-426b-9073-2f6be8d07567.png)

+ 程序卡在这里无法继续推进，发生了死锁
3. 注意
+ 同步代码块是嵌套的，即

```java
synchronized (lock1) {  // 1. A 拿到 o1
    System.out.println(Thread.currentThread().getName() + "进入1");

    // 此时如果 B 已经拿到了 o2，A 就会在这里卡住等待 o2
    synchronized (lock2) {
        System.out.println(Thread.currentThread().getName() + "进入2");
    }
}
```

+ 如果不是嵌套的（以下情况），就破坏了死锁的保持并请求条件，不会发生死锁

```java
synchronized (lock1) {  // 1. A 拿到 o1
                System.out.println(Thread.currentThread().getName() + "进入1");
}
// 此时如果 B 已经拿到了 o2，A 就会在这里卡住等待 o2
synchronized (lock2) {
    System.out.println(Thread.currentThread().getName() + "进入2");
}
```

4. **避免死锁：**
+ 避免嵌套同步。
+ 保证多个线程获取锁的顺序一致（例如，所有线程都必须先获取 o1，再获取 o2，就不会发生死锁）。

# 释放锁
1. **<font style="color:rgb(31, 35, 40);">下面操作会释放锁</font>**
+ <font style="color:rgb(31, 35, 40);">当前线程的同步方法、同步代码块执行结束。</font>
+ <font style="color:rgb(31, 35, 40);">当前线程在同步代码块、同步方法中遇到break、return。</font>
+ <font style="color:rgb(31, 35, 40);">当前线程在同步代码块、同步方法中出现了未处理的Error或Exception,导致异常结束。</font>
+ <font style="color:rgb(31, 35, 40);">当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。</font>
2. **<font style="color:rgb(31, 35, 40);">下面操作不会释放锁</font>**
+ <font style="color:rgb(31, 35, 40);">线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行,不会释放锁</font>
+ <font style="color:rgb(31, 35, 40);">线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁。提示:应尽量避免使用suspend()和resume()来控制线程，方法不再推荐使用</font>

# 练习
## 练习1
需求：

+ <font style="color:rgb(31, 35, 40);">在main方法中启动两个线程</font>
+ <font style="color:rgb(31, 35, 40);">第1个线程循环随机打印100以内的整数</font>
+ <font style="color:rgb(31, 35, 40);">直到第2个线程从键盘读取了“Q”命令。</font>

```java
package com.aurora.MultiThread.Practice;

import java.util.Random;

public class A extends Thread {

    private boolean loop = true;

    public void setLoop(boolean loop) {
        this.loop = loop;
    }

    @Override
    public void run() {
        Random random = new Random();
        while (loop) {
            System.out.println(random.nextInt(100));

            //休眠
            try {
                Thread.sleep(1000);
            }  catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("A线程退出");
    }
}
```

```java
package com.aurora.MultiThread.Practice;

import java.util.Scanner;

public class B extends Thread {
    private A a;
    private Scanner sc = new Scanner(System.in);

    public B(A a) {
        this.a = a;
    }
    @Override
    public void run() {

        while (true) {
            System.out.println("输入指令Q表示退出");
            char key = sc.next().toUpperCase().charAt(0);
            if (key == 'Q') {
                a.setLoop(false);
                System.out.println("B线程退出");
                break;
            }
        }
    }
}
```

```java
package com.aurora.MultiThread.Practice;

public class Practice1 {
    public static void main(String[] args) {
        A a =  new A();
        B b = new B(a);

        a.start();
        b.start();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1765699259819-60665515-24ab-4c0f-8dec-c45ce037eaec.png)

## 练习2
<font style="color:rgb(31, 35, 40);">需求：</font>

+ <font style="color:rgb(31, 35, 40);">有2个用户分别从同一个卡上取钱(总额:10000)</font>
+ <font style="color:rgb(31, 35, 40);">每次都取1000,当余额不足时,就不能取款了</font>
+ <font style="color:rgb(31, 35, 40);">不能出现超取现象=》线程同步问题.</font>

```java
package com.aurora.MultiThread.Practice;

public class DrawMoney implements Runnable {
    private int money = 10000;
    private final Object lock = new Object();

    @Override
    public void run() {
        while (true) {
            synchronized (lock) {
                if (money > 0) {
                    money -= 1000;
                    System.out.println(Thread.currentThread().getName() + "取出了1000元，余额：" + money);

                    try {
                        Thread.sleep(1000);
                    }  catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                } else {
                    System.out.println("钱被取完了");
                    break;
                }
            }
        }
    }
}
```

```java
package com.aurora.MultiThread.Practice;

public class Practice02 {
    public static void main(String[] args) {
        DrawMoney drawMoney = new DrawMoney();
        Thread t1 = new Thread(drawMoney);
        t1.setName("t1");
        Thread t2 = new Thread(drawMoney);
        t2.setName("t2");

        t1.start();
        t2.start();
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1765700306818-2f73b123-5a19-4af7-a410-c288c23fb683.png)

