# 集合的介绍
## 集合的理解和好处
1. 前面保存多个数据使用的都是数组，但是数组有一些不足，比如
+ <font style="color:rgb(31, 35, 40);">长度开始时必须指定，而且一旦指定，不能更改</font>
+ <font style="color:rgb(31, 35, 40);">保存的必须为同一类型的元素</font>
+ <font style="color:rgb(31, 35, 40);">使用数组进行增加/删除元素比较麻烦</font>
+ <font style="color:rgb(31, 35, 40);">eg：写出对Person数组进行扩容的代码</font>

```java
Person[] pers = new Person[1]; //大小是1
per[0] = new Person();  
//增加新的Person对象?
Person[] pers2 = new Person[pers.length+1];//新创建数组
for(){} //拷贝pers数组的元素到per2
pers2[pers2.length-1] = new Person()://添加新的对象
```

2. 集合的优点
+ <font style="color:rgb(31, 35, 40);">可以动态保存任意多个对象，使用比较方便</font>
+ <font style="color:rgb(31, 35, 40);">提供了一系列方便的操作对象的方法: add、remove、set、get 等</font>
+ <font style="color:rgb(31, 35, 40);">使用集合添加/删除新元素简洁明了</font>

## 集合的框架体系
1. Java的集合类很多，主要分为两大类，如图：

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763552506678-89691ba6-1f57-4ef0-a7d4-57ec70a451a9.png)

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763552524067-f74e909e-1c89-49bc-8d91-5ea30a9b76ee.png)

2. 集合主要分为两种（单列集合，双列集合）
+ 单列集合：`Collection`接口有两个重要的接口`List`和`Set`，他们都是单列集合（单列数据）
+ 双列集合：`Map`接口的实现子类是双列集合，存放的是`k-v`（双列数据）

```java
package com.aurora.set.collectionDemo;

import java.util.ArrayList;
import java.util.HashMap;

public class collectionDemo01 {
    @SuppressWarnings("all")
    public static void main(String[] args) {
        ArrayList arrayList = new ArrayList();
        arrayList.add("tom");
        arrayList.add("jack");

        HashMap hashMap = new HashMap();
        hashMap.put("NO1", "Beijing");
        hashMap.put("NO2", "Shanghai");
    }
}
```

# Collection接口和常用方法
## Collection接口实现类的特点
1. `Collection`接口继承自`Iterable`接口

```java
public interface Collection <E> extends lterable <E>
```

2. `Collection`接口实现类的特点
+ `<font style="color:rgb(31, 35, 40);">collection</font>`<font style="color:rgb(31, 35, 40);">实现子类可以存放多个元素，每个元素可以是</font>`<font style="color:rgb(31, 35, 40);">Object</font>`
+ <font style="color:rgb(31, 35, 40);">有些</font>`<font style="color:rgb(31, 35, 40);">Collection</font>`<font style="color:rgb(31, 35, 40);">的实现类,可以存放重复的元素,有些不可以</font>
+ <font style="color:rgb(31, 35, 40);">有些</font>`<font style="color:rgb(31, 35, 40);">Collection</font>`<font style="color:rgb(31, 35, 40);">的实现类是有序的(List)，有些不是有序(Set)</font>
+ `<font style="color:rgb(31, 35, 40);">Collection</font>`<font style="color:rgb(31, 35, 40);">接口没有直接的实现子类，是通过它的子接口 Set 和 List 来实现的</font>

## Collection接口常用方法
3. `Collection`的常用方法，这里以`ArrayList`实现类为例

```java
package com.aurora.set.collectionDemo;

import java.util.ArrayList;
import java.util.List;

public class collectionMethod {
    @SuppressWarnings("all")
    public static void main(String[] args) {
        List list = new ArrayList();    //多态写法

        //1.add添加单个元素,可以添加不同类型的
        list.add("jack");
        list.add(10);   //本质是list.add(new Integer(10))
        list.add(true);
        System.out.println("list: " + list);    //[jack, 10, true]

        //2.remove,删除元素
        list.remove(0); //按位置删
        list.remove(true);  //按内容删
        System.out.println("list: " + list);    //[10]

        //3.contains 查找元素是否存在
        System.out.println(list.contains("jack"));  //false

        //4.获取元素个数
        System.out.println(list.size());    //1

        //5.isEmpty 判断是否为空
        System.out.println(list.isEmpty()); //false

        //6.clear 清空
        list.clear();
        System.out.println("list: " + list);    //[]

        //7.addAll 添加多个元素
        ArrayList list2 = new ArrayList();
        list2.add("红楼梦");
        list2.add("三国演义");
        list.addAll(list2);
        System.out.println("list: " + list);    //[红楼梦, 三国演义]

        //8.containsAll 查找多个元素是否都存在
        System.out.println(list.containsAll(list2));    //true

        //9.removeAll 删除多个元素
        list.add("聊斋");
        list2.add("时间是金");
        System.out.println("list: " + list);    //[红楼梦, 三国演义, 聊斋]
        System.out.println("list2:" + list2);   //[红楼梦, 三国演义, 时间是金]
        list.removeAll(list2);
        System.out.println("list: " + list);    //[聊斋],只删除list中包含list2中的元素，list2中可以存在list中没有的元素
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763604679703-2ea72853-bad2-4096-ba4b-258b94fba11b.png)

## Collection接口遍历元素
### 遍历方式一：使用Iterator
1. `Iterator`介绍：
+ <font style="color:rgb(31, 35, 40);">Iterator对象称为迭代器，主要用于遍历Collection集合中的元素。</font>
+ <font style="color:rgb(31, 35, 40);">所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了lterator接口的对象,即可以返回一个迭代器。</font>
2. **使用Iterator迭代器遍历的基本流程**
    1. **获取迭代器：**使用`Collection实现类对象.iterator`，`col.iterator()` 会返回一个实现了 `Iterator` 接口的对象，这个对象可以用来访问集合中的数据。  
        1. 每次调用 `iterator()` 都会返回 **一个新的迭代器对象**
        2. 迭代器内部有一个游标（指针），初始状态指向第一个元素“前面”

```java
Iterator iterator = col.iterator();
```

    2. **使用**`**while**`**+**`**hasNext()**`**+**`**next()**`**遍历**

```java
while (iterator.hasNext()) {
    Object obj = iterator.next();
    System.out.println("obj=" + obj);
}
```

        1. `HasNext()`：判断迭代器后面是否还有元素，如果有，返回`true`，否则返回`false`
        2. `next()`：返回当前迭代器指向的元素，然后将迭代器指向下一个位置
3. 注意：
+ 遍历结束后，迭代器失效，因为当退出while循环后 , 这时iterator迭代器指向最后的元素，此时再使用`iterator.next()`就越界了，会报出`NoSuchElementException`
+ 因此要想再次遍历，需要重置迭代器`iterator = col.iterator();`
+ `Iterator`仅用于遍历集合，`Iterator`本身并不存放对象
4. 使用示例

```java
package com.aurora.set.collectionDemo;

public class Book {
    private String name;
    private String author;
    private double price;

    public Book(String name, String author, double price) {
        this.name = name;
        this.author = author;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    @Override
    public String toString() {
        return "Book{" +
                "name='" + name + '\'' +
                ", author='" + author + '\'' +
                ", price=" + price +
                '}';
    }
}
```

```java
package com.aurora.set.collectionDemo;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class CollectionIterator {
    public static void main(String[] args) {
        Collection col = new ArrayList();
        col.add(new Book("三国演义", "罗贯中", 10.1));
        col.add(new Book("小李飞刀", "古龙", 5.1));
        col.add(new Book("红楼梦", "曹雪芹", 34.6));

        //获得迭代器
        Iterator iterator = col.iterator();
        while (iterator.hasNext()) {
            Object obj = iterator.next();
            System.out.println("obj: " + obj);
        }

        //此时iterator失效
        //iterator.next();      //报错：NoSuchElementException

        //第二次遍历
        iterator = col.iterator();  //重置遍历器
        while (iterator.hasNext()) {
            Object obj = iterator.next();
            System.out.println("obj: " + obj);
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763607195518-f13dc2c2-6b4a-49f1-829a-110a80445eaa.png)

5. 快捷键
+ `itit`：快速生成iterator遍历集合的代码，`while...`
+ `ctrl + j`：显示所有快捷键的快捷键
6. 迭代器的`remove方法`
+  在遍历时不能直接使用集合的 `remove()` 方法，会导致并发修改异常`ConcurrentModificationException`
+ 正确做法是使用迭代器自己的删除方法：`iterator.remove();`

### 遍历方式二：for循环增强
1. 增强for循环
+ <font style="color:rgb(31, 35, 40);">增强for循环，可以代替iterator迭代器，特点：增强for就是简化版的iterator,本质一样。只能用于遍历集合或数组。</font>
+ <font style="color:rgb(31, 35, 40);">基本语法</font>

```java
for (元素类型 元素名:集合名或数组名){
    
}
```

2. 增强for循环遍历的示例

```java
package com.aurora.set.collectionDemo;

import java.util.ArrayList;
import java.util.Collection;

@SuppressWarnings("all")
public class Collection_for {
    public static void main(String[] args) {
        Collection col =  new ArrayList();
        col.add(new Book("三国演义", "罗贯中", 10.1));
        col.add(new Book("小李飞刀", "古龙", 5.1));
        col.add(new Book("红楼梦", "曹雪芹", 34.6));

        //使用增强for循环遍历
        for (Object o : col) {
            System.out.println(o);
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763635587032-6b2458ae-3013-463a-adc3-3056e2a09298.png)

3. 快捷方式：`I`->`enter`

# List接口及实现类
## List接口和常用方法
### List接口基本介绍
1. List接口是Collection接口的子接口
2. List的特性：
    1. **<font style="color:rgb(31, 35, 40);">元素有序</font>**<font style="color:rgb(31, 35, 40);">：L</font><font style="color:rgb(31, 35, 40);">ist集合类中元素有序，即添加顺序和取出顺序一致</font>
    2. **<font style="color:rgb(31, 35, 40);">元素可重复</font>**<font style="color:rgb(31, 35, 40);">： List 不会检查重复，所以相同内容的对象可以加入多个</font>
    3. **<font style="color:rgb(31, 35, 40);">支持索引访问（随机访问）</font>**<font style="color:rgb(31, 35, 40);">： List 中每个元素都有一个整数索引（index），从 0 开始。</font>

### List接口的常用方法
下面的这些方法是List独有的，set用不了

1. `void add(int index, Object ele)`： 在指定`index`位置插入`ele`元素（原位置及后面的元素会后移）。
2. `boolean addAll(int index, Collection eles)`： 从index位置开始（往里面加入元素的那个List的index），把另一个集合中的所有元素添加进来。
3. `Object get(int index)`：获取指定index的元素
4. `int indexOf(Object obj)`：返回元素首次出现的索引，如果不存在返回-1
5. `int lastIndexOf(Object obj)`：返回元素最后一次出现的位置
6. `Object remove(int index)`： 删除指定 index 的元素，并返回删除的内容。
7. `Object set(int index, Object ele)`： 把 index 位置的元素替换成 ele，并返回原来的值。
8. `List subList(int fromIndex, int toIndex)`： 返回 `[fromIndex, toIndex)` 范围的子列表（左闭右开）。

```java
package com.aurora.set.ListInterface;

import java.util.ArrayList;
import java.util.List;

public class ListMethod {
    @SuppressWarnings("all")
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add("张三丰");
        list.add("贾宝玉");
        System.out.println("list: " + list);    //list: [张三丰, 贾宝玉]

        //1.void add(int index, Object ele)
        list.add(1, "韩顺平");
        System.out.println("list: " + list);    //list: [张三丰, 韩顺平, 贾宝玉]

        //2.boolean addAll(int index, Collection eles)
        List list2 = new ArrayList();
        list2.add("tom");
        list2.add("jack");
        list.addAll(1, list2);
        System.out.println("list: " + list);    //list: [张三丰, tom, jack, 韩顺平, 贾宝玉]

        //3.Object get(int index)
        Object result = list.get(1);
        System.out.println("result: " + result);    //result: tom

        //4.int indexOf(Object obj)
        list.add("tom");
        System.out.println("list: " + list);    //list: [张三丰, tom, jack, 韩顺平, 贾宝玉, tom]
        System.out.println(list.indexOf("tom"));    //1

        //5.int lastIndexOf(Object obj)
        list.add("韩顺平");
        System.out.println("list: " + list);    //list: [张三丰, tom, jack, 韩顺平, 贾宝玉, tom, 韩顺平]
        System.out.println(list.lastIndexOf("韩顺平"));    //6

        //6.Object remove(int index)
        Object obj = list.remove(0);
        System.out.println("被删除的元素: " + obj);   //被删除的元素: 张三丰
        System.out.println("list: " + list);    //list: [tom, jack, 韩顺平, 贾宝玉, tom, 韩顺平]

        //7.Object set(int index, Object ele)
        list.set(1, "玛丽");
        System.out.println("list: " + list);    //list: [tom, 玛丽, 韩顺平, 贾宝玉, tom, 韩顺平]

        //8.List subList(int fromIndex, int toIndex)
        List returnList = list.subList(0, 2);
        System.out.println("list: " + returnList);  //list: [tom, 玛丽]
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763639311541-b84f2caf-baa0-4720-b6ad-66b835dd66fe.png)

### List接口练习
1. 需求：<font style="color:rgb(31, 35, 40);">添加10个以上的元素(比如String "hello")，在2号位插入一个元素"韩顺平教育”，获得第5个元素，删除第6个元素，修改第7个元素，在使用迭代器遍历集合，要求:使用List的实现类ArrayList完成。</font>
2. <font style="color:rgb(31, 35, 40);">实现</font>

```java
package com.aurora.set.ListInterface;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class ListPractice01 {
    @SuppressWarnings("all")
    public static void main(String[] args) {
        List list = new ArrayList();

        //添加10个以上的元素
        for (int i = 0; i < 12; i++) {
            list.add("hello" + i);
        }
        System.out.println("list: " + list);

        //在2号位插入元素java
        list.add(1, "java");
        System.out.println("list: " + list);

        //获得第5个元素
        Object obj = list.get(4);
        System.out.println("obj: " + obj);

        //删除第6个元素
        list.remove(5);
        System.out.println("list: " + list);

        //修改第7个元素
        list.set(6, "world");
        System.out.println("list: " + list);

        //使用迭代器遍历集合
        Iterator iterator = list.iterator();
        while (iterator.hasNext()) {
            Object object = iterator.next();
            System.out.println(object);
        }
    }
}
```

### List的三种遍历方式（ArrayList/LinkedList/Vector通用）
1. 方式一：使用`iterator`迭代器， 这是遍历所有 `Collection` 集合的**通用**和**标准**方式。  
2. 方式二：使用增强for循环， 可以用于所有实现了 `Iterable` 接口的类（包括所有 `Collection` 集合）。  
3. 方式三：普通for循环， 适用于所有**有索引**的集合或数组。由于 `List` 是有序的且支持索引访问，所以可以使用这种方式。  
4. 示例

```java
package com.aurora.set.ListInterface;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

public class ListFor {
    @SuppressWarnings("all")
    public static void main(String[] args) {
        //这里以LinkedList为例
        List list = new LinkedList();
        list.add("jack");
        list.add("tom");
        list.add("jerry");

        //1.迭代器
        System.out.println("=================迭代器=================");
        Iterator iterator = list.iterator();
        while (iterator.hasNext()) {
            Object object = iterator.next();
            System.out.println(object);
        }

        //2.增强for循环
        System.out.println("=================增强for循环=================");
        for (Object object : list) {
            System.out.println(object);
        }

        //3.普通for循环
        System.out.println("=================普通for循环=================");
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763712654279-6d1382c3-4d67-4100-a0ff-55f948b42e46.png)

### List实现类的练习2
![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763712732591-f62cffa4-19a7-4afd-bde2-a26082fdf76d.png)

```java
package com.aurora.set.ListInterface;

import java.util.ArrayList;
import java.util.List;

public class ListPractice02 {
    @SuppressWarnings("all")
    public static void main(String[] args) {
        //使用ArrayList实现
        List list = new ArrayList();

        //添加图书信息
        list.add(new Book("红楼梦", 100, "曹雪芹"));
        list.add(new Book("西游记", 10, "吴承恩"));
        list.add(new Book("水浒传", 19, "施耐庵"));
        list.add(new Book("三国演义", 80, "罗贯中"));

        //排序前
        System.out.println("=================排序前=================");
        for (Object object : list) {
            System.out.println(object);
        }

        //排序
        bubbleSort(list);

        //排序后
        System.out.println("=================排序后=====================");
        for (Object object : list) {
            System.out.println(object);
        }
    }

    //冒泡排序算法
    public static void bubbleSort(List list) {
        for (int i = 0; i < list.size() - 1; i++) {
            for (int j = 0; j < list.size() - 1 - i; j++) {
                //取出Book对象
                Book book1 = (Book) list.get(j);
                Book book2 = (Book) list.get(j + 1);
                if (book1.getPrice() > book2.getPrice()) {
                    list.set(j, book2);
                    list.set(j + 1, book1);
                }
            }
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763715133740-d2f73257-1900-45c1-b423-dc06c5369c38.png)

## ArrayList底层结构和源码分析
### ArrayList的底层存储机制
ArrayList的底层实际上是一个Object数组，源码如下：

```java
// 源码片段 (JDK 8)
transient Object[] elementData; // 存放元素的数组
private int size; // 实际包含的元素个数
```

所以：

1. ArrayList可以加入空值`null`，并且是多个，因为ArrayList底层由数组实现数据存储

### ArrayList的扩容机制
1. 使用无参构造器时`new ArrayList()`
+ 初始时 `elementData = {}`（一个空数组），容量就是 0。
+ **第一次 add() 时**，会扩容到 **默认容量 10**。
+ 后续扩容使用：新容量 = 旧容量 + (旧容量 >> 1)，即 **旧容量的 1.5 倍**。
+ 源码：

```java
private static final int DEFAULT_CAPACITY = 10;

// 第一次 add 时会使用 DEFAULT_CAPACITY
int newCapacity = oldCapacity + (oldCapacity >> 1);  // 1.5 倍
```

2. 使用有参构造器`new ArrayList(int initialCapacity)`
+ 初始容量就是你指定的 `initialCapacity`。
+ 后续第一次扩容依旧是 **1.5 倍扩容**。

### ArrayList的线程安全
 Vector 是线程安全的，但效率低；ArrayList 是线程不安全的，但效率高。  

+ **Vector 的做法**： 如果你看 `Vector` 的源码，会发现它的 `add`、`get` 等方法上都加了 `synchronized` 关键字。这就像进门要排队拿锁，保证了安全但牺牲了速度。
+ **ArrayList 的风险**： 在多线程环境下，两个线程同时对 `ArrayList` 进行 `add` 操作，可能会导致：
1. **数据覆盖**：两个线程抢占同一个数组索引。
2. **抛出异常**：在扩容过程中可能导致索引越界或 `ConcurrentModificationException`。

## Vector底层结构和源码剖析
### Vector类的基本介绍
1. Vector类的定义

```java
public class vector<E>extends AbstractList<E> 
implements List<E>，RandomAccess，cloneable，Serializable
```

2. Vector的底层也是一个对象数组：`protected Object[] elementData;`
3. Vector时线程同步的，即线程安全，因为它的关键方法（如 `add`, `get`, `size`）都加上了 `synchronized` 关键字。例如：

```java
synchronizedpublic synchronized E get(int index){
if (index >= elementCount)
	throw new ArraylndexOutOfBoundsException(index);
return elementData(index);
}
```

所以在开发中，需要线程同步安全时，考虑使用Vector

### Vector的扩容机制
1. 构造方式与ArrayList类似，无参构造`new Vector()`和有参构造`new Vector(initialCapacity)`

```java
//有参构造器
public Vector(int initialCapacity) {
    this(initialCapacity, 0);
}
```

第二个参数 `capacityIncrement` 是**容量增长步长**。

+ `capacityIncrement = 0` → 扩容 _2 倍_
+ `capacityIncrement > 0` → 每次增长固定量（冷门特性）
2. 扩容方式：这里与ArrayList不同，ArrayList默认是扩容1.5倍，而Vector扩容2倍

```java
 int newCapacity = oldCapacity + 
        ((capacityIncrement > 0) ? capacityIncrement : oldCapacity);
```

3. `add()`的实际执行逻辑
+ 检查容量
+ 扩容（若需要）
+ 添加元素

```java
package com.hspedu.list_;

import java.util.Vector;

@SuppressWarnings({"all"})
public class Vector_ {
    public static void main(String[] args) {
        //无参构造器
        //有参数的构造
        Vector vector = new Vector(8);
        for (int i = 0; i < 10; i++) {
            vector.add(i);
        }
        vector.add(100);
        System.out.println("vector=" + vector);
        //1. new Vector() 底层
        /*
            public Vector() {
                this(10);
            }
         补充：如果是  Vector vector = new Vector(8);
            走的方法:
            public Vector(int initialCapacity) {
                this(initialCapacity, 0);
            }
         2. vector.add(i)
         2.1  //下面这个方法就添加数据到vector集合
            public synchronized boolean add(E e) {
                modCount++;
                ensureCapacityHelper(elementCount + 1);
                elementData[elementCount++] = e;
                return true;
            }
          2.2  //确定是否需要扩容 条件 ： minCapacity - elementData.length>0
            private void ensureCapacityHelper(int minCapacity) {
                // overflow-conscious code
                if (minCapacity - elementData.length > 0)
                    grow(minCapacity);
            }
          2.3 //如果 需要的数组大小 不够用，就扩容 , 扩容的算法
              //newCapacity = oldCapacity + ((capacityIncrement > 0) ?
              //                             capacityIncrement : oldCapacity);
              //就是扩容两倍.
            private void grow(int minCapacity) {
                // overflow-conscious code
                int oldCapacity = elementData.length;
                int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
                                                 capacityIncrement : oldCapacity);
                if (newCapacity - minCapacity < 0)
                    newCapacity = minCapacity;
                if (newCapacity - MAX_ARRAY_SIZE > 0)
                    newCapacity = hugeCapacity(minCapacity);
                elementData = Arrays.copyOf(elementData, newCapacity);
            }
         */

    }
}
```

### Vector和ArrayList的比较
| **<font style="color:rgb(31, 31, 31);">特性</font>** | **<font style="color:rgb(31, 31, 31);">Vector</font>** | **<font style="color:rgb(31, 31, 31);">ArrayList</font>** |
| --- | --- | --- |
| **<font style="color:rgb(31, 31, 31);">线程安全</font>** | **<font style="color:rgb(31, 31, 31);">是</font>**<font style="color:rgb(31, 31, 31);"> (Synchronized)</font> | <font style="color:rgb(31, 31, 31);">否 (线程不安全)</font> |
| **<font style="color:rgb(31, 31, 31);">效率</font>** | <font style="color:rgb(31, 31, 31);">较低 (因为有锁的开销)</font> | <font style="color:rgb(31, 31, 31);">较高</font> |
| **<font style="color:rgb(31, 31, 31);">扩容倍数</font>** | <font style="color:rgb(31, 31, 31);">默认 </font>**<font style="color:rgb(31, 31, 31);">2 倍</font>** | <font style="color:rgb(31, 31, 31);">默认 </font>**<font style="color:rgb(31, 31, 31);">1.5 倍</font>** |
| **<font style="color:rgb(31, 31, 31);">出现版本</font>** | <font style="color:rgb(31, 31, 31);">JDK 1.0 (古老)</font> | <font style="color:rgb(31, 31, 31);">JDK 1.2</font> |
| **<font style="color:rgb(31, 31, 31);">推荐场景</font>** | <font style="color:rgb(31, 31, 31);">极少使用 (除非维护旧代码)</font> | <font style="color:rgb(31, 31, 31);">单线程或主要使用场景</font> |


## LinkedList
### LinkedList的全面说明
1. LinkedList底层实现了双向链表和双端队列特点
2. 可以添加任意元素，包括`null`，且元素可以重复
3. 线程不安全，没有实现同步

### LinkedList的底层操作机制
1. <font style="color:rgb(31, 35, 40);">LinkedList底层维护了一个双向链表.</font>
2. <font style="color:rgb(31, 35, 40);">LinkedList中维护了两个属性first和last分别指向首节点和尾节点</font>
3. <font style="color:rgb(31, 35, 40);">每个节点(Node对象)，里面又维护了prev、next、item三个属性，其中通过 prev指向前一个，通过next指向后一个节点。最终实现双向链表.</font>
4. <font style="color:rgb(31, 35, 40);">所以LinkedList的元素的添加和删除，不是通过数组完成的，相对来说效率较高。</font>
5. <font style="color:rgb(31, 35, 40);">模拟一个简单的双向链表</font>

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763783283942-34bbd6e9-9ffd-4a97-a748-536f3e476ee2.png)

```java
package com.aurora.set.ListInterface;

public class Node {
    public Object item;
    public Node next;
    public Node pre;

    public Node(Object item) {
        this.item = item;
    }

    @Override
    public String toString() {
        return "Node{" +
                "item=" + item +
                '}';
    }
}
```

```java
package com.aurora.set.ListInterface;

public class LinkedListSimulate {
    public static void main(String[] args) {
        Node jack = new Node("jack");
        Node tom = new Node("tom");
        Node jerry = new Node("jerry");

        //链接节点
        jack.next = tom;
        tom.next = jerry;
        jerry.pre = tom;
        tom.pre = jack;

        Node first = jack;  //头节点
        Node last = jerry;  //尾节点

        //从头到尾遍历
        System.out.println("==========从头到尾遍历========");
        Node node = first;
        while (node != null) {
            System.out.println(node);
            node = node.next;
        }

        //从尾到头遍历
        System.out.println("==========从尾到头遍历============");
        node = last;
        while (node != null) {
            System.out.println(node);
            node = node.pre;
        }

        //插入对象
        //在tom和jerry之间插入一个smith
        Node smith = new Node("smith");
        smith.next = jerry;
        smith.pre = tom;
        tom.next = smith;
        jerry.pre = smith;

        //再次从头到尾遍历
        System.out.println("==========再次从头到尾遍历========");
        node = first;
        while (node != null) {
            System.out.println(node);
            node = node.next;
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763784602558-68992dcb-688d-4bf9-b69b-9814dca6d962.png)

### LinkedList的增删查改与遍历
1. `add()`：增加元素
2. `remove(int index)`：删除`index`位置的元素
3. `get(int index)`：获取`index`位置的元素
4. `set(int index, E element)`：将`index`位置的元素修改为`element`
5. LinkedList的遍历：依旧是三种方式，迭代器、增强for循环、普通for循环
6. 示例

```java
package com.aurora.set.ListInterface;

/*
    LinkedList的增删查改（CRUD）
 */

import java.util.Iterator;
import java.util.LinkedList;

public class LinkedListCRUD {
    @SuppressWarnings("all")
    public static void main(String[] args) {
        LinkedList linkedList = new LinkedList();

        //增
        linkedList.add(1);
        linkedList.add(2);
        linkedList.add(3);
        linkedList.add(4);
        linkedList.add(5);
        System.out.println("linkedList: " + linkedList);

        //删
        linkedList.remove(2);   //如果不传入参数，默认删除的是首节点
        System.out.println("linkedList: " + linkedList);

        //查
        Object item = linkedList.get(1);
        System.out.println("item: " + item);

        //改
        linkedList.set(1, 999);
        System.out.println("linkedList: " + linkedList);

        //迭代器遍历
        System.out.println("=============迭代器遍历==============");
        Iterator iterator = linkedList.iterator();
        while (iterator.hasNext()) {
            Object next = iterator.next();
            System.out.println("next: " + next);
        }

        //增强for循环遍历
        System.out.println("=============增强for循环遍历==============");
        for (Object next : linkedList) {
            System.out.println("next: " + next);
        }

        //普通for循环遍历
        System.out.println("=============普通for循环遍历==============");
        for (int i = 0; i < linkedList.size(); i++) {
            Object next = linkedList.get(i);
            System.out.println("next: " + next);
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763790465180-80f24124-f232-4ae0-be1a-c4274c2c625c.png)

### LinkedList和ArrayList的比较
| 操作 | LinkedList 特点 | 对比 ArrayList |
| --- | --- | --- |
| **增 (Add)** | **快** (仅修改指针，不需要扩容或移动数据) | 慢 (可能需要扩容、移动数组) |
| **删 (Remove)** | **快** (仅修改指针) | 慢 (后续元素需整体前移) |
| **改 (Set)** | **慢** (需要先遍历找到节点) | 快 (数组下标直接定位) |
| **查 (Get)** | **慢** (需要遍历) | **快** (数组下标直接定位) |
| **底层结构** | 双向链表 | 可变数组 |


# Set接口及实现类
## Set接口和常用方法
### Set接口基本介绍
1. 无序：添加和取出的顺序不一致，没有索引
2. 不允许重复元素，所以最多包含一个`null`
3. JDK API中Set接口的实现类有：

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763797191898-3125476d-5e79-48d9-889e-34f957002726.png)

### Set接口的常用方法
和List接口一样，Set接口也是Collection的子接口，因此，常用方法与Collection接口一样，例如：`add()`、`remove()`、`contains()`、`addAll()`、`removeAll()`、`containsAll`、`size()`、`isEmpty()`、`clear()`

### Set接口的遍历方式
同Collection的遍历方式一样，因为Set接口是Collection接口的子接口。

+ 使用迭代器
+ 增强for循环

**注意**：不能使用索引的方式获取，因此也就不能使用普通for循环来遍历Set，普通for循环只适用于List，因为List有索引。

### Set接口的常用方法及遍历示例
这里以Set接口的实现类`HashSet`来讲解Set接口的常用方法及遍历方式。

```java
package com.aurora.set.SetInteface;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class SetMethod {
    @SuppressWarnings("all")
    public static void main(String[] args) {

        //以HashSet为例
        Set set = new HashSet();

        //添加元素
        set.add("john");
        set.add("lucy");
        set.add("jack");
        set.add("jerry");
        set.add("john");    //重复
        set.add(null);
        set.add(null);      //再次添加null

        System.out.println(set);    //[null, john, jerry, lucy, jack]，重复的john和null并没有添加进去，且无序

        //删除元素
        set.remove(null);
        System.out.println(set);    //[john, jerry, lucy, jack]

        //迭代器遍历
        System.out.println("===============迭代器遍历=========");
        Iterator iterator = set.iterator();
        while (iterator.hasNext()) {
            Object obj = iterator.next();
            System.out.println(obj);
        }

        //增强for循环遍历
        System.out.println("===============增强for循环遍历=========");
        for (Object o : set) {
            System.out.println(o);
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763798352578-7fba6840-a333-45ca-b7e0-d67e10e4c8ee.png)

## Set接口实现类-HashSet
### HashSet的介绍
1. HashSet实现了Set接口
2. HashSet实际上是HashMap，源码如下

```java
public HashSet() {
    map = new HashMap<>();
}
```

3. Set的通用属性
+ 可以存放null值，但是只能有一个null
+ 不能有重复元素/对象
+ 不保证元素是有序的，取决于Hash后，在确定索引的结果。即不保证存放元素的顺序和取出顺序一致
    - 当你调用 `add(元素)` 时，HashSet 并不是简单地把元素放在数组的 `index=0, 1, 2...` 位置，而是经过了一系列复杂的计算：
        * **计算 Hash 值**：调用元素的 `hashCode()` 方法，得到一个整数。
        * **计算索引 (Index)**：通过运算（通常是 `(n-1) & hash`）把这个整数映射到数组的下标范围内。

### HashSet使用示例
1. 执行add方法时，会返回一个boolean值，添加成功，返回 true, 否则返回false

```java
//Set接口中的add抽象方法
boolean add(E e);
```

2. 基本使用示例

```java
package com.aurora.set.SetInteface;

import java.util.HashSet;

public class HashSetDemo01 {
    @SuppressWarnings("all")
    public static void main(String[] args) {
        HashSet hashSet = new HashSet();

        //add
        System.out.println(hashSet.add("jack"));    //true
        System.out.println(hashSet.add("lucy"));    //true
        System.out.println(hashSet.add("john"));    //true
        System.out.println(hashSet.add("rose"));    //true
        System.out.println(hashSet.add("jack"));    //false，重复，不能再添加一次

        System.out.println(hashSet);    //[john, rose, lucy, jack]

        //remove
        hashSet.remove("lucy");
        System.out.println(hashSet);    //[john, rose, jack]


    }
}
```

3. 在HashSet中添加自定义对象

```java
package com.aurora.set.SetInteface;

public class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Dog{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

```java
package com.aurora.set.SetInteface;

import java.util.ArrayList;
import java.util.HashSet;

public class HashSetDemo02 {
    @SuppressWarnings("all")
    public static void main(String[] args) {
        HashSet hashSet = new HashSet();

        //添加Dog对象
        hashSet.add(new Person("tom"));
        hashSet.add(new Person("tom"));

        System.out.println(hashSet);    //[Dog{name='tom'}, Dog{name='tom'}]，两个tom都被加进去了

    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763800302935-d7040bfe-3331-41cd-84d5-836302923385.png)

+ **现象：**从以上结果可以看到，虽然两个`Person`对象的名字都是`"tom"`，但是都添加成功了
+ **原因：**
    - `Person`类没有重写`HashCode()`和`equals()`方法因此，它使用的是 `Object` 类的默认实现。
        * **默认 hashCode**：基于对象的**内存地址**计算。两个 `new` 出来的对象，内存地址肯定不同，所以哈希值不同。
        * **默认 equals**：比较的是 `==`（内存地址）。
+ **结论**：HashSet 觉得这是两个完全不同的人（虽然名字一样，但住在内存的不同房间），所以都放进去了。
4. 在HashSet中添加String对象

```java
package com.aurora.set.SetInteface;

import java.util.HashSet;

public class HashSetDemo03 {
    @SuppressWarnings("all")
    public static void main(String[] args) {
        HashSet hashSet = new HashSet();

        hashSet.add(new String("tom"));
        hashSet.add(new String("tom"));

        System.out.println(hashSet);    //[tom]，只添加进去1个
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763800804309-2f48fe0f-0853-4eaa-9f34-6cb647b0d901.png)

+ **现象**：这里用了 `new`，内存地址肯定不一样，为什么第二个加不进去了？
+ **原因**：**String 类太特殊了（它重写了方法）**。
    - 虽然是两个不同的对象（内存地址不同），但 `String` 计算 `hashCode` 是根据**字符内容**算的。
        * 两个 `"tom"` 的哈希值是**一样**的。
    - 当哈希值一样时，HashSet 会调用 `equals()` 进一步确认。
    - `String` 的 `equals()` 也是比较**字符内容**。
+ **结论**：哈希值相同 + equals 比较相同 = 视为同一个元素 -> **去重**。

### HashSet底层机制
1. 向HashSet中添加元素时底层实际的步骤：
    1. 先获取元素的哈希值（使用`hashCode()`方法）
    2. 对哈希值进行运算，得出一个索引值即为要存放在哈希表中的位置号
    3. 如果该位置上没有其他元素，则直接存放；如果该位置上已经有其他元素，则需要进行`equals`判断，如果相等，则不再添加（这就是HashSet不可重复的原因）；如果不相等，则以链表的方式添加
    4. <font style="color:rgb(31, 35, 40);">在Java8中,如果一条链表的元素个数到达 TREEIFY_THRESHOLD(默认是8)，并且table的大小>=MIN TREEIFY CAPACITY(默认64),就会进行树化(红黑树)，否则仍然会采用数组扩容机制。</font>

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763810410370-b54a6c99-784b-4b2d-94fe-480e18e8540a.png)

+ 其中`Bucket`是由Hash算法算出的内部地址
2. `hashCode()`和`equals()`的源码
+ Set接口中的`hashCode()`抽象方法

```java
// 这是一个 native 方法，由 C/C++ 实现，直接操作内存
// 默认逻辑：通常是将对象的【内存地址】经过特定算法转换成一个整数
public native int hashCode();
```

+ Set中的`equals()`抽象方法

```java
public boolean equals(Object obj) {
    // 核心逻辑：只有当两个引用指向内存中【同一个对象】时，才返回 true
    return (this == obj);
}
```

3. `String`类重写后的`hashCode()`和`equals()`方法源码

```java
// 缓存哈希值，计算过一次就不再计算 (String 是不可变的)
private int hash; // Default to 0

public int hashCode() {
    int h = hash;
    // 如果 hash 还没算过 (h==0) 且字符串长度 > 0
    if (h == 0 && value.length > 0) {
        char val[] = value; // 获取字符串内部的字符数组

        // 遍历每一个字符
        for (int i = 0; i < value.length; i++) {
            // 核心算法：h = 31 * h + 当前字符的ASCII码
            h = 31 * h + val[i];
        }
        hash = h; // 缓存结果
    }
    return h;
}
```

**解析**：只要字符数组 `value` 里的字符序列完全一样，计算出来的 `h` 就一定一样。

```java
public boolean equals(Object anObject) {
    // 1. 如果内存地址都一样，那肯定是相等的，直接 true (性能优化)
    if (this == anObject) {
        return true;
    }
    // 2. 判断是否是 String 类型
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        // 3. 先比较长度，长度不一样肯定不相等
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            // 4. 逐个字符比较
            while (n-- != 0) {
                // 只要发现有一个字符不一样，立刻返回 false
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            // 全部比完都一样，返回 true
            return true;
        }
    }
    return false;
}
```

**总结**：`String` 的逻辑完全基于**内容 (Content)**。哪怕是两个不同内存地址的对象，只要里面装的字符一样，hash 就一样，equals 也返回 true。

### HashSet练习
1. 需求
+ <font style="color:rgb(31, 35, 40);">定义一个Employee类,该类包含:private成员属性name.age</font>
+ <font style="color:rgb(31, 35, 40);">要求:</font>
    - <font style="color:rgb(31, 35, 40);">创建3个Employee对象放入 HashSet中</font>
    - <font style="color:rgb(31, 35, 40);">当name和age的值相同时，认为是相同员工,不能添加到HashSet集合中</font>
2. 实现

```java
package com.aurora.set.SetInteface;

import java.util.Objects;

public class Employee {
    private String name;
    private int age;

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    /**
     * 核心去重逻辑 1: 比较内容
     * 如果不重写，默认比较内存地址 (==)，那第3个对象就能加进去
     */
    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;
        Employee employee = (Employee) o;
        return age == employee.age && Objects.equals(name, employee.name);
    }

    /**
     * 核心去重逻辑 2: 计算特征码
     * 必须保证：如果两个对象 equals 为 true，它们的 hashCode 必须一样
     */
    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
```

```java
package com.aurora.set.SetInteface;

import java.util.HashSet;

public class HashSetPractice01 {
    @SuppressWarnings("all")
    public static void main(String[] args) {

        HashSet hashSet = new HashSet();
        hashSet.add(new Employee("tom", 18));       //加入成功
        hashSet.add(new Employee("jerry", 20));     //加入成功
        hashSet.add(new Employee("tom", 18));       //name和age均重复，没有加入

        System.out.println(hashSet);    //[Employee{name='jerry', age=20}, Employee{name='tom', age=18}]
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763812216896-5619b585-1104-4165-929d-79673c59556e.png)

3. 重写`equals()`
+ 为什么要重写：如果不重写，默认比较内存地址 (==)，那第`name`和`age`重复的对象就能加进去
4. 重写`hashCode()`
+ 为什么要重写：Java Object class的官方规范： 如果两个对象 equals() 相等，那么它们的 hashCode 必须相等
+ 重写代码的解释：最终返回的是`Objects.hash(name, age);`
    - 先来看`hash()`的源码

```java
    public static int hash(Object... values) {
        return Arrays.hashCode(values);
    }
```

    - 通过源码可以看到`hash()`内部做了什么
        * 将传入的参数组成一个Object数组：`Object[] array = { name, age };`
        * 然后调用：`return Arrays.hashCode(array);`
        * 这就将多个字段的hash值组合成一个整体hash，然后再用`hashCode()`计算这个整体的hash值
5. 为什么要同时重写`equals()`和`hashCode()`
+  在基于哈希的数据结构中（HashSet/HashMap），对象的存储位置由 hashCode 决定，而对象是否相等由 equals 决定。因此，当你重写 equals 时必须同时重写 hashCode，否则集合判重会失败，导致重复元素或重复 key。
+ 判断两个元素是否重复会经历两个步骤：
    - hashCode相同吗？
        * 相同->继续进入`equals()`判断
        * 不同->元素肯定不重复，加入
    - equals相同吗？（因为hashCode是通过hash函数映射的，所以不同元素也可能会hashCode值相同，所以必须进入这一步再判断）
        * 相同->认为重复，不加入
        * 不同->不重复，可以加入（即使hashCode一样）

## Set接口实现类_LinkedHashSet
### LinkedHashSet的介绍
1. `<font style="color:rgb(31, 35, 40);">L</font><font style="color:rgb(31, 35, 40);">inkedHashSet</font>`<font style="color:rgb(31, 35, 40);"> 是 </font>`<font style="color:rgb(31, 35, 40);">HashSet</font>`<font style="color:rgb(31, 35, 40);">的子类</font>
2. `<font style="color:rgb(31, 35, 40);">LinkedHashSet</font>`<font style="color:rgb(31, 35, 40);"> 底层是一个 </font>`<font style="color:rgb(31, 35, 40);">LinkedHashMap</font>`<font style="color:rgb(31, 35, 40);">，底层维护了一个数组+双向链表</font>
3. **<font style="color:rgb(31, 35, 40);">双向链表的维护</font>**<font style="color:rgb(31, 35, 40);">：</font>`<font style="color:rgb(31, 35, 40);">LinkedHashSet</font>`<font style="color:rgb(31, 35, 40);"> (通过 </font>`<font style="color:rgb(31, 35, 40);">LinkedHashMap</font>`<font style="color:rgb(31, 35, 40);">) 维护了两个指针 </font>`<font style="color:rgb(31, 35, 40);">head</font>`<font style="color:rgb(31, 35, 40);"> (头) 和 </font>`<font style="color:rgb(31, 35, 40);">tail</font>`<font style="color:rgb(31, 35, 40);"> (尾)。</font>
4. <font style="color:rgb(31, 35, 40);">存储策略：</font>
+ <font style="color:rgb(31, 35, 40);">根据元素的</font>`<font style="color:rgb(31, 35, 40);">hashCode</font>`<font style="color:rgb(31, 35, 40);">值来决定元素的存储位置（与</font>`<font style="color:rgb(31, 35, 40);">HashSet</font>`<font style="color:rgb(31, 35, 40);">一样）</font>
+ <font style="color:rgb(31, 35, 40);">同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的（实际不是）。</font>
5. <font style="color:rgb(31, 35, 40);">特点：</font>
+ **有序性**<font style="color:rgb(31, 35, 40);">: 看起来元素是以</font>**插入顺序**<font style="color:rgb(31, 35, 40);">保存的（插入顺序和遍历顺序一致）。</font>
+ **唯一性**<font style="color:rgb(31, 35, 40);">: 不允许添加重复元素。</font>

### 示例
```java
package com.aurora.set.SetInteface;

public class Customer {
    private String name;
    private int no;

    public Customer(String name, int no) {
        this.name = name;
        this.no = no;
    }

    @Override
    public String toString() {
        return "Customer{" +
                "name='" + name + '\'' +
                ", no=" + no +
                '}';
    }

    // 注意：实际开发中放入 Set 的对象通常需要重写 hashCode 和 equals
    //这里由于不添加重复的Customer元素，所以没写
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763889132894-35884899-8f95-4945-ac54-96c1b66f8b98.png)

**结果**：

+ 可以看到输出顺序与添加顺序相同
+ 重复的`456`没有添加进去

### LinkedHashSet添加元素的过程
1. **计算位置**: 先求 `hash` 值，再求索引，确定该元素在 `table` 数组中的位置（这步和 `HashSet` 一样，用于快速查找和去重）。
2. **放入哈希表**: 将元素放入对应的数组位置（如果冲突则挂在单链表或红黑树上）。
3. **维护双向链表**: 将新添加的元素加入到双向链表的尾部。

```java
tail.next = newElement //示意代码
newElement.pre = tail
tail = newEelment;
```

+ LInkedHashSet存储元素的示意图

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763890335557-f23ec622-058d-4473-a563-60a941477e64.png)

通过以上步骤，就保证了LinkedHashSet的遍历顺序和插入顺序一致。

### LinkedHashSet练习题
<font style="color:rgb(31, 35, 40);">Car类(属性:name,price)，如果name和price一样，则认为是相同元素，就不能添加。</font>

```java
package com.aurora.set.SetInteface;

import java.util.Objects;

public class Car {
    private String name;
    private double price;

    public Car(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }

    @Override
    public String toString() {
        return "Car{" +
                "name='" + name + '\'' +
                ", price=" + price +
                '}';
    }

    //重写equals 方法 和 hashCode
    //当 name 和 price 相同时， 就返回相同的 hashCode 值, equals返回true
    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;
        Car car = (Car) o;
        return Double.compare(price, car.price) == 0 && Objects.equals(name, car.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, price);
    }
}
```

```java
package com.aurora.set.SetInteface;

import java.util.LinkedHashSet;

@SuppressWarnings("all")
public class LinkedHashSetPractice {
    public static void main(String[] args) {
        LinkedHashSet linkedHashSet = new LinkedHashSet();
        linkedHashSet.add(new Car("奥拓", 1000));     //OK
        linkedHashSet.add(new Car("奥迪", 300000));   //OK
        linkedHashSet.add(new Car("法拉利", 10000000));    //OK
        linkedHashSet.add(new Car("奥迪", 300000));   //加入不了
        linkedHashSet.add(new Car("保时捷", 70000000));    //OK
        linkedHashSet.add(new Car("奥迪", 300000));   //加入不了

        System.out.println("linkedHashSet=" + linkedHashSet);
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763890786717-200bf7fb-e5fb-4db8-b247-b8484a3cbdd4.png)

### LinkedHashSet与HashSet的区别
| 特性 | HashSet | LinkedHashSet |
| --- | --- | --- |
| **底层实现** | 基于 `HashMap` | 基于 `LinkedHashMap` (HashMap 的子类) |
| **数据结构** | 数组 + 链表 (或红黑树) | 数组 + 链表 (或红黑树) + **双向链表** |
| **有序性** | **无序** (取决于 Hash 值) | **有序** (默认为插入顺序) |
| **添加/删除性能** | 极快 $O(1)$，开销最小 | 稍慢 $O(1)$，因为需要维护双向链表的指针 |
| **遍历性能** | 取决于 `capacity` (容量) + `size` (元素数量) | 只取决于 `size` (元素数量)，遍历通常更快 |
| **内存占用** | 较小 | **较大** (每个节点多两个引用：`before` 和 `after`) |
| **允许 Null 值** | 允许 (最多 1 个) | 允许 (最多 1 个) |
| **线程安全** | 不安全 | 不安全 |


# Map接口及实现类
## Map接口
![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763955105473-554a209e-0b59-4b06-879b-baa3a67de78e.png)

### Map接口实现类的特点
1. Map与Collection并列存在，`Collection` 是单列集合 (保存单个对象)，`Map` 用于保存具有**映射关系**的数据：`Key-Value` (键值对)。
2. **数据存储特性**
+ **引用类型**：Map 中的 key 和 value 可以是任何引用类型的数据。
+ **底层封装**：
    - 在 JDK 8 及以后，键值对会封装到 `HashMap$Node` 对象中（实现了 `Map.Entry` 接口）。
    - 底层结构为：数组 + 链表 + 红黑树。
3. **约束关系**
+ **Key（键）**:
    - **不允许重复**：判定重复的机制依赖于 `hashCode()` 和 `equals()` 方法（原理与 `HashSet` 一致）。
    - **覆盖机制**：如果添加相同的 Key，新的 Value 会覆盖旧的 Value。
    - **允许为 null**：`HashMap` 允许 Key 为 `null`，但只能有一个（因为 Key 不可重复）。
    - **常用类型**：`String` 类最常作为 Map 的 Key，因为它是不可变的且重写了 hash 方法。
+ **Value（值）**
    - **允许重复**：不同的 Key 可以指向相同的 Value。
    - **允许为 null**：Value 可以为 `null`，且可以有多个。
3. **映射关系**
+ **单向一对一**：通过指定的 Key 总能找到唯一对应的 Value。
4. 示例——以实现类HashMap为例

```java
package com.aurora.set.MapInterface;

import java.util.HashMap;
import java.util.Map;

@SuppressWarnings("all")
public class MapDemo01 {
    public static void main(String[] args) {
        Map map = new HashMap();

        //添加元素
        map.put("no1", "韩顺平");
        map.put("no2", "张无忌");//k-v
        map.put("no1", "张三丰");//当有相同的k , 就等价于替换.
        map.put("no3", "张三丰");//k-v
        map.put(null, null); //k-v
        map.put(null, "abc"); //等价替换
        map.put("no4", null); //k-v
        map.put("no5", null); //k-v
        map.put(1, "赵敏");//k-v
        map.put(new Object(), "金毛狮王");//k-v

        System.out.println(map.get("no2"));

        System.out.println("map: " + map);
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763961655550-74f19e6c-6248-48dc-8e46-8efcb8eb53bd.png)

### Map的底层实现原理
1. `**HashMap.Node**`**:HashMap存储**`**K-V**`**的真正载体**
+  也就是说，**一对 K-V 实际上是存放在一个 Node 对象中的。**
+ Node内布结构

```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next; // 指向下一个节点（链表）
}
```

2. `**Map.Entry**`**接口**

**Map.Entry 是一个接口**，其中定义了操作 K、V 的通用方法：

```java
K getKey();
V getValue();
```

而 **HashMap.Node 实现了 Entry 接口**：

```java
static class Node<K,V> implements Map.Entry<K,V>
```

所以：

+ **Node 是 Entry 的实现类**

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763963728842-a8728765-4aad-4cba-b6d7-6e04ee8655a8.png)

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763963679055-fd23c1b8-dcdd-43d1-8be6-6cb9d58b80dc.png)

**核心方法：**

+ `K getKey()`: 获取当前键值对的 Key。
+ `V getValue()`: 获取当前键值对的 Value。
+ `V setValue(V value)`: 修改当前键值对的 Value，并返回旧值。（注意：这是修改 Map 中数据的最高效方式之一，因为它直接操作了节点）。
3. `**entrySet()**`

`entrySet()`可以帮助我们遍历HashMap，当你调用：

```java
Set<Map.Entry<K,V>> set = map.entrySet();
```

entrySet() 返回的是一个 **视图（view）**：

```java
HashMap$EntrySet
```

EntrySet 的作用很简单：

+ 方便程序员遍历 HashMap 的所有 k-v 数据。

在这个集合中，元素“看起来”是 Map.Entry 类型，但实际上是 **Node 对象**。

注意： entrySet 中存放的只是数组中 Node 对象的引用，而不是复制一份。  这样有两个好处：

+ **节省内存**：不用再复制大量 Entry 对象。
+ **保持同步**：修改 map 中 Node 的 value，entrySet() 看到的 value 也是最新的。

### Map接口常用方法
| 方法名 | 描述 |
| --- | --- |
| `put(K key, V value)` | 添加键值对。如果 Key 已存在，返回旧值并更新为新值。 |
| `get(Object key)` | 根据 Key 获取 Value。 |
| `remove(Object key)` | 根据 Key 删除键值对。 |
| `size()` | 获取元素个数 |
| `isEmpty()` | 判断格式是否为0 |
| `containsKey(Object key)` | 判断是否包含指定的 Key。 |
| `keySet()` | 获取所有的 Key，返回 `Set` 集合。 |
| `values()` | 获取所有的 Value，返回 `Collection` 集合。 |
| `entrySet()` | 获取所有的键值对对象，返回 `Set<Map.Entry<K,V>>`。 |
| `clear()` | 清除k-v |


```java
package com.aurora.set.MapInterface;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

@SuppressWarnings("all")
public class MapMethod {
    public static void main(String[] args) {
        Map map = new HashMap();

        //1.put(K key, V value)
        map.put("fh", new Book("", 100));//OK
        map.put("fh", "bnd");//替换-> 一会分析源码
        map.put("fgd", "mr");//OK
        map.put("sgfh", "mr");//OK
        map.put("vcbhhd", null);//OK
        map.put(null, "dfhdfg");//OK
        map.put("lh", "gct");//OK
        map.put("hsp", "hspd");
        System.out.println("map: " + map);  //map: {null=dfhdfg, fh=bnd, fgd=mr, vcbhhd=null, sgfh=mr, hsp=hspd, lh=gct}

        //2.get(Object key)
        System.out.println(map.get("fh"));  //bnd

        //3.remove(Object key)
        map.remove(null);
        System.out.println("map: " + map);  //map: {fh=bnd, fgd=mr, vcbhhd=null, sgfh=mr, hsp=hspd, lh=gct}

        //4.size()
        System.out.println(map.size()); //6

        //5.isEmpty()
        System.out.println(map.isEmpty());  //false

        //6.containsKey(Object key)
        System.out.println(map.containsKey("hsp")); //true

        //7.keySet()
        Set keySetet = map.keySet();
        System.out.println(keySetet);   //[fh, fgd, vcbhhd, sgfh, hsp, lh]

        //8.values()
        Collection collection = map.values();
        System.out.println(collection); //[bnd, mr, null, mr, hspd, gct]

        //9.entrySet()
        Set set = map.entrySet();
        System.out.println(set);    //[fh=bnd, fgd=mr, vcbhhd=null, sgfh=mr, hsp=hspd, lh=gct]

        //10.clear()
        map.clear();
        System.out.println("map: " + map);  //map: {}
    }
}


class Book {
    private String name;
    private int num;

    public Book(String name, int num) {
        this.name = name;
        this.num = num;
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763965031165-73cc22bf-ff44-4325-b8a9-03982b45f6ba.png)

### Map接口遍历方法
Map 接口（如 HashMap）与 List 或 Set 不同，它不继承 `Iterable` 接口，因此不能直接对 Map 对象本身使用 `for-each` 循环。

我们需要通过某种方式获取它的 **Key 集合**、**Value 集合** 或 **Entry (键值对) 集合**，然后再进行遍历。因为**Key集合**和 **Entry (键值对) 集合**的类型为`Set`，**Value 集合**的类型为`Collection`，而`Set`和`Collection`都继承了`Iterable`接口，因此可以进行遍历。

####  通过 `keySet() `遍历  Key，再用 `get() `拿 Value
1. 先取出所有key

```java
Set keySet = map.keySet();
```

2. 方法一：使用增强for循环遍历

```java
for (Object key : keySet) {
    System.out.println(key + "-" + map.get(key));
}
```

3. 方法二：使用迭代器遍历

```java
Iterator iterator = keySet.iterator();
while (iterator.hasNext()) {
    Object key = iterator.next();
    System.out.println(key + "-" + map.get(key));
}
```

4. 示例

```java
package com.aurora.set.MapInterface;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

@SuppressWarnings("all")
public class MapFor01 {
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put("邓超", "孙俪");
        map.put("王宝强", "马蓉");
        map.put("宋喆", "马蓉");
        map.put("刘令博", null);
        map.put(null, "刘亦菲");
        map.put("鹿晗", "关晓彤");

        //先取出所有key
        Set keyset = map.keySet();

        //增强for循环遍历
        System.out.println("===============增强for循环遍历===========");
        for (Object key : keyset) {
            System.out.println(key + ":" + map.get(key));
        }

        //迭代器遍历
        System.out.println("===============迭代器遍历===========");
        Iterator iterator = keyset.iterator();
        while (iterator.hasNext()) {
            Object key = iterator.next();
            System.out.println(key + ":" + map.get(key));
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763970625454-ae239b0b-3e8a-4110-999e-277829fd1d6a.png)

#### 通过values()遍历Value
 只能看 value，如果你只关心“值”，不在乎是哪个“键”对应的，可以使用这种方式。

1. 获取所有value

```java
Collection values = map.values();
```

2. 方式一：使用增强for循环遍历

```java
for (Object value : values) {
    System.out.println(value);
}
```

3. 方式二：使用迭代器遍历

```java
Iterator iterator = values.iterator();
while (iterator.hasNext()) {
    Object obj = iterator.next();
    System.out.println(obj);
}
```

4. 示例

```java
package com.aurora.set.MapInterface;

import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

@SuppressWarnings("all")
public class MapFor02 {
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put("邓超", "孙俪");
        map.put("王宝强", "马蓉");
        map.put("宋喆", "马蓉");
        map.put("刘令博", null);
        map.put(null, "刘亦菲");
        map.put("鹿晗", "关晓彤");

        //取出所有的value
        Collection valueset = map.values();

        //使用增强for循环遍历
        System.out.println("============使用增强for循环遍历=================");
        for (Object value : valueset) {
            System.out.println(value);
        }

        //使用迭代器遍历
        System.out.println("============使用迭代器遍历=================");
        Iterator iterator = valueset.iterator();
        while (iterator.hasNext()) {
            Object obj = iterator.next();
            System.out.println(obj);
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763970945968-f807aace-412a-4b32-b303-0d983accd42a.png)

####  通过 entrySet() 遍历 Key-Value  
这是**最高效**且在开发中**最推荐**的遍历方式，特别是当既需要 Key 又需要 Value 时。

1. 取出所有键值对

```java
Set entrySet = map.entrySet();
```

2. 方式一：使用增强for循环遍历

```java
for (Object entry : entrySet) {
    Map.Entry m = (Map.Entry) entry;
    System.out.println(m.getKey() + "-" + m.getValue());
}
```

3. 方式二：使用增强for循环遍历

```java
Iterator iterator3 = entrySet.iterator();
while (iterator3.hasNext()) {
    Map.Entry m = (Map.Entry) iterator3.next();
    System.out.println(m.getKey() + "-" + m.getValue());
}
```

4. 示例

```java
package com.aurora.set.MapInterface;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

@SuppressWarnings("all")
public class MapFor03 {
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put("邓超", "孙俪");
        map.put("王宝强", "马蓉");
        map.put("宋喆", "马蓉");
        map.put("刘令博", null);
        map.put(null, "刘亦菲");
        map.put("鹿晗", "关晓彤");

        //获取所有Entry（键值对）
        Set entrySet = map.entrySet();

        //使用增强for循环遍历
        System.out.println("============使用增强for循环遍历==============");
        for (Object key : entrySet) {
            Map.Entry entry = (Map.Entry) key;
            System.out.println(entry.getKey() + ":" + entry.getValue());
        }

        //使用迭代器遍历
        System.out.println("============使用迭代器遍历==============");
        Iterator iterator = entrySet.iterator();
        while (iterator.hasNext()) {
            Map.Entry entry = (Map.Entry) iterator.next();
            System.out.println(entry.getKey() + ":" + entry.getValue());
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763972294735-1fbd71b8-bcbd-428c-9cee-7839565ad8a4.png)

### Map接口练习
1. 需求
+ <font style="color:rgb(31, 35, 40);">使用HashMap添加3个员工对象，要求</font>
    - <font style="color:rgb(31, 35, 40);">键:员工id</font>
    - <font style="color:rgb(31, 35, 40);">值:员工对象</font>
+ <font style="color:rgb(31, 35, 40);">并遍历显示工资>18000的员工(遍历方式最少两种)</font>
+ <font style="color:rgb(31, 35, 40);">员工类:姓名、工资、员工id</font>
2. 实现

```java
package com.aurora.set.Map.MapInterface;

import java.util.Objects;

public class Employee {
    private String name;
    private int no;
    private double salary;

    public Employee(String name, int no, double salary) {
        this.name = name;
        this.no = no;
        this.salary = salary;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "name='" + name + '\'' +
                ", no=" + no +
                ", salary=" + salary +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;
        Employee employee = (Employee) o;
        return no == employee.no && Double.compare(salary, employee.salary) == 0 && Objects.equals(name, employee.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, no, salary);
    }
}
```

```java
package com.aurora.set.Map.MapInterface;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

@SuppressWarnings("all")
public class MapPractice01 {
    public static void main(String[] args) {
        Map map = new HashMap();

        //创建员工对象
        Employee tom = new Employee("tom", 1001, 20000);
        Employee jerry = new Employee("jerry", 1002, 10000);
        Employee jack = new Employee("jack", 1003, 19000);

        //添加员工对象至HashMap
        map.put(tom.getNo(), tom);
        map.put(jerry.getNo(), jerry);
        map.put(jack.getNo(), jack);

        //并遍历显示工资>18000的员工(遍历方式最少两种)
        //1.增强for循环遍历Entry
        System.out.println("=============增强for循环遍历Entry===============");
        Set entrySet = map.entrySet();
        for (Object entry : entrySet) {
            Map.Entry item = (Map.Entry) entry;
            Employee employee = (Employee) item.getValue();
            if (employee.getSalary() > 18000) {
                System.out.println(item.getKey() + ":" + item.getValue());
            }
        }

        //2.迭代器遍历Entry
        //Set entrySet = map.entrySet();    //上面写过一次了
        System.out.println("=============迭代器遍历Entry===============");
        Iterator iterator = entrySet.iterator();
        while (iterator.hasNext()) {
            Map.Entry item = (Map.Entry) iterator.next();
            Employee employee = (Employee) item.getValue();
            if (employee.getSalary() > 18000) {
                System.out.println(item.getKey() + ":" + item.getValue());
            }
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763973329025-2dac674e-c460-4ab0-a7c9-c2198783c9b4.png)

## Map接口实现类HashMap
### HashMap总结
1. **基本介绍**
+ **Map接口的常用实现类**：<font style="color:rgb(31, 35, 40);">HashMap、Hashtable和Properties。</font>
+ **所属体系**：`HashMap` 是 `java.util.Map` 接口使用频率最高的实现类。
2. **数据存储特点**
+ **存储形式**：以 `Key-Value`（键值对）的方式存储数据。
    - 在 JDK 8 中，节点类型为 `HashMap$Node`（实现了 `Map.Entry` 接口）。
+ **Key (键) 的特点**：
    - **不可重复**：如果插入相同的 Key，新的 Value 会**替换**旧的 Value。
    - **Key 的本质**：Key 不会被替换（引用地址不变），只是 Value 更新了。
    - 允许使用 `null` 作为 Key（且只能有一个）。
+ **Value (值) 的特点**：
    - **可重复**：不同的 Key 可以对应相同的 Value。
    - 允许使用 `null` 作为 Value（可以有多个）。
+ **无序性**：不保证映射的顺序（插入顺序与遍历顺序不一致），因为底层是基于 Hash 表存储的。
3. **线程安全性**
+ **不安全**：`HashMap` 没有实现同步（Synchronized），方法没有互斥操作。
+ **并发问题**：
    - 多线程环境下扩容可能导致数据覆盖或死循环（JDK 7 容易出现死循环，JDK 8 修复了死循环但在多线程下仍会丢失数据）。
+ **替代方案**：
    - 如果是多线程并发环境，建议使用 `java.util.concurrent.ConcurrentHashMap`。

### HashMap底层机制
Java 8中：HashMap底层的数据结构为**数组 + 链表 + 红黑树**

**添加元素 (Put) 详细执行流程**

1. **初始化****：**
    - 创建 `HashMap` 对象时，将加载因子 (`loadFactor`) 初始化为 0.75。
    - 此时 `table` 数组依然为 `null`（懒加载，直到第1次添加时才初始化）。
2. **计算索引****：**
    - 当添加 `key-value` 时，通过 `key.hashCode()` 并经过扰动函数得到哈希值，进而计算出在 `table` 中的索引位置。
3. **判断位置状态****：**
    - **无元素**：如果该索引处没有元素，直接添加。
    - **有元素（碰撞）**：如果该索引处已经有元素，继续判断：
        * **Key 相等**：判断当前元素的 Key 与准备加入的 Key 是否相等（hash值相同且 `==` 或 `equals` 为 true）。如果相等，则直接替换 value。
        * **Key 不等**：
            + 判断是树结构：如果是红黑树节点，调用树的插入方法。
            + 判断是链表结构：如果是链表，则遍历链表（JDK 8 尾插法）。

**扩容机制 (Resize) 深度解析**

+ **第 1 次添加****：**
    - 发现 `table` 为 null，进行初始化扩容。
    - `table` 容量变为 16。
    - 计算临界值 (`threshold`) = 16 * 0.75 = 12。
+ **后续扩容****：**
    - 当元素个数超过临界值（例如 12）时触发。
    - `table` 容量扩容为原来的 2 倍 (例如 16 -> 32)。
    - 临界值也变为原来的 2 倍 (例如 12 -> 24)，依次类推。
+ **树化具体条件 (JDK 8)****：**
    - 条件 1：链表元素个数 > `TREEIFY_THRESHOLD` (默认 8)。
    - 条件 2：`table` 的大小 >= `MIN_TREEIFY_CAPACITY` (默认 64)。
    - _注意_：如果链表长 > 8 但数组容量 < 64，只会触发扩容（Resize）来尝试打散链表，而不会树化。

### HashMap的使用
在讲Map接口时使用的都是HashMap为例，已经讲解的很详细了

## Map接口实现类Hashtable
了解即可，版本遗留类，不推荐使用

### Hashtable的基本介绍
1. <font style="color:rgb(31, 35, 40);">存放的元素是键值对:即</font>`<font style="color:rgb(31, 35, 40);">K-V</font>`<font style="color:rgb(31, 35, 40);">， 底层结构都是 </font>**哈希表（数组 + 链表 / 红黑树）**
2. **<font style="color:rgb(31, 35, 40);">hashtable的键和值都不能为null</font>**<font style="color:rgb(31, 35, 40);">，否则会抛出</font>`<font style="color:rgb(31, 35, 40);">NullPointerException</font>`
+  因为 `Hashtable` 是早期年代设计的，方法内需要用 `key.hashCode()`，如果 key 为 null 会直接 `<font style="color:rgb(31, 35, 40);">NullPointerException</font>`，它没有额外判断。  
3. <font style="color:rgb(31, 35, 40);">hashTable使用方法基本上和HashMap一样</font>
4. <font style="color:rgb(31, 35, 40);">hashTable 被 </font>`<font style="color:rgb(31, 35, 40);">synchronized</font>`<font style="color:rgb(31, 35, 40);"> 修饰，是线程安全的(synchronized),例如：</font>

```java
public synchronized V put(K key, V value)
```

<font style="color:rgb(31, 35, 40);"> hashMap是线程不安全的</font>

### <font style="color:rgb(31, 35, 40);">HashTable和HashMap的对比</font>
| 特性 | HashMap | Hashtable |
| --- | --- | --- |
| **线程安全** | **不安全** (无 synchronized) | **安全** (方法上有 synchronized) |
| **Null 键/值** | 允许 (Key只允许1个null) | **不允许** (否则抛 `NullPointerException`) |
| **效率** | 较高 (非同步) | 较低 (同步开销大) |
| **用法** | Map 接口主要实现类 | 与 HashMap 基本一致 (遗留类，不推荐) |
| **底层扩容** | 初始16，2倍扩容 | 初始11，2n+1扩容 |


## Map接口实现类Properties
### Properties基本介绍
1. **<font style="color:rgb(31, 35, 40);">Properties类继承自 Hashtable 类并且实现了Map接口</font>**<font style="color:rgb(31, 35, 40);">，也是使用一种键值对的形式来保存数据。</font>
2. **<font style="color:rgb(31, 35, 40);">与hashtable一样，Properties的键和值都不能为null</font>**<font style="color:rgb(31, 35, 40);">，否则会抛出</font>`<font style="color:rgb(31, 35, 40);">NullPointerException</font>`
3. <font style="color:rgb(31, 35, 40);">他的使用特点和Hashtable类似。</font>
4. <font style="color:rgb(31, 35, 40);">Properties还可以用于从xxx.properties文件中，加载数据到Properties类对象, 并进行读取和修改。</font>
5. <font style="color:rgb(31, 35, 40);">说明:工作后 xxx.properties文件通常作为配置文件，这个知识点在IO流举例,有兴趣可先看文章。</font>[https://www.cnblogs.com/xudong-bupt/p/3758136.html](https://www.cnblogs.com/xudong-bupt/p/3758136.html)

### Properties基本使用
```java
package com.aurora.set.Map;

import java.util.Properties;

@SuppressWarnings("all")
public class PropertiesDemo01 {
    public static void main(String[] args) {
        Properties properties = new Properties();
//        properties.put(null, "abc");    //NullPointerException
//        properties.put("abc", null);    //NullPointerException

        properties.put("john", 100);
        properties.put("lucy", 100);
        properties.put("lic", 100);
        properties.put("lic", 88);

        System.out.println("properties: " + properties);    //properties: {john=100, lic=88, lucy=100}

        //通过key获取对应值
        System.out.println(properties.get("john")); //100
        System.out.println(properties.getProperty("lucy")); //null

        //删除
        properties.remove("lic");
        System.out.println("properties: " + properties);    //properties: {john=100, lucy=100}

        //修改
        properties.put("john", 999);    //直接添加相同的键覆盖就好了
        System.out.println("properties: " + properties);    //properties: {john=999, lucy=100}
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763978182591-aa73cf4e-2451-48a5-b024-5ec009d68392.png)

**为什么 **`**getProperty("lucy")**`** 得到 null？**

```java
properties.put("lucy", 100);
System.out.println(properties.getProperty("lucy")); // null
```

**原因**：  
`getProperty()` 会将 key 和 value 都当作 **String** 处理。

但存入的是：

```java
put("lucy", 100);  // key="lucy", value= Integer(100)
```

value 类型不是 String，  
所以 `getProperty()` 取不到，返回 null。

🔧 **正确用法**：

```java
properties.setProperty("lucy", "100");
System.out.println(properties.getProperty("lucy")); // 100
```

# TreeSet和TreeMap
## 基本介绍
1. **特性**：`TreeMap` 和 `TreeSet` 是两个非常重要的类。与 `HashMap` 和 `HashSet` 不同，**Tree 系列集合的主要特性是：它们是有序的。**
2. **底层数据结构**：`TreeMap` 和 `TreeSet` 的底层都使用**红黑树**这种数据结构。
+ **为什么要用它？** 普通二叉树在极端情况下会退化成链表（查询复杂度变 O(n)）。红黑树通过复杂的旋转和变色操作，保证树的高度大致平衡。
3. **TreeSet与TreeMap的关系**：类似于 `HashSet` 是基于 `HashMap` 实现的一样，`**TreeSet**`** 的底层也是基于 **`**TreeMap**`** 实现的**。
+ `TreeMap` 存储 Key-Value 对。
+ `TreeSet` 只存储 Elements。在内部，它把 Element 当作 `TreeMap` 的 Key，而 Value 则是一个固定的虚拟对象（`PRESENT`）。

## TreeMap
1. `TreeMap` 实现了 `SortedMap` 和 `NavigableMap` 接口，这赋予了它强大的导航功能（如获取“小于某个值的最大键”）。
2. **排序规则**：`TreeMap` 中的 Key 必须是可排序的。它支持两种排序方式：
+ **自然排序 (Natural Ordering):** Key 必须实现 `Comparable` 接口（例如 `String`, `Integer` 默认都实现了）。
+ **定制排序 (Custom Ordering):** 在构造 `TreeMap` 时传入一个 `Comparator` 对象。
    - 详细信息参考文档：常用类（6.3.2定制排序）
3. **关键特性**
+ **Key 唯一性与覆盖：**`TreeMap` 中 Key 是唯一的。如果 `put` 一个已经存在的 Key，**旧的 Value 会被新的 Value 覆盖**，集合的大小（size）不会增加。
+ **Key 不允许为 null：** 在 `TreeMap` 中，Key 不能为 `null`（因为需要调用 `compareTo` 或 `compare` 方法进行排序，null 会抛出空指针异常）。_注：在极旧的 JDK 版本中可能允许，但现在标准是不允许。_
+ **Value 可以为 null。**
+ **非线程安全：** 如果多线程并发访问，需要使用 `Collections.synchronizedSortedMap` 包装。
4. 基本使用及排序示例

```java
package com.aurora.set.Map;

import java.util.Comparator;
import java.util.TreeMap;

@SuppressWarnings("all")
public class TreeMapDemo01 {
    public static void main(String[] args) {
        //示例1：使用默认排序
        TreeMap scores = new TreeMap();
        scores.put(98, "Math");
        scores.put(85, "English");
        scores.put(100, "Physics");
        scores.put(100, "Computer");    //key重复，原来对应的value被覆盖

        //输出结果自动按key升序
        System.out.println(scores);     //{85=English, 98=Math, 100=Physics}

        //示例二：自定义排序
        TreeMap salary = new TreeMap(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                return ((String) o1).length() - ((String) o2).length();     //按照key的长度升序排列
            }
        });

        salary.put("Alice", 5000);
        salary.put("Bob", 8000);
        salary.put("Charlie", 6000);

        System.out.println(salary);     //{Bob=8000, Alice=5000, Charlie=6000}
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764071108440-74831506-72cd-4de4-8922-57f9a147f52e.png)

## TreeSet
1. `TreeSet` 实现了 `SortedSet` 和 `NavigableSet` 接口。它是一个有序的、不包含重复元素的集合。
2. **去重与排序机制**
+ `TreeSet` 判断两个元素是否“相等”以及确定顺序，**不依赖 **`**hashCode()**`** 和 **`**equals()**`，而是依赖 `compareTo()` (自然排序) 或 `compare()` (定制排序)。
+ 如果 `compareTo` 返回 `0`，`TreeSet` 认为这两个元素是相同的，后添加的元素一般不会替换旧元素（但在 `TreeMap` 中，Key 相同 Value 会被覆盖）。
3. 使用示例

```java
package com.aurora.set.Map;

import java.util.Comparator;
import java.util.TreeSet;

@SuppressWarnings("all")
public class TreeSetDemo01 {
    public static void main(String[] args) {
        TreeSet treeSet = new TreeSet(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                return ((String) o1).length() - ((String) o2).length();
            }
        });

        treeSet.add("jack");
        treeSet.add("tom");
        treeSet.add("hh");
        treeSet.add("a");
        treeSet.add("abc");     //长度与"tom"同样为3，加不进去

        System.out.println(treeSet);    //[a, hh, tom, jack]
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764071831500-9eb5a4f4-fd85-4dd3-bdf7-953475b30a01.png)

+ `**treeSet.add("abc");**`**加入不进去的原因**
    - 这就是TreeSet的去重机制，`TreeSet` 判断两个元素是否“相等”以及确定顺序，**不依赖 **`**hashCode()**`** 和 **`**equals()**`，而是依赖 `compareTo()` (自然排序) 或 `compare()` (定制排序)。
    - 我们在定制排序中将排序规则改成了按照元素的长度（`return ((String) o1).length() - ((String) o2).length();`），要新加入的`"abc"`长度与已经存在的元素`"tom"`长度都为3，所以被视为重复元素，不能添加进去
    - 如果是默认排序，那么就是按照`compareTo()`来排序，也就是按照字符串的大小（不是长度， 而是基于字符的 **Unicode 编码值** 进行比较的  ），大小相同就视为重复元素，不能添加。

# 总结：开发中如何选择集合实现类
<font style="color:rgb(31, 35, 40);">在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行选择,分析如下:</font>

1. <font style="color:rgb(31, 35, 40);">先判断存储的类型(一组对象[单列] / 一组键值对[双列])</font>
2. <font style="color:rgb(31, 35, 40);">一组对象[单列]:</font>
+ <font style="color:rgb(31, 35, 40);">Collection接口</font>
    - <font style="color:rgb(31, 35, 40);">允许重复:List</font>
        * <font style="color:rgb(31, 35, 40);">增删多:LinkedList[底层维护了一个双向链表]</font>
        * <font style="color:rgb(31, 35, 40);">改查多: ArrayList[底层维护Object类型的可变数组]</font>
    - <font style="color:rgb(31, 35, 40);">不允许重复:Set</font>
        * <font style="color:rgb(31, 35, 40);">无序:HashSet[底层是HashMap，维护了一个哈希表即(数组+链表+红黑树)</font>
        * <font style="color:rgb(31, 35, 40);">排序:TreeSet</font>
        * <font style="color:rgb(31, 35, 40);">插入和取出顺序一致:LinkedHashSet .维护数组+双向链表</font>
3. <font style="color:rgb(31, 35, 40);">一组键值对[双列]:Map</font>
+ <font style="color:rgb(31, 35, 40);">键无序;HashMap [底层是;哈希表 jdk7:数组+链表,jdk8:数组+链表+红黑</font>
+ <font style="color:rgb(31, 35, 40);">键排序: TreeMap</font>
+ <font style="color:rgb(31, 35, 40);">键插入和取出顺序一致:LinkedHashMap</font>
+ <font style="color:rgb(31, 35, 40);">读取文件Properties</font>

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1763983030125-46b43638-7445-4fe0-9d96-b2924f4dbf13.png)

# Collections工具类
## Collections工具类介绍
1. Collections是一个操作Set、List和Map等集合的工具类。
2. Colletions中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作。

## 排序操作
Colelctions中的排序操作均为static方法

1. `reverse(List)`：反转List中元素的顺序
2. `shuffle(List)`：对List集合元素进行随机排序
3. `sort(List)`：根据元素的自然顺序对指定List集合中的元素按照升序排序
4. `sort(List, Comparator)`：根据指定的Comparator产生的顺序对List中的元素进行排序
5. `swap(List, int i, int j)`：将指定list集合中的`i`处元素和`j`处元素进行交换

**注意**：这些方法只能用于List，不能用于Set和Map，因为：

+ 因为Set是无序的
+ Map存储的是键值对，连`Collections`接口都没有继承，是通过键值对查找元素，而不是下标索引

```java
package com.aurora.set.ColletionsUtils;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

@SuppressWarnings("all")
public class CollectionsSort {
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add("tom");
        list.add("smith");
        list.add("king");
        list.add("milan");
        list.add("tom");

        System.out.println("list: " + list);    //list: [tom, smith, king, milan, tom]

        //reverse()
        Collections.reverse(list);
        System.out.println("reverse: " + list);     //reverse: [tom, milan, king, smith, tom]

        //shuffle()
        Collections.shuffle(list);
        System.out.println("shuffled: " + list);    //shuffled: [king, smith, tom, milan, tom]

        //sort(List)
        Collections.sort(list);
        System.out.println("sorted: " + list);      //sorted: [king, milan, smith, tom, tom]

        //sort(List, Comparator)
        Collections.sort(list, new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                return ((String) o1).length() - ((String) o2).length();
            }
        });
        System.out.println("sorted(Comparator): " + list);      //sorted(Comparator): [tom, tom, king, milan, smith]

        //swap()
        Collections.swap(list, 1, 2);
        System.out.println("swap: " + list);    //swap: [tom, king, tom, milan, smith]
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764127516682-96f9700a-906a-4d9b-8f2a-ce6807d9cb20.png)

## 查找、替换
1. `<font style="color:rgb(31, 35, 40);">Object max(Collection)</font>`<font style="color:rgb(31, 35, 40);">:根据元素的自然顺序,返回给定集合中的最大元素。</font>
2. `<font style="color:rgb(31, 35, 40);">Object max(Collection,Comparator)</font>`<font style="color:rgb(31, 35, 40);">:根据Comparator指定的顺序， 返回给定集合中的最大元素。</font>
3. `<font style="color:rgb(31, 35, 40);">Object min(Collection)</font>`
4. `<font style="color:rgb(31, 35, 40);">Object min(Collection,Comparator)</font>`
5. `<font style="color:rgb(31, 35, 40);">int frequency(Collection,Object)</font>`<font style="color:rgb(31, 35, 40);">:返回指定集合中指定元素的出现次数。</font>
6. `<font style="color:rgb(31, 35, 40);">void copy(List dest,List src)</font>`<font style="color:rgb(31, 35, 40);">:将src中的内容复制到dest中。</font>
+ **注意：dest 的长度必须 >= src 的长度，否则会抛异常**。  
+ ![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764128601001-8d2dea08-6666-4652-be02-df8e404d6923.png)
+ 所以需要提前把`dest`填满占位元素
7. `<font style="color:rgb(31, 35, 40);">boolean replaceAll(List list,Object oldVal,Object newVal)</font>`<font style="color:rgb(31, 35, 40);">:使用新值 替换List 对象的所有旧值。</font>

```java
package com.aurora.set.ColletionsUtils;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

@SuppressWarnings("all")
public class CollectionsDemo {
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add("tom");
        list.add("smith");
        list.add("king");
        list.add("milan");
        list.add("tom");

        System.out.println("list: " + list);

        //max(Collection)
        System.out.println(Collections.max(list));

        //max(Collection, Comparator)
        Object max = Collections.max(list, new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                return ((String) o1).length() - ((String) o2).length();
            }
        });
        System.out.println("max = " + max);

        //min(Comparator)
        System.out.println(Collections.min(list));

        //min(Coleation, Comparator)
        Object min = Collections.min(list, new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                return ((String) o1).length() - ((String) o2).length();
            }
        });
        System.out.println("min  = " + min);

        //frequency()
        System.out.println("frequency: " + Collections.frequency(list, "tom"));

        //copy()
        ArrayList dest =  new ArrayList();
        //先给dest填充占位符，负责空间为0，不能正确将list中的元素复制到dest
        for (int i = 0; i < list.size(); i++) {     //这里设置dest的大小与List一样
            dest.add("");
        }
        Collections.copy(dest, list);
        System.out.println("dest: " + dest);

        //replaceALL
        Collections.replaceAll(list, "tom", "汤姆");
        System.out.println("replaceAll: " + list);
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764128835041-f2701c0b-48e9-4b3e-a055-6f0de76f6a1f.png)

# 本章练习
## 练习1
1. 需求
+ <font style="color:rgb(31, 35, 40);">(1) 封装一个新闻类，包含标题和内容属性，提供get、set方法，重写toString方法，打印对象时只打印标题;</font>
+ <font style="color:rgb(31, 35, 40);">(2) 只提供一个带参数的构造器，实例化对象时，只初始化标题;并且实例化两个对象:新闻一:</font>
    - <font style="color:rgb(31, 35, 40);">新冠确诊病例超千万，数百万印度教信徒赴恒河“圣浴”引民众担忧</font>
    - <font style="color:rgb(31, 35, 40);">新闻二:男子突然想起2个月前钓的鱼还在网兜里，捞起一看赶紧放生</font>
+ <font style="color:rgb(31, 35, 40);">(3) 将新闻对象添加到ArrayList集合中，并且进行倒序遍历;</font>
+ <font style="color:rgb(31, 35, 40);">(4) 在遍历集合过程中，对新闻标题进行处理，超过15字的只保留前15个，然后在后边加“…."</font>
+ <font style="color:rgb(31, 35, 40);">(5)在控制台打印遍历出经过处理的新闻标题;</font>
2. 实现

```java
package com.aurora.set.Practice;

public class News {
    private String title;
    private String content;

    public News(String title) {
        this.title = title;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    @Override
    public String toString() {
        return "News{" +
                "title='" + title + '\'' +
                '}';
    }
}
```

```java
package com.aurora.set.Practice;

import java.util.ArrayList;

@SuppressWarnings("all")
public class Practice01 {
    public static void main(String[] args) {
        News news1 = new News("新冠确诊病例超千万，数百万印度教信徒赴恒河“圣浴”引民众担忧");
        News news2 = new News("男子突然想起2个月前钓的鱼还在网兜里，捞起一看赶紧放生");

        ArrayList arrayList = new ArrayList();
        arrayList.add(news1);
        arrayList.add(news2);

        //倒序遍历
        for (int i = arrayList.size() - 1; i >= 0; i--) {
            News news = (News) arrayList.get(i);
            news.setTitle(processTitle(news.getTitle()));
        }

        System.out.println(arrayList);
    }

    //处理新闻标题的方法
    public static String processTitle(String title) {
        if (title == null) {
            return "";
        }
        if (title.length() > 15) {
            title = title.substring(1,15) + "...";
        }
        return title;
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764134250369-c0439231-bc59-47ce-a1db-6427c2bdfda2.png)

## 练习2
1. <font style="color:rgb(31, 35, 40);">需求：使用ArrayList完成对对象Car {name, price}的各种操作</font>
    1. <font style="color:rgb(31, 35, 40);">add:添加单个元素</font>
    2. <font style="color:rgb(31, 35, 40);">remove:删除指定元素</font>
    3. <font style="color:rgb(31, 35, 40);">contains:查找元素是否存在</font>
    4. <font style="color:rgb(31, 35, 40);">size:获取元素个数</font>
    5. <font style="color:rgb(31, 35, 40);">isEmpty:判断是否为空</font>
    6. <font style="color:rgb(31, 35, 40);">clear:清空</font>
    7. <font style="color:rgb(31, 35, 40);">addAll:添加多个元素</font>
    8. <font style="color:rgb(31, 35, 40);">containsAl:查找多个元素是否都存在</font>
    9. <font style="color:rgb(31, 35, 40);">removeAll:删除多个元素</font>
    10. <font style="color:rgb(31, 35, 40);">使用增强for和迭代器来遍历所有的car，需要重写Car的toString方法</font>
2. 实现

```java
package com.aurora.set.Practice;

import java.util.ArrayList;
import java.util.Iterator;

@SuppressWarnings("all")
public class Practice02 {
    public static void main(String[] args) {
        ArrayList cars = new ArrayList();
        Car car1 = new Car("Audi", 1000000);
        Car car2 = new Car("BMW", 1999999);
        Car car3 = new Car("Benz", 2888888);

        //1.add
        cars.add(car1);
        cars.add(car2);
        cars.add(car3);
        System.out.println("cars: " + cars);

        //2.remove
        cars.remove(1);
        System.out.println("remove: " + cars);

        //3.contains
        System.out.println("contains: " + cars.contains(car1));

        //4.size
        System.out.println("size: " + cars.size());

        //5.isEmpty
        System.out.println("isEmpty: " + cars.isEmpty());

        //6.clear
        cars.clear();
        System.out.println("clear: " + cars);

        //7.addAll
        ArrayList newCars = new ArrayList();
        newCars.add(car1);
        newCars.add(car2);
        newCars.add(car3);
        cars.addAll(newCars);
        System.out.println("addAll: " + cars);

        //8.containsAll
        cars.containsAll(newCars);
        System.out.println("containsAll: " + cars.containsAll(newCars));

        //9.removeAll
        cars.removeAll(newCars);
        System.out.println("removeAll: " + cars);

        //10.迭代器遍历
        cars.addAll(newCars);
        Iterator iterator = cars.iterator();
        while (iterator.hasNext()) {
            Car car = (Car) iterator.next();
            System.out.println(car);
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764135704737-002713b3-adc2-47db-971e-b089a55c8520.png)

## 练习3
1. 需求
    1. <font style="color:rgb(31, 35, 40);">使用HashMap类实例化一个Map类型的对象m，键(String)和值(int)分别用于存储员工的姓名和工资，存入数据如下:jack—650元; tom—1200元; smith——2900元;</font>
    2. <font style="color:rgb(31, 35, 40);">将jack的工资更改为2600元</font>
    3. <font style="color:rgb(31, 35, 40);">为所有员工工资加薪100元;</font>
    4. <font style="color:rgb(31, 35, 40);">遍历集合中所有的员工</font>
    5. <font style="color:rgb(31, 35, 40);">遍历集合所有的工资</font>
    6. <font style="color:rgb(31, 35, 40);">遍历集合中所有的员工及对应工资</font>
2. 实现

```java
package com.aurora.set.Practice;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

@SuppressWarnings("all")
public class Practice03 {
    public static void main(String[] args) {
        Map m =  new HashMap();
        m.put("jack", 650);
        m.put("tom", 1200);
        m.put("smith", 2900);
        System.out.println(m);

        //将jack的工资更改为2600元
        m.put("jack", 2600);
        System.out.println(m);

        //为所有员工工资加薪100元
        for (Object key : m.keySet()) {
            m.put(key, (Integer) m.get(key) + 100);
        }
        System.out.println(m);

        //遍历集合中所有的员工
        for (Object key : m.keySet()) {
            System.out.println(key);
        }

        //历集合所有的工资
        for (Object value : m.values()) {
            System.out.println(value);
        }

        //  遍历集合中所有的员工及对应工资
        Set entrySet = m.entrySet();
        Iterator iterator = entrySet.iterator();
        while (iterator.hasNext()) {
            Map.Entry entry = (Map.Entry) iterator.next();
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
    }
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764137302390-46bc1609-52b6-40a6-921d-1b5cb567ab2c.png)

## 练习4
<font style="color:rgb(31, 35, 40);">试分析HashSet和TreeSet分别如何实现去重的</font>

1. **<font style="color:rgb(31, 35, 40);">HashSet的去重机制</font>**<font style="color:rgb(31, 35, 40);">:hashCode() + equals() ,底层先通过存入对象,进行运算得到一个hash值，通过hash值得到对应的索引，如果发现table索引所在的位置,没有数据，就直接存放如果有数据，就进行equals比较[遍历比较]，如果比较后，不相同，就加入，否则就不加入。</font>
2. **<font style="color:rgb(31, 35, 40);">TreeSet的去重机制</font>**<font style="color:rgb(31, 35, 40);">:如果你传入了一个Comparator匿名对象，就使用实现的compare去重，如果方法返回0，就认为是相同的元素/数据，就不添加，如果你没有传入一个Comparator匿名对象,则以你添加的对象实现的Compareable接口的compareTo去重。</font>

## 练习5
<font style="color:rgb(31, 35, 40);">下面代码运行会不会抛出异常，并从源码层面说明原因。[考察读源码＋接口编程+动态绑定]</font>

```java
TreeSet treeSet = new TreeSet();
treeSet.add(new Person());
```

```java
package com.hspedu.homework;
import java.util.TreeSet;

@SuppressWarnings({"all"})
public class Homework05 {
    public static void main(String[] args) {
        TreeSet treeSet = new TreeSet();
        //分析源码
        //add 方法，因为 TreeSet() 构造器没有传入Comparator接口的匿名内部类
        //所以在底层 Comparable<? super K> k = (Comparable<? super K>) key;
        //即 把 Perosn转成 Comparable类型
        treeSet.add(new Person());//ClassCastException.
        treeSet.add(new Person());//ClassCastException.
        System.out.println(treeSet);

    }
}
class Person implements Comparable{

    @Override
    public int compareTo(Object o) {
        return 0; // 重写，永远都是0，此时就只能加一个对象
    }
}
```

**第一次添加 **`**add(new Person())**`**:**

+ **如果Person 类实现了 Comparable**：转型成功，调用 `compareTo`。
+ **如果Person 类没有实现 Comparable**：转型失败，抛出 `ClassCastException`。
+ **在代码中，**`**Person implements Comparable**`**，所以第一步安全通过。**

**第二次添加 **`**add(new Person())**`**:**

+ 因为 `compareTo` 永远返回 `0`，`TreeMap` （`TreeSet`底层是由`TreeMap`实现的）认为新对象和旧对象是“相等”的。它不会插入新节点，而是覆盖旧 Value（对于 TreeSet 来说 Value 都是同一个占位对象 `PRESENT`，所以看起来没变化）。

**总结考察点：**

接口编程：`TreeSet` 依赖 `Comparable` 接口来统一操作对象。如果没有比较器，它强行要求元素是 `Comparable` 的实例。

1. **异常原因**：`ClassCastException` 只有在对象**没有实现**`Comparable` 接口时才会抛出（试图将一个普通对象强转为接口类型）。
2. **动态绑定**：具体的比较逻辑取决于对象运行时类型 (`Person`) 的 `compareTo` 实现。

## 练习6
<font style="color:rgb(31, 35, 40);">下面的代码输出什么?这道题很有意思,稍不注意就掉进陷阱.</font>

<font style="color:rgb(31, 35, 40);">已知: Person类按照id和name重写了hashCode和equals方法（id和name相同的话就认定为同一个对象）, 问下面代码输出什么?</font>

```java
package com.hspedu.homework;

import java.util.HashSet;
import java.util.Objects;

@SuppressWarnings({"all"})
public class Homework06 {
    public static void main(String[] args) {
        HashSet set = new HashSet();//ok
        Person p1 = new Person(1001,"AA");//ok
        Person p2 = new Person(1002,"BB");//ok
        set.add(p1);//ok
        set.add(p2);//ok
        p1.name = "CC"; // 修改了原p1的name为CC
        set.remove(p1); // 可能删除失败，这里删除p1按照当前的1001和CC计算hash，那么这对应的位置与原p1不同
        System.out.println(set);// 2
        set.add(new Person(1001,"CC")); // 可以添加成功，添加到本来要删除的p1（实际删除失败）的位置
        System.out.println(set);// 3
        set.add(new Person(1001,"AA")); // 可以添加，因为原p1已经修改了
        System.out.println(set);// 4
    }
}

class Person {
    public String name;
    public int id;

    public Person(int id, String name) {
        this.name = name;
        this.id = id;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return id == person.id &&
                Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, id);
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", id=" + id +
                '}';
    }
}
```

**代码执行流程图解：**

| **步骤** | **操作** | **对象状态 (id, name)** | **计算出的 Hash 对应位置** | **实际查找/操作的位置** | **结果** | **Set 元素数** |
| --- | --- | --- | --- | --- | --- | --- |
| **1** | `set.add(p1)` | (1001, "AA") | Bucket A | Bucket A | 成功 (存入 p1) | 1 |
| **2** | `set.add(p2)` | (1002, "BB") | Bucket B | Bucket B | 成功 (存入 p2) | 2 |
| **3** | `p1.name="CC"` | p1 变为 (1001, "CC") | - | - | p1仍在 Bucket A，但其哈希值逻辑已变 | 2 |
| **4** | `set.remove(p1)` | p1 是 (1001, "CC") | Bucket C | Bucket C | 失败 (Bucket C 为空，找不到 p1) | 2 |
| **5** | `add(1001,"CC")` | 新对象 (1001, "CC") | Bucket C | Bucket C | 成功 (Bucket C 为空，直接存入) | 3 |
| **6** | `add(1001,"AA")` | 新对象 (1001, "AA") | Bucket A | Bucket A | 成功 (Bucket A 有 p1，但 p1 现在是 CC，equals 比较 false，挂在 p1 后面) | 4 |


## 练习7
<font style="color:rgb(31, 35, 40);">试写出Vector和ArrayList的比较</font>

![](https://cdn.nlark.com/yuque/0/2025/png/38867830/1764138902026-2a08c8c5-1039-4d71-bf94-9b1d36d35f78.png)

